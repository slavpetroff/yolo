{"p":"01","n":"01","t":"Execute Protocol Hardening","w":1,"d":[],"xd":[],"mh":{"tr":["All 10 steps have verification gates that block progression on missing artifacts","Every step transition commits execution-state.json with step name, status, timestamp","Skipped steps produce standardized output and state record","No step can advance without predecessor artifact verified"],"ar":[{"p":"references/execute-protocol.md","pv":"VERIFICATION GATE","c":"grep"}],"kl":[]},"obj":"Make the 10-step execute protocol self-enforcing with mandatory artifact verification gates, per-step commits, execution state tracking, and explicit skip documentation","sk":[],"fm":["references/execute-protocol.md"],"auto":true}
{"id":"T1","tp":"auto","a":"Add Verification Gate Protocol section defining the gate pattern (REQ-06). Insert a new section after Pre-Execution and before Step 1 titled '## Verification Gate Protocol' that defines: (1) the gate template each step must follow -- check artifact exists, check artifact is valid JSONL/TOON via jq or file test, block with STOP message if missing, (2) the state commit template -- update execution-state.json with step/status/timestamp and commit before proceeding, (3) the skip output template -- display format and state record format for skipped steps. This section becomes the reference that all 10 steps point to.","f":["references/execute-protocol.md"],"v":"Section exists between Pre-Execution and Step 1, contains artifact check template, state commit template, skip template","done":"Verification Gate Protocol section present with gate, commit, and skip templates","spec":"File: references/execute-protocol.md. Insert a new section BETWEEN the end of the 'Context Scoping Protocol' table (after line 45, the paragraph ending with 'not as raw context files.') and BEFORE '### Step 1: Critique / Brainstorm' (currently line 47). The new section heading is '## Verification Gate Protocol'. It contains three subsections:\n\n### 1. Gate Check Template (subsection '### Gate Check')\nInsert this exact template block:\n```\n**ENTRY GATE:** Verify {predecessor_artifact} exists in {phase-dir}.\n- File check: `[ -f \"{phase-dir}/{artifact}\" ]`\n- JSONL validity (if .jsonl): `jq empty \"{phase-dir}/{artifact}\" 2>/dev/null`\n- TOON validity (if .toon): `[ -s \"{phase-dir}/{artifact}\" ]`\n- If artifact was produced by a skippable step, also accept: step status is \"skipped\" in .execution-state.json (check via `jq -r '.steps[\"{step_name}\"].status' .yolo-planning/.execution-state.json`)\n- If NEITHER artifact exists NOR step is skipped: **STOP** \"{Step N} artifact missing — {artifact} not found in {phase-dir}. Run step {N} first.\"\n```\n\n### 2. State Commit Template (subsection '### State Commit')\nInsert this exact template block:\n```\n**EXIT GATE:** After step completes successfully:\n1. Update `.yolo-planning/.execution-state.json`:\n   - Set `steps.{step_name}.status` to `\"complete\"`\n   - Set `steps.{step_name}.completed_at` to ISO 8601 timestamp\n   - Set `steps.{step_name}.artifact` to the path of the produced artifact\n   - Set top-level `step` to `\"{step_name}\"`\n2. Verify this step's output artifact exists: `[ -f \"{phase-dir}/{output_artifact}\" ]`\n3. Commit: `chore(state): {step_name} complete phase {N}`\n```\n\n### 3. Skip Output Template (subsection '### Skip Output')\nInsert this exact template block:\n```\nWhen a step's Guard condition triggers a skip:\n1. Display: `○ {Step Name} skipped ({reason})`\n2. Update `.yolo-planning/.execution-state.json`:\n   - Set `steps.{step_name}.status` to `\"skipped\"`\n   - Set `steps.{step_name}.reason` to `\"{reason}\"`\n   - Set `steps.{step_name}.skipped_at` to ISO 8601 timestamp\n3. Commit: `chore(state): {step_name} skipped phase {N}`\n4. Proceed to next step.\n```\n\nAfter the three subsections, add a closing paragraph: 'Every step in the 10-step workflow below MUST follow these templates. Entry gates run before any step logic. Exit gates run after step logic completes. Skip output runs instead of step logic when guard conditions are met.'\n\nVerification: `grep -c 'ENTRY GATE\\|EXIT GATE\\|Skip Output' references/execute-protocol.md` should return 3+ matches (the templates themselves).","ts":""}
{"id":"T2","tp":"auto","a":"Add entry gate and exit gate to Steps 1-5 (REQ-01, REQ-04, REQ-05, REQ-06, REQ-07). For each step: (1) Add ENTRY GATE block at the top that verifies the predecessor step's artifact exists and is valid -- Step 1 has no entry gate (first step), Step 2 checks critique.jsonl exists (or was explicitly skipped), Step 3 checks architecture.toon exists, Step 4 checks plan.jsonl files exist, Step 5 checks enriched plan.jsonl has spec fields. (2) Add EXIT GATE block at the bottom that commits execution-state.json with current step completed and verifies this step's output artifact exists. (3) Standardize Guard clauses to use the skip output format from T1 -- Steps 1 and 5 already have guards, ensure they produce the standardized skip output and state record.","f":["references/execute-protocol.md"],"v":"Steps 1-5 each have ENTRY GATE and EXIT GATE blocks, grep for 'ENTRY GATE' returns 5+ matches in Steps 1-5 area","done":"Steps 1-5 have entry gates checking predecessor artifacts and exit gates committing state","spec":"File: references/execute-protocol.md. Modify Steps 1-5 sections. For each step, add an ENTRY GATE block immediately after the step heading (and after any existing Guard line), and add an EXIT GATE block as the last item in the step's numbered list. Preserve all existing content between them.\n\n### Step 1: Critique / Brainstorm (line 47)\nENTRY GATE: Step 1 is the first step — no predecessor artifact to check. Add this line after the existing Guard line (line 49): '**ENTRY GATE:** None (first step). Verify phase directory exists: `[ -d \"{phase-dir}\" ]`. If not: STOP \"Phase directory missing. Run /yolo:go --plan first.\"'\nGUARD REWRITE: Rewrite the existing Guard (line 49) to use the Skip Output template. Change from '**Guard:** Skip if `--effort=turbo` or critique.jsonl already exists in phase directory.' to:\n'**Guard:** If `--effort=turbo` or critique.jsonl already exists in phase directory → **Skip Output:** Display `○ Critique skipped ({reason: turbo effort | critique exists})`. Update `.execution-state.json`: set `steps.critique.status` to `\"skipped\"`, `steps.critique.reason` to `\"{turbo effort | critique.jsonl exists}\"`, `steps.critique.skipped_at` to ISO timestamp. Commit: `chore(state): critique skipped phase {N}`. Proceed to Step 2.'\nEXIT GATE: Add after the last numbered item (item 7, the user gate): '8. **EXIT GATE:** Verify `{phase-dir}/critique.jsonl` exists and is valid JSONL (`jq empty`). Update `.execution-state.json`: set `steps.critique.status` to `\"complete\"`, `steps.critique.completed_at` to ISO timestamp, `steps.critique.artifact` to `\"{phase-dir}/critique.jsonl\"`. Commit: `chore(state): critique complete phase {N}`.'\n\n### Step 2: Architecture (line 63)\nENTRY GATE: Add after the existing Guard line (line 65): '**ENTRY GATE:** Verify `{phase-dir}/critique.jsonl` exists OR `steps.critique.status` is `\"skipped\"` in `.execution-state.json`. If neither: STOP \"Step 1 artifact missing — critique.jsonl not found. Run step 1 first.\"'\nGUARD REWRITE: Rewrite Guard (line 65) to: '**Guard:** If architecture.toon already exists in phase directory → **Skip Output:** Display `○ Architecture skipped (architecture.toon exists)`. Update `.execution-state.json`: set `steps.architecture.status` to `\"skipped\"`, `steps.architecture.reason` to `\"architecture.toon exists\"`, `steps.architecture.skipped_at` to ISO timestamp. Commit: `chore(state): architecture skipped phase {N}`. Proceed to Step 3.'\nEXIT GATE: Add after item 5: '6. **EXIT GATE:** Verify `{phase-dir}/architecture.toon` exists and is non-empty (`[ -s ]`). Update `.execution-state.json`: set `steps.architecture.status` to `\"complete\"`, `steps.architecture.completed_at` to ISO timestamp, `steps.architecture.artifact` to `\"{phase-dir}/architecture.toon\"`. Commit: `chore(state): architecture complete phase {N}`.'\n\n### Step 3: Load Plans and Detect Resume State (line 76)\nENTRY GATE: Add after the heading (line 76): '**ENTRY GATE:** Verify `{phase-dir}/architecture.toon` exists OR `steps.architecture.status` is `\"skipped\"` in `.execution-state.json`. If neither: STOP \"Step 2 artifact missing — architecture.toon not found. Run step 2 first.\"'\nStep 3 has NO skip condition (it is mandatory). No Guard rewrite needed.\nEXIT GATE: Add after item 8 (cross-phase deps): '9. **EXIT GATE:** Verify `.yolo-planning/.execution-state.json` exists with `status: \"running\"` and at least one plan entry. Verify at least one `*.plan.jsonl` exists in phase dir. Update `.execution-state.json`: set `steps.planning.status` to `\"complete\"`, `steps.planning.completed_at` to ISO timestamp. Commit: `chore(state): planning complete phase {N}`.'\n\n### Step 4: Design Review (line 99)\nENTRY GATE: Add after the delegation directive line (line 101): '**ENTRY GATE:** Verify at least one `*.plan.jsonl` file exists in phase dir (`ls {phase-dir}/*.plan.jsonl`). If none: STOP \"Step 3 artifact missing — no plan.jsonl files found. Run step 3 first.\"'\nStep 4 has NO skip condition (it is mandatory). No Guard rewrite needed.\nEXIT GATE: Add after item 6 (the verify step): '7. **EXIT GATE:** For each plan.jsonl, verify all tasks have non-empty `spec` field (`jq -r .spec` on each task line is non-empty). Update `.execution-state.json`: set `steps.design_review.status` to `\"complete\"`, `steps.design_review.completed_at` to ISO timestamp, `steps.design_review.artifact` to `\"enriched plan.jsonl\"`. Commit: `chore(state): design_review complete phase {N}`.'\n\n### Step 5: Test Authoring (line 115)\nENTRY GATE: Add after the existing Guard line (line 117): '**ENTRY GATE:** Verify enriched plan.jsonl exists with `spec` fields populated (check at least one task has non-empty `spec` via `jq -r .spec`). If not: STOP \"Step 4 artifact missing — plan.jsonl tasks have no spec fields. Run step 4 first.\"'\nGUARD REWRITE: Rewrite Guard (line 117) to: '**Guard:** If `--effort=turbo` or no tasks have `ts` fields in any plan.jsonl → **Skip Output:** Display `○ Test Authoring skipped ({reason: turbo effort | no ts fields})`. Update `.execution-state.json`: set `steps.test_authoring.status` to `\"skipped\"`, `steps.test_authoring.reason` to `\"{turbo effort | no ts fields}\"`, `steps.test_authoring.skipped_at` to ISO timestamp. Commit: `chore(state): test_authoring skipped phase {N}`. Proceed to Step 6.'\nEXIT GATE: Add after item 8 (the display line): '9. **EXIT GATE:** Verify `{phase-dir}/test-plan.jsonl` exists with valid JSONL (`jq empty`) and all entries have `red: true`. Update `.execution-state.json`: set `steps.test_authoring.status` to `\"complete\"`, `steps.test_authoring.completed_at` to ISO timestamp, `steps.test_authoring.artifact` to `\"{phase-dir}/test-plan.jsonl\"`. Commit: `chore(state): test_authoring complete phase {N}`.'\n\nVerification: `grep -c 'ENTRY GATE' references/execute-protocol.md` should return at least 5 matches in the Steps 1-5 region. `grep -c 'EXIT GATE' references/execute-protocol.md` should return at least 5 matches in the Steps 1-5 region.","ts":""}
{"id":"T3","tp":"auto","a":"Add entry gate and exit gate to Steps 6-10 (REQ-01, REQ-04, REQ-05, REQ-06, REQ-07). For each step: (1) Add ENTRY GATE block -- Step 6 checks test-plan.jsonl exists (or step 5 skipped), Step 7 checks summary.jsonl exists for each plan, Step 8 checks code-review.jsonl with r:approve, Step 9 checks verification.jsonl exists (or QA skipped), Step 10 checks security-audit.jsonl (or security skipped). (2) Add EXIT GATE block that commits execution-state.json and verifies output artifact. (3) Standardize Guard clauses for Steps 8 and 9 which have skip conditions (--skip-qa, --skip-security) to use the skip output format and state record from T1.","f":["references/execute-protocol.md"],"v":"Steps 6-10 each have ENTRY GATE and EXIT GATE blocks, grep for 'ENTRY GATE' returns 10 total matches across all steps","done":"Steps 6-10 have entry gates checking predecessor artifacts and exit gates committing state","spec":"File: references/execute-protocol.md. Modify Steps 6-10 sections. Same pattern as T2: ENTRY GATE after heading/guard, EXIT GATE as last item.\n\n### Step 6: Implementation (currently line 132)\nENTRY GATE: Add after the heading: '**ENTRY GATE:** Verify enriched plan.jsonl exists with `spec` fields populated. If test-plan.jsonl should exist (step 5 was not skipped): verify `{phase-dir}/test-plan.jsonl` exists with `red: true` entries. Check via: `jq -r '.steps.test_authoring.status' .yolo-planning/.execution-state.json` — if `\"complete\"`, verify test-plan.jsonl exists; if `\"skipped\"`, proceed without it. If step 5 is `\"complete\"` but test-plan.jsonl missing: STOP \"Step 5 artifact missing — test-plan.jsonl not found. Run step 5 first.\"'\nStep 6 has NO skip condition (it is mandatory). No Guard rewrite needed.\nEXIT GATE: Add after the 'Summary verification gate' block (after the existing item about marking plan complete in execution-state.json, currently around line 162): '**EXIT GATE:** For each plan, verify `{phase-dir}/{plan_id}.summary.jsonl` exists with valid JSONL. Update `.execution-state.json`: set `steps.implementation.status` to `\"complete\"`, `steps.implementation.completed_at` to ISO timestamp, `steps.implementation.artifact` to `\"summary.jsonl\"`. Commit: `chore(state): implementation complete phase {N}`.'\n\n### Step 7: Code Review (currently line 164)\nENTRY GATE: Add after the heading: '**ENTRY GATE:** For each plan, verify `{phase-dir}/{plan_id}.summary.jsonl` exists with valid JSONL (`jq empty`). If not: STOP \"Step 6 artifact missing — summary.jsonl not found for plan {plan_id}. Run step 6 first.\"'\nStep 7 has NO skip condition (it is mandatory). No Guard rewrite needed.\nEXIT GATE: Add after item 8 (the verify line): '9. **EXIT GATE:** Verify `{phase-dir}/code-review.jsonl` exists with `r: \"approve\"` in line 1 verdict (`jq -r .r`). Update `.execution-state.json`: set `steps.code_review.status` to `\"complete\"`, `steps.code_review.completed_at` to ISO timestamp, `steps.code_review.artifact` to `\"{phase-dir}/code-review.jsonl\"`. Commit: `chore(state): code_review complete phase {N}`.'\n\n### Step 8: QA (currently line 187)\nENTRY GATE: Add after the existing skip line (line 189): '**ENTRY GATE:** Verify `{phase-dir}/code-review.jsonl` exists with `r: \"approve\"` in line 1 (`jq -r .r` equals `\"approve\"`). If not: STOP \"Step 7 artifact missing — code-review.jsonl not found or not approved. Run step 7 first.\"'\nGUARD REWRITE: Rewrite the existing skip line (line 189, 'If `--skip-qa` or turbo: ...') to: '**Guard:** If `--skip-qa` or `--effort=turbo` → **Skip Output:** Display `○ QA skipped ({reason: --skip-qa flag | turbo effort})`. Update `.execution-state.json`: set `steps.qa.status` to `\"skipped\"`, `steps.qa.reason` to `\"{--skip-qa | turbo effort}\"`, `steps.qa.skipped_at` to ISO timestamp. Commit: `chore(state): qa skipped phase {N}`. Proceed to Step 9.'\nEXIT GATE: Add after item 12 (the last QA item about proceed to step 9): '13. **EXIT GATE:** Verify `{phase-dir}/verification.jsonl` exists with valid JSONL (`jq empty`). Verify `{phase-dir}/qa-code.jsonl` exists with valid JSONL. Update `.execution-state.json`: set `steps.qa.status` to `\"complete\"`, `steps.qa.completed_at` to ISO timestamp, `steps.qa.artifact` to `\"{phase-dir}/verification.jsonl\"`. Commit: `chore(state): qa complete phase {N}`.'\n\n### Step 9: Security Audit (currently line 244)\nENTRY GATE: Add after the existing skip line (line 246): '**ENTRY GATE:** Verify `{phase-dir}/verification.jsonl` exists OR `steps.qa.status` is `\"skipped\"` in `.execution-state.json`. If neither: STOP \"Step 8 artifact missing — verification.jsonl not found. Run step 8 first.\"'\nGUARD REWRITE: Rewrite the existing skip line (line 246, 'If `--skip-security` or config ...') to: '**Guard:** If `--skip-security` or config `security_audit` != true → **Skip Output:** Display `○ Security audit skipped ({reason: --skip-security flag | security_audit disabled})`. Update `.execution-state.json`: set `steps.security.status` to `\"skipped\"`, `steps.security.reason` to `\"{--skip-security | security_audit disabled}\"`, `steps.security.skipped_at` to ISO timestamp. Commit: `chore(state): security skipped phase {N}`. Proceed to Step 10.'\nEXIT GATE: Add after item 7 (the last security item): '8. **EXIT GATE:** Verify `{phase-dir}/security-audit.jsonl` exists with valid JSONL (`jq empty`). Update `.execution-state.json`: set `steps.security.status` to `\"complete\"`, `steps.security.completed_at` to ISO timestamp, `steps.security.artifact` to `\"{phase-dir}/security-audit.jsonl\"`. Commit: `chore(state): security complete phase {N}`.'\n\n### Step 10: Sign-off (currently line 261)\nENTRY GATE: Add after the heading: '**ENTRY GATE:** Verify `{phase-dir}/security-audit.jsonl` exists OR `steps.security.status` is `\"skipped\"` in `.execution-state.json`. Also verify `{phase-dir}/code-review.jsonl` exists with `r: \"approve\"`. If security artifact missing AND security not skipped: STOP \"Step 9 artifact missing — security-audit.jsonl not found. Run step 9 first.\"'\nStep 10 has NO skip condition (it is mandatory). No Guard rewrite needed.\nEXIT GATE: Add after item 7 (suggest-next.sh): '8. **EXIT GATE:** Verify `.execution-state.json` has `status: \"complete\"` and `step: \"signoff\"`. Verify ROADMAP.md is updated. Final state commit already done in item 5 — no additional commit needed.'\n\nVerification: `grep -c 'ENTRY GATE' references/execute-protocol.md` should return exactly 10 matches total (one per step). `grep -c 'EXIT GATE' references/execute-protocol.md` should return exactly 10 matches total (one per step).","ts":""}
{"id":"T4","tp":"auto","a":"Rewrite the Execution State Transitions table into a mandatory checklist (REQ-05). Replace the current documentation-only table (lines 297-312) with: (1) A prescriptive table that includes columns for step, state.step value, entry artifact (what must exist), exit artifact (what this step produces), commit message format, and skip conditions. (2) Add explicit language that this table is the enforcement contract -- go.md MUST check each row before and after each step. (3) Add execution-state.json schema update to include per-step entries with status (pending/running/complete/skipped), started_at, completed_at, artifact_path, and skip_reason fields.","f":["references/execute-protocol.md"],"v":"Table has entry_artifact and exit_artifact columns, schema shows per-step status tracking","done":"Transitions table is prescriptive with entry/exit artifacts, state schema has per-step tracking","spec":"File: references/execute-protocol.md. Replace the ENTIRE '## Execution State Transitions' section (currently lines 297-312, from the heading through 'Each transition commits .execution-state.json so resume works on exit.') with the following content:\n\n## Execution State Transitions (Enforcement Contract)\n\n**This table is the enforcement contract.** go.md MUST verify the Entry Artifact column before running each step and verify the Exit Artifact column after each step completes. No exceptions.\n\nThen insert this exact table:\n\n| Step | state.step | Entry Artifact | Exit Artifact | Commit Format | Skip Conditions |\n|------|-----------|----------------|---------------|---------------|----------------|\n| 1. Critique | `critique` | Phase dir exists | `critique.jsonl` | `docs({phase}): critique and gap analysis` | `--effort=turbo`, critique.jsonl exists |\n| 2. Architecture | `architecture` | `critique.jsonl` OR step 1 skipped | `architecture.toon` | `docs({phase}): architecture design` | architecture.toon exists |\n| 3. Load Plans | `planning` | `architecture.toon` OR step 2 skipped | `.execution-state.json` + `*.plan.jsonl` | `chore(state): execution state phase {N}` | NONE (mandatory) |\n| 4. Design Review | `design_review` | `*.plan.jsonl` exists | enriched `plan.jsonl` (all tasks have `spec`) | `docs({phase}): enrich plan {NN-MM} specs` | NONE (mandatory) |\n| 5. Test Authoring | `test_authoring` | enriched `plan.jsonl` with `spec` fields | `test-plan.jsonl` + test files | `test({phase}): RED phase tests for plan {NN-MM}` | `--effort=turbo`, no `ts` fields |\n| 6. Implementation | `implementation` | enriched `plan.jsonl` + `test-plan.jsonl` (if step 5 ran) | `{plan_id}.summary.jsonl` per plan | `{type}({phase}-{plan}): {task}` per task | NONE (mandatory) |\n| 7. Code Review | `code_review` | `{plan_id}.summary.jsonl` for each plan | `code-review.jsonl` with `r: \"approve\"` | `docs({phase}): code review {NN-MM}` | NONE (mandatory) |\n| 8. QA | `qa` | `code-review.jsonl` with `r: \"approve\"` | `verification.jsonl` + `qa-code.jsonl` | `docs({phase}): verification results` | `--skip-qa`, `--effort=turbo` |\n| 9. Security | `security` | `verification.jsonl` OR step 8 skipped | `security-audit.jsonl` | `docs({phase}): security audit` | `--skip-security`, config `security_audit` != true |\n| 10. Sign-off | `signoff` | `security-audit.jsonl` OR step 9 skipped + `code-review.jsonl` approved | `.execution-state.json` complete + ROADMAP.md | `chore(state): phase {N} complete` | NONE (mandatory) |\n\nAfter the table, add:\n\nEach transition commits `.execution-state.json` so resume works on exit. The `steps` object in `.execution-state.json` tracks per-step state:\n\nThen add this JSON schema block:\n```json\n{\n  \"phase\": 1,\n  \"phase_name\": \"{slug}\",\n  \"status\": \"running\",\n  \"started_at\": \"{ISO 8601}\",\n  \"step\": \"{current_step_name}\",\n  \"wave\": 1,\n  \"total_waves\": 1,\n  \"plans\": [{\"id\": \"NN-MM\", \"title\": \"...\", \"wave\": 1, \"status\": \"pending|complete\"}],\n  \"steps\": {\n    \"critique\": {\"status\": \"complete|skipped|pending\", \"started_at\": \"{ISO}\", \"completed_at\": \"{ISO}\", \"artifact\": \"{path}\", \"reason\": \"\"},\n    \"architecture\": {\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"},\n    \"planning\": {\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"},\n    \"design_review\": {\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"},\n    \"test_authoring\": {\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"},\n    \"implementation\": {\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"},\n    \"code_review\": {\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"},\n    \"qa\": {\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"},\n    \"security\": {\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"},\n    \"signoff\": {\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"}\n  }\n}\n```\n\nAfter the schema block, add: 'Per-step status values: `\"pending\"` (not started), `\"running\"` (in progress), `\"complete\"` (finished successfully), `\"skipped\"` (guard condition triggered). The `reason` field is populated only for skipped steps. The `artifact` field stores the path to the step output file. Step 3 (Load Plans) initializes this `steps` object with all 10 entries set to `\"pending\"`.'\n\nAlso update the existing `.execution-state.json` schema in Step 3 (currently lines 84-92) to include the new `steps` object. Add the `steps` key to the JSON block shown there, with all 10 step entries initialized to `{\"status\": \"pending\", \"started_at\": \"\", \"completed_at\": \"\", \"artifact\": \"\", \"reason\": \"\"}`.\n\nVerification: `grep -c 'Entry Artifact\\|Exit Artifact\\|Enforcement Contract' references/execute-protocol.md` should return 3 (one heading mention + two column headers in the table header row).","ts":""}
{"id":"T5","tp":"auto","a":"Add skip documentation requirements to all skippable steps (REQ-07). Identify every step with skip conditions: Step 1 (turbo effort, critique.jsonl exists), Step 5 (turbo effort, no ts fields), Step 8 (--skip-qa, turbo), Step 9 (--skip-security, config). For each: (1) Ensure the Guard clause explicitly shows the skip output line format as displayed output, (2) Add execution-state.json update with status:skipped and reason field, (3) Ensure the exit gate still fires (state commit) even on skip. Also add a paragraph to the Verification Gate Protocol section (from T1) stating that non-skippable steps (2, 3, 4, 6, 7, 10) have NO skip path -- if they fail, execution halts with a STOP message.","f":["references/execute-protocol.md"],"v":"grep for 'skipped' returns entries in Steps 1, 5, 8, 9 with standardized format, non-skippable steps documented","done":"All skippable steps have standardized skip output and state recording, non-skippable steps documented as mandatory","spec":"File: references/execute-protocol.md. This task adds two things: (A) a mandatory/skippable classification paragraph in the Verification Gate Protocol section from T1, and (B) explicit skip documentation in Steps 2, 8, and 9 guard clauses (Steps 1 and 5 guards were already rewritten in T2; Steps 8 and 9 guards were already rewritten in T3; Step 2 guard was already rewritten in T2).\n\n### Part A: Add classification paragraph to Verification Gate Protocol section\nAppend the following paragraph to the END of the Verification Gate Protocol section (after the closing paragraph added by T1, before Step 1):\n\n'### Mandatory vs Skippable Steps\n\nSkippable steps (have Guard conditions that allow skip):\n- **Step 1 — Critique:** Skip when `--effort=turbo` or `critique.jsonl` already exists.\n- **Step 2 — Architecture:** Skip when `architecture.toon` already exists.\n- **Step 5 — Test Authoring:** Skip when `--effort=turbo` or no tasks have `ts` fields.\n- **Step 8 — QA:** Skip when `--skip-qa` flag or `--effort=turbo`.\n- **Step 9 — Security:** Skip when `--skip-security` flag or config `security_audit` != true.\n\nMandatory steps (NO skip path — failure halts execution with STOP):\n- **Step 3 — Load Plans:** Must always run to initialize execution state.\n- **Step 4 — Design Review:** Must always run to enrich specs.\n- **Step 6 — Implementation:** Must always run to produce code.\n- **Step 7 — Code Review:** Must always run to verify quality.\n- **Step 10 — Sign-off:** Must always run to finalize phase.\n\nIf a mandatory step fails, execution halts with a STOP message. There is no `--force` override for mandatory steps. The only recovery is to fix the issue and re-run.'\n\n### Part B: Verify all skippable steps have complete skip documentation\nFor each of the 5 skippable steps, verify (after T2 and T3 have run) that the Guard clause contains ALL THREE required elements:\n1. Display line in format: `○ {Step Name} skipped ({reason})`\n2. execution-state.json update with `status: \"skipped\"` and `reason` field\n3. State commit: `chore(state): {step_name} skipped phase {N}`\n\nIf T2/T3 missed any of these three elements in any guard, add the missing element. The specific guards to verify are:\n- Step 1 Guard (rewritten by T2): Must have skip display, state update with `steps.critique.status: skipped`, state commit.\n- Step 2 Guard (rewritten by T2): Must have skip display, state update with `steps.architecture.status: skipped`, state commit.\n- Step 5 Guard (rewritten by T2): Must have skip display, state update with `steps.test_authoring.status: skipped`, state commit.\n- Step 8 Guard (rewritten by T3): Must have skip display, state update with `steps.qa.status: skipped`, state commit.\n- Step 9 Guard (rewritten by T3): Must have skip display, state update with `steps.security.status: skipped`, state commit.\n\nSince T2 and T3 specs already include all three elements in their guard rewrites, Part B is a verification pass. If any guard is incomplete, add the missing text. No new text is needed if T2/T3 are implemented correctly.\n\nVerification: `grep -c 'Mandatory.*steps\\|Skippable.*steps\\|NO skip path' references/execute-protocol.md` should return 3+ matches. `grep -c 'status.*skipped' references/execute-protocol.md` should return at least 5 matches (one per skippable step guard).","ts":""}
