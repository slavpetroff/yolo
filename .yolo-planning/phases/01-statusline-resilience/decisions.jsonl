{"ts":"2026-02-18T23:00:00Z","agent":"architect","task":"scoping","dec":"Phase 01 is standalone statusline fix — no dependency on persona work","reason":"REQ-10 is a script bug fix in yolo-statusline.sh (427 lines). Completely orthogonal to agent prompt changes. Can run in parallel with Phase 02.","alts":["Bundle with persona as a single phase — rejected: unrelated concerns"]}
{"ts":"2026-02-18T23:00:01Z","agent":"architect","task":"scoping","dec":"Root cause: OSC 8 invisible bytes + no line length budgeting + variable-width progress bars","reason":"Claude Code issue #14011 confirms OSC 8 escape sequence bytes are counted as visible width, causing misalignment. Issue #5430 confirms COLUMNS is not available in statusline context. Combined with YOLO's 20-char fixed-width progress bars and dense L3 (session+weekly+sonnet+extra), lines easily exceed 200 chars visible.","alts":["Remove OSC 8 links entirely — too aggressive, links are useful","Hardcode 80-char limit — too narrow, most terminals are 120+"]}
{"ts":"2026-02-18T23:00:02Z","agent":"architect","task":"scoping","dec":"Width budget approach: compute visible char width (stripping ANSI+OSC8), truncate/elide segments to fit","reason":"Since COLUMNS is unavailable, use a configurable max width (default 120). Strip invisible bytes to measure true visible width. Dynamically shrink progress bars or elide text segments when over budget. This is the approach used by ccstatusline and other statusline tools.","alts":["Use stty to read parent terminal width — fragile on non-POSIX, fails on Windows","Accept wrapping — poor UX"]}
{"ts":"2026-02-18T23:10:00Z","agent":"lead","task":"decomposition","dec":"3-plan decomposition: infrastructure (wave 1), line integration (wave 2), tests (wave 2)","reason":"Plan 01-01 builds the utility functions (visible_width, truncate_line, compute_bar_width) that Plans 01-02 and 01-03 both depend on. Separating line integration from tests avoids file conflicts in wave 2 (01-02 touches yolo-statusline.sh, 01-03 touches yolo-statusline.bats). Each plan has 4 tasks within the 3-5 constraint.","alts":["2 plans (infra+integration in one, tests in another) — rejected: would exceed 5 tasks per plan","4 plans (one per line) — rejected: too granular, L2 and L4 are small"]}
{"ts":"2026-02-18T23:10:01Z","agent":"lead","task":"decomposition","dec":"Dual truncation strategy: pre-construction budget (Plan 01-02) + post-construction truncate_line (Plan 01-01 T4)","reason":"Pre-construction budgeting (shrink bars, drop segments) preserves semantic meaning. Post-construction truncate_line is a safety net that hard-truncates if pre-construction still exceeded budget. Both are needed: budget handles graceful degradation, truncate handles edge cases.","alts":["Only post-construction truncation — loses semantic segments unpredictably","Only pre-construction budgeting — hard to guarantee MAX_WIDTH without a safety net"]}
{"ts":"2026-02-18T23:10:02Z","agent":"lead","task":"dependency","dec":"Wave ordering: 01-01 (wave 1) -> 01-02, 01-03 (wave 2, parallel)","reason":"01-02 and 01-03 have no file overlap (scripts/ vs tests/) so they can execute in parallel. Both depend on the infrastructure functions from 01-01.","alts":["All sequential (wave 1, 2, 3) — unnecessary, adds latency"]}
{"ts":"2026-02-18T23:30:00Z","agent":"architect","task":"architecture","dec":"Use full ECMA-48 CSI regex [0-9;]*[a-zA-Z] for visible_width instead of SGR-only [0-9;]*m","reason":"CSI grammar allows any final byte 0x40-0x7E. Future-proofs against cursor/erase codes. Research R-C1 confirms pattern. Addresses C1 (critical).","alts":["SGR-only m-terminated regex (fragile)","Full intermediate-byte support [0-9;]*[!-/]*[A-Z@-~] (overkill)"]}
{"ts":"2026-02-18T23:30:01Z","agent":"architect","task":"architecture","dec":"Implement truncate_line as 3-state awk parser (Ground/CSI/OSC8) instead of pure bash","reason":"Awk char-by-char via substr is 10-50x faster than bash $var:i:1 loops. State machine is the only correct approach for mid-escape truncation. POSIX awk compatible. Research R-C2 confirms. Addresses C2 (critical).","alts":["Pure bash for loop (correct but slow ~5-15ms vs ~1ms)","sed-based approach (cannot track cross-boundary state)","External python (violates zero-dependency constraint)"]}
{"ts":"2026-02-18T23:30:02Z","agent":"architect","task":"architecture","dec":"Separate visible_width() measurement from strip_osc8_links() degradation as distinct functions","reason":"Measurement strips invisible parts for counting. Degradation replaces hyperlinks with plain text. Same sed pattern but different semantic purpose. Conflating them caused the original bug. Addresses C3 (major).","alts":["Single function with mode flag (adds branching in hot path)","Inline sed in each call site (duplicates logic)"]}
{"ts":"2026-02-18T23:30:03Z","agent":"architect","task":"architecture","dec":"Two-pass line construction for L3 (and L1 during execution): skeleton with placeholders then real bars","reason":"ANSI codes consume raw bytes but zero visible width. Cannot know remaining budget without measuring skeleton first. Standard approach per tmux/powerline/vim. Research R-C4 confirms. Addresses C4 (major).","alts":["Single-pass with estimated overhead (error-prone)","Measure-after-build then rebuild if over (wastes full construction cycle)"]}
{"ts":"2026-02-18T23:30:04Z","agent":"architect","task":"architecture","dec":"Extract utility functions to scripts/statusline-utils.sh for testability","reason":"Current script cannot be sourced without triggering pipeline (reads stdin at line 5). Extracting enables direct unit testing of visible_width, truncate_line via source. Standard bash testing practice. Research R-C7 confirms. Addresses C7 (major).","alts":["BASH_SOURCE guard in single file (still sources 400+ lines for 5 functions)","Test via subprocess only (tests test helper not real function)"]}
{"ts":"2026-02-18T23:30:05Z","agent":"architect","task":"architecture","dec":"MAX_WIDTH=120 with YOLO_MAX_WIDTH env var override, no safety margin subtraction","reason":"Root cause of wrapping was OSC 8 escape bytes counted as visible width, not a 120 vs 118 margin issue. 120 chars on 120-col terminal fills exactly without wrapping. Env var provides escape hatch. Addresses C5 (major).","alts":["MAX_WIDTH=118 (unnecessary margin, wastes 2 chars)","MAX_WIDTH=119 (unnecessary margin, wastes 1 char)"]}
{"ts":"2026-02-18T23:45:00Z","agent":"senior","task":"T1-spec","dec":"visible_width chains strip_ansi (which chains strip_osc8_links + CSI strip) rather than duplicating sed patterns","reason":"DRY principle. strip_osc8_links and strip_ansi are useful independently (strip_osc8_links for degradation, strip_ansi for tests). visible_width calls strip_ansi then wc -m. This avoids 3 separate sed patterns that could drift out of sync.","alts":["Inline all sed passes in visible_width (duplication risk)","Single monolithic sed with multiple expressions (harder to read/maintain)"]}
{"ts":"2026-02-18T23:45:01Z","agent":"senior","task":"T2-spec","dec":"truncate_line fast path checks visible_width before invoking awk parser","reason":"Most lines will be within MAX_WIDTH after budget construction (plan 01-02). The fast path avoids spawning awk for the common case, reducing subprocess overhead from 4 awk invocations to 0 per render. Only lines that actually overflow pay the awk cost. Per C10/IP4 optimization.","alts":["Always run awk (simpler but 4 unnecessary subprocesses per render)","Cache width from budget pass in a variable (requires cross-function state, messier)"]}
{"ts":"2026-02-18T23:45:02Z","agent":"senior","task":"01-02-T1-spec","dec":"L3 uses rebuild approach (reconstruct with fewer segments) rather than sed-based segment removal","reason":"Removing segments from ANSI-encoded strings via sed is fragile (escape sequences break patterns). Rebuilding from original variables is deterministic and easier to test. The _l3_rebuild function takes a segment list and constructs the line fresh each iteration.","alts":["sed-based segment stripping (fragile with ANSI codes)","Pre-compute all segment combinations (exponential, wasteful)"]}
{"ts":"2026-02-18T23:45:03Z","agent":"senior","task":"01-02-T2-spec","dec":"L1 uses rebuild approach for width budgeting rather than sed-based segment removal","reason":"Same rationale as L3. Rebuilding L1 from variables with include_diff/include_commits/include_files/include_qa flags is deterministic. The sed approach would need to parse complex ANSI patterns for each segment type, which is error-prone.","alts":["sed-based L1 segment stripping (fragile)","Truncate-only approach (loses semantic segments unpredictably)"]}
{"ts":"2026-02-18T23:45:04Z","agent":"senior","task":"01-03-spec","dec":"Tests source statusline-utils.sh for direct function testing rather than using subprocess wrappers","reason":"Per TD5, the utility library was extracted specifically for testability. Sourcing it in bats setup() makes all functions available as shell functions. This tests the ACTUAL implementation, not a test-specific mirror. Addresses C7 concern about testing test helpers instead of real functions.","alts":["Subprocess-based testing (tests a shell invocation, not the function)","Duplicate function logic in test helpers (tests the copy, not the original)"]}
{"ts":"2026-02-18T23:45:05Z","agent":"senior","task":"01-03-spec","dec":"Integration tests use mock slow-cache files rather than stubbing curl/security","reason":"The statusline script reads from cache files when they are fresh. Writing a pre-populated cache file directly is simpler and more reliable than mocking the entire OAuth + curl flow. The cache format is a known pipe-delimited string. This tests the rendering path, not the data fetching path.","alts":["Mock curl to return JSON (more complex, tests fetching not rendering)","Use env vars to inject test data (would require script changes)"]}
{"ts":"2026-02-18T23:45:06Z","agent":"senior","task":"plan-enrichment","dec":"Updated plan 01-01 file targets from yolo-statusline.sh to statusline-utils.sh for T1-T3","reason":"Architecture TD5 specifies utility functions go in scripts/statusline-utils.sh. The original plan had all tasks targeting yolo-statusline.sh. Tasks T1 (visible_width), T2 (truncate_line), T3 (compute_bar_width) create functions in the new utils file. Only T4 (source + safety net) modifies yolo-statusline.sh.","alts":["Keep all in yolo-statusline.sh (violates TD5, blocks unit testing per C7)"]}
