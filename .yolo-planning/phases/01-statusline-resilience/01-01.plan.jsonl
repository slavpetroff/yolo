{"p":"01","n":"01","t":"Width measurement and truncation infrastructure","w":1,"d":[],"xd":[],"mh":{"tr":["visible_width strips ANSI escapes and OSC 8 sequences","visible_width returns integer character count","progress_bar accepts dynamic width parameter (8-20)","MAX_WIDTH variable defaults to 120","truncate_line truncates to MAX_WIDTH based on visible width"],"ar":[{"p":"scripts/statusline-utils.sh","pv":"visible_width()","c":"visible_width"},{"p":"scripts/statusline-utils.sh","pv":"truncate_line()","c":"truncate_line"},{"p":"scripts/statusline-utils.sh","pv":"MAX_WIDTH=","c":"MAX_WIDTH"},{"p":"scripts/statusline-utils.sh","pv":"strip_osc8_links()","c":"strip_osc8_links"},{"p":"scripts/statusline-utils.sh","pv":"strip_ansi()","c":"strip_ansi"},{"p":"scripts/statusline-utils.sh","pv":"compute_bar_width()","c":"compute_bar_width"}],"kl":[{"fr":"truncate_line","to":"visible_width","vi":"truncate_line calls visible_width to measure"},{"fr":"progress_bar","to":"MAX_WIDTH","vi":"progress_bar width parameter derived from MAX_WIDTH budget"},{"fr":"strip_ansi","to":"strip_osc8_links","vi":"strip_ansi calls strip_osc8_links then strips CSI"}]},"obj":"Create scripts/statusline-utils.sh with visible_width, truncate_line, strip_osc8_links, compute_bar_width, strip_ansi; source from yolo-statusline.sh","sk":["commit"],"fm":["scripts/statusline-utils.sh","scripts/yolo-statusline.sh"]}
{"id":"T1","tp":"auto","a":"Create scripts/statusline-utils.sh with MAX_WIDTH, visible_width(), strip_osc8_links(), and strip_ansi(). This is a NEW file per TD5.","f":["scripts/statusline-utils.sh"],"ts":"Test visible_width returns correct count for plain text, ANSI-colored text, OSC 8 hyperlinked text, mixed ANSI+OSC8, and non-m CSI sequences (e.g. \\033[K). Test strip_osc8_links replaces hyperlink with visible text. Test strip_ansi returns visible-only text.","v":"visible_width returns correct char count for ANSI+OSC8 input; strip_osc8_links outputs plain text; strip_ansi outputs visible text only","done":"scripts/statusline-utils.sh exists with MAX_WIDTH, visible_width, strip_osc8_links, strip_ansi functions. File has no side effects when sourced.","td":[],"spec":"CREATE new file: scripts/statusline-utils.sh (~60 lines for this task, will grow in T2-T3).\n\nFile structure:\n```\n#!/usr/bin/env bash\n# statusline-utils.sh -- Sourceable utility library for yolo-statusline.sh\n# No side effects when sourced. All functions are pure (input->stdout).\n# Portable: BSD sed (-E flag) + POSIX awk. Uses $'\\x1b' for literal ESC.\n\n# --- Width configuration (TD6) ---\nMAX_WIDTH=\"${YOLO_MAX_WIDTH:-120}\"\n\n# Literal ESC character for portable sed (R4 mitigation)\nESC=$'\\x1b'\n\n# --- strip_osc8_links() ---\n# Replace OSC 8 hyperlinks with their visible text content (TD2 degradation).\n# Pattern: ESC]8;params;URI ST visible_text ESC]8;; ST -> visible_text\n# ST (String Terminator) = ESC \\\\ (0x1b 0x5c)\nstrip_osc8_links() {\n  printf '%s' \"$1\" | sed -E \"s/${ESC}\\]8;[^${ESC}]*${ESC}\\\\\\\\([^${ESC}]*)${ESC}\\]8;;${ESC}\\\\\\\\/\\1/g\"\n}\n\n# --- strip_ansi() ---\n# Strip ALL invisible escape sequences, returning visible-text-only string.\n# Combines strip_osc8_links (extract hyperlink text) + CSI removal (TD1).\nstrip_ansi() {\n  local no_osc8\n  no_osc8=$(strip_osc8_links \"$1\")\n  printf '%s' \"$no_osc8\" | sed -E \"s/${ESC}\\[[0-9;]*[a-zA-Z]//g\"\n}\n\n# --- visible_width() ---\n# Return visible character count of a string with ANSI CSI and/or OSC 8.\n# Algorithm (architecture component spec):\n#   1. Strip OSC 8 wrappers keeping visible text (sed pass 1 via strip_osc8_links)\n#   2. Strip all CSI sequences (sed pass 2 per TD1: ESC [ params final)\n#   3. Count remaining chars: printf '%s' | wc -m | tr -d ' '\n# Uses wc -m (character count) not wc -c (byte count) for UTF-8 safety.\nvisible_width() {\n  local stripped\n  stripped=$(strip_ansi \"$1\")\n  printf '%s' \"$stripped\" | wc -m | tr -d ' '\n}\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. ESC variable: Define `ESC=$'\\x1b'` once at top. Use `$ESC` inside sed double-quoted strings. This avoids BSD sed \\x1b portability issue (R4).\n2. sed -E flag: Works on both GNU and BSD sed. Do NOT use -r (GNU only).\n3. CSI regex per TD1: `${ESC}\\[[0-9;]*[a-zA-Z]` -- matches ESC [ {digits/semicolons} {any letter}. This covers SGR (m), erase (K,J), cursor (H,f,A-F), scroll (s-u).\n4. OSC 8 regex per TD2: `${ESC}\\]8;[^${ESC}]*${ESC}\\\\\\\\([^${ESC}]*)${ESC}\\]8;;${ESC}\\\\\\\\` -- captures visible text in group 1. The ST is ESC followed by backslash. In sed double-quoted string with -E, need `${ESC}\\\\\\\\` for literal ESC + backslash.\n5. No side effects: File must NOT read stdin, write files, or execute commands at source time. Only function definitions and variable assignments.\n6. strip_osc8_links reuses the same sed as visible_width step 1 but returns the string (for degradation) vs visible_width which counts chars.\n7. visible_width calls strip_ansi (which chains strip_osc8_links + CSI strip) then counts with wc -m.\n\nEDGE CASES:\n- Empty string input: visible_width returns 0. strip_ansi returns empty. strip_osc8_links returns empty.\n- String with only escape codes (no visible text): visible_width returns 0.\n- Multiple OSC 8 links in same string: sed /g flag handles all occurrences.\n- Non-m CSI sequences (e.g. \\033[2K erase line): stripped by [a-zA-Z] final byte match.\n- Nested ANSI inside OSC 8 visible text: strip_osc8_links preserves inner ANSI, strip_ansi then removes it."}
{"id":"T2","tp":"auto","a":"Add truncate_line() function to scripts/statusline-utils.sh. Implements the 3-state awk parser per TD3.","f":["scripts/statusline-utils.sh"],"ts":"Test truncate_line: (1) string under MAX_WIDTH returned unchanged, (2) long plain text truncated to MAX_WIDTH chars, (3) ANSI-colored text truncated preserving reset code, (4) truncation inside CSI sequence completes the sequence, (5) truncation inside OSC 8 emits closing sequence + reset, (6) empty string returns empty.","v":"truncate_line output <= MAX_WIDTH visible chars for all inputs; ANSI reset appended when truncated","done":"truncate_line() function exists in scripts/statusline-utils.sh, uses awk 3-state parser, appends reset on truncation","td":["T1"],"spec":"APPEND to scripts/statusline-utils.sh (after strip_ansi, before end of file).\n\nFunction signature: truncate_line \"string\" [max_width]\n  - $1 = input string (may contain ANSI CSI + OSC 8 sequences)\n  - $2 = optional max visible width (defaults to $MAX_WIDTH)\n  - stdout = truncated string (or original if already fits)\n\nAlgorithm (TD3 + performance optimization):\n```\ntruncate_line() {\n  local input=\"$1\"\n  local limit=\"${2:-$MAX_WIDTH}\"\n  \n  # Fast path: if visible_width <= limit, return unchanged (skip awk)\n  local w\n  w=$(visible_width \"$input\")\n  [ \"$w\" -le \"$limit\" ] && { printf '%s' \"$input\"; return; }\n  \n  # Slow path: awk 3-state parser\n  printf '%s' \"$input\" | awk -v max=\"$limit\" '\n  BEGIN {\n    ORS = \"\"\n    state = 0  # 0=ground, 1=CSI, 2=OSC8\n    vis = 0\n    buf = \"\"\n    done = 0\n  }\n  {\n    n = length($0)\n    for (i = 1; i <= n; i++) {\n      c = substr($0, i, 1)\n      \n      if (done && state == 0) break\n      \n      if (state == 0) {\n        # Ground state\n        if (c == \"\\033\") {\n          # Check next char for CSI or OSC\n          if (i < n) {\n            nc = substr($0, i+1, 1)\n            if (nc == \"[\") {\n              state = 1  # Enter CSI\n              buf = buf c\n              continue\n            } else if (nc == \"]\") {\n              state = 2  # Enter OSC (likely OSC 8)\n              buf = buf c\n              continue\n            }\n          }\n          buf = buf c  # Lone ESC, append\n        } else {\n          # Visible character\n          if (vis < max) {\n            buf = buf c\n            vis++\n          } else {\n            done = 1\n          }\n        }\n      } else if (state == 1) {\n        # CSI state: accumulate until final byte [a-zA-Z]\n        buf = buf c\n        if (c ~ /[a-zA-Z]/) {\n          state = 0  # CSI complete\n        }\n      } else if (state == 2) {\n        # OSC8 state: accumulate until ST (ESC \\\\)\n        buf = buf c\n        if (c == \"\\\\\" && i >= 2 && substr($0, i-1, 1) == \"\\033\") {\n          state = 0  # ST reached, back to ground\n        }\n      }\n    }\n  }\n  END {\n    # If we truncated while inside OSC8, emit closing sequence\n    if (state == 2) {\n      buf = buf \"\\033]8;;\\033\\\\\"\n    }\n    # Append reset if we actually truncated\n    if (done || state != 0) {\n      buf = buf \"\\033[0m\"\n    }\n    print buf\n  }'\n}\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. POSIX awk compatibility (R1): Use substr(s, i, 1) in a for loop, NOT gawk-specific split(\"\", arr). macOS ships /usr/bin/awk which is nawk/mawk.\n2. Fast path: Call visible_width first. If <= limit, return input unchanged. This avoids awk for the common case (most lines fit). Per IP4/C10 optimization.\n3. State machine: 3 states per TD3. Ground=0 (increment vis per visible char). CSI=1 (consume until [a-zA-Z] final byte). OSC8=2 (consume until ESC backslash ST).\n4. When vis reaches max in Ground state, set done=1 but continue consuming if inside an escape sequence. This prevents mid-escape truncation.\n5. OSC 8 cleanup: If truncation happens inside an open OSC 8 hyperlink (state==2), emit the closing sequence `\\033]8;;\\033\\\\` to avoid corrupting the terminal.\n6. Reset code: Always append `\\033[0m` when truncation occurred (done==1 or ended in non-ground state). This resets any open color/bold/dim.\n7. awk receives input via pipe (printf '%s' | awk), not as argument. This handles strings with special characters safely.\n8. The awk uses literal \\033 for ESC character. In awk, \\033 is octal for ESC (0x1b). This is POSIX-compliant."}
{"id":"T3","tp":"auto","a":"Add compute_bar_width() function to scripts/statusline-utils.sh. Calculates per-bar width clamped to [MIN_BAR, MAX_BAR].","f":["scripts/statusline-utils.sh"],"ts":"Test compute_bar_width: (1) large budget returns 20, (2) minimal budget returns MIN_BAR (3), (3) zero budget returns 0 (drop signal), (4) budget for 4 bars at 80 available returns 20, (5) budget for 4 bars at 12 available returns 3, (6) budget for 4 bars at 8 available returns 0 (drop signal).","v":"compute_bar_width returns clamped value in [3,20] or 0 for drop signal","done":"compute_bar_width() exists in scripts/statusline-utils.sh, returns integer clamped to [3,20] or 0","td":["T1"],"spec":"APPEND to scripts/statusline-utils.sh (after truncate_line, before end of file).\n\nFunction signature: compute_bar_width available_width num_bars\n  - $1 = available_width (integer, total chars available for all bars)\n  - $2 = num_bars (integer, number of progress bars to fit)\n  - stdout = integer per-bar width, clamped to [MIN_BAR, MAX_BAR] or 0\n\nConstants (define at top of file, near MAX_WIDTH):\n```\nMIN_BAR=3\nMAX_BAR=20\n```\n\nImplementation:\n```\ncompute_bar_width() {\n  local available=\"$1\" num_bars=\"$2\"\n  \n  # Guard: zero bars means nothing to compute\n  [ \"$num_bars\" -le 0 ] && { echo 0; return; }\n  \n  local per_bar=$((available / num_bars))\n  \n  # Clamp to [MIN_BAR, MAX_BAR] or signal drop with 0\n  if [ \"$per_bar\" -lt \"$MIN_BAR\" ]; then\n    echo 0  # Signal: drop a segment\n  elif [ \"$per_bar\" -gt \"$MAX_BAR\" ]; then\n    echo \"$MAX_BAR\"\n  else\n    echo \"$per_bar\"\n  fi\n}\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. Return value 0 is the DROP SIGNAL per architecture. Caller must check: if compute_bar_width returns 0, drop the rightmost segment and recalculate with N-1 bars.\n2. MIN_BAR=3 (not 8 as originally planned). Architecture specifies clamp(per_bar, 3, 20) with 0 as drop signal when < 3. The value 3 allows very compact bars (3 chars = meaningful visual).\n3. MAX_BAR=20 matches the current hardcoded bar width in progress_bar calls throughout yolo-statusline.sh.\n4. Integer division: bash $(()) truncates toward zero. 11/4=2 which is < MIN_BAR=3, so returns 0. This is correct behavior.\n5. available_width is the space available for ALL bars combined, not per-bar. Caller computes: available = MAX_WIDTH - skeleton_width_without_bars."}
{"id":"T4","tp":"auto","a":"Modify scripts/yolo-statusline.sh to source statusline-utils.sh and apply truncate_line safety net to all 4 output lines (L1-L4) at lines 422-425.","f":["scripts/yolo-statusline.sh"],"ts":"Test that all 4 output lines respect MAX_WIDTH when data is dense. Set YOLO_MAX_WIDTH=60 and provide input that would produce >60 char lines. Assert all lines <= 60 visible chars.","v":"All 4 lines pass through truncate_line before output; source statement exists","done":"yolo-statusline.sh sources statusline-utils.sh; printf calls use truncate_line; no line exceeds MAX_WIDTH","td":["T2"],"spec":"MODIFY existing file: scripts/yolo-statusline.sh. Two changes:\n\nCHANGE 1: Add source statement + degradation order comment (after line 9, before line 11).\nInsert after the color definitions (line 9: `D='\\033[2m' B='\\033[1m' X='\\033[0m'`) and before the cached platform info section (line 12: `_UID=$(id -u)`):\n\n```bash\n# --- Width-limiting utilities (TD5) ---\nsource \"$(dirname \"$0\")/statusline-utils.sh\"\n\n# DEGRADATION ORDER (C8 â€” per-line segment drop priority, rightmost = first to drop):\n# L1 (project): [YOLO] Phase Plans Effort Model QA Branch Files Commits Diff\n#   -> drop: Diff -> Commits -> Files -> QA -> Model -> Effort -> Plans\n#   -> OSC 8 link degrades to plain text before any segment drops\n# L2 (context): Context: [BAR] PCT% tokens | Tokens: in out | Cache: hit% wr rd\n#   -> Shrink bar (20->12->8) -> abbreviate labels (write->wr, read->rd)\n# L3 (usage): Session: [BAR] % | Weekly: [BAR] % | Sonnet: [BAR] % | Extra: [BAR] % $/$\n#   -> Shrink all bars (20->12->8->3) -> drop Extra -> drop Sonnet\n# L4 (model): Model: name | Time: dur (API: dur) | agents | YOLO ver -> ver | CC ver\n#   -> Drop update text -> drop agent line -> abbreviate versions\n```\n\nCHANGE 2: Replace the final printf block (lines 422-425) with truncate_line-wrapped output.\nCurrent code:\n```bash\nprintf '%b\\n' \"$L1\"\nprintf '%b\\n' \"$L2\"\nprintf '%b\\n' \"$L3\"\nprintf '%b\\n' \"$L4\"\n```\n\nReplace with:\n```bash\n# Safety-net truncation (IP4): truncate_line ensures no line exceeds MAX_WIDTH.\n# Lines that already went through budget construction (L1, L2, L3 in plan 01-02)\n# will pass the fast path (visible_width check) and skip awk.\nprintf '%b\\n' \"$(truncate_line \"$L1\")\"\nprintf '%b\\n' \"$(truncate_line \"$L2\")\"\nprintf '%b\\n' \"$(truncate_line \"$L3\")\"\nprintf '%b\\n' \"$(truncate_line \"$L4\")\"\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. source path: Use `$(dirname \"$0\")/statusline-utils.sh` to resolve relative to the script location. This works regardless of CWD.\n2. The source statement MUST come after color definitions (C, G, Y, R, D, B, X on lines 8-9) because statusline-utils.sh does not define colors.\n3. The source statement MUST come before any function call that uses visible_width or truncate_line.\n4. truncate_line is called via command substitution inside printf '%b\\n'. The %b format interprets backslash escapes, which is needed for ANSI codes.\n5. Per C10/IP4: This is the safety net. Plan 01-02 will add pre-construction budget passes for L1-L3 that ensure width compliance BEFORE reaching this point. Those lines will hit truncate_line's fast path (visible_width check passes, awk skipped). L4 and edge cases will use the awk path.\n6. Do NOT remove the existing `exit 0` on line 427.\n7. The DEGRADATION ORDER comment block is placed near the top per C8, adjacent to where the source of statusline-utils.sh brings in MAX_WIDTH."}
