{"p":"01","n":"03","t":"Width-limited rendering tests","w":2,"d":["01-01"],"xd":[],"mh":{"tr":["All existing 8 tests continue to pass","New tests cover visible_width with ANSI and OSC 8 input","New tests cover each line variant under width constraint","Tests verify progress bars shrink before text drops"],"ar":[{"p":"tests/unit/yolo-statusline.bats","pv":"visible_width strips ANSI","c":"visible_width"},{"p":"tests/unit/yolo-statusline.bats","pv":"L3 fits within MAX_WIDTH","c":"width budget"}],"kl":[{"fr":"tests/unit/yolo-statusline.bats","to":"scripts/statusline-utils.sh","vi":"tests source statusline-utils.sh for direct function tests"},{"fr":"tests/unit/yolo-statusline.bats","to":"scripts/yolo-statusline.sh","vi":"integration tests invoke full statusline via run_statusline"}]},"obj":"Add comprehensive test coverage for width measurement, truncation, and per-line width budget behavior","sk":["commit"],"fm":["tests/unit/yolo-statusline.bats"]}
{"id":"T1","tp":"auto","a":"Add source of statusline-utils.sh in test setup and add direct unit tests for visible_width, strip_ansi, and strip_osc8_links. Tests: (1) plain text returns correct length, (2) ANSI colored text returns text-only length, (3) OSC 8 hyperlink returns link-text-only length, (4) mixed ANSI+OSC8 returns correct count, (5) non-m CSI sequence (\\033[K) returns correct count, (6) strip_osc8_links replaces hyperlink with visible text, (7) strip_ansi returns visible-only text.","f":["tests/unit/yolo-statusline.bats"],"ts":"7 tests for visible_width, strip_osc8_links, and strip_ansi using direct function calls via sourced statusline-utils.sh","v":"7 visible_width/strip tests pass","done":"Source of statusline-utils.sh in setup, 7 passing direct function tests","td":[],"spec":"MODIFY tests/unit/yolo-statusline.bats: Add to setup() and add new test cases.\n\nCHANGE 1: Add source of statusline-utils.sh in setup() function (after SUT assignment, before cache cleanup).\nAfter line `SUT=\"$SCRIPTS_DIR/yolo-statusline.sh\"`, add:\n```bash\n  # Source utility library for direct function testing (TD5)\n  source \"$SCRIPTS_DIR/statusline-utils.sh\"\n```\n\nCHANGE 2: Add 7 new test cases after the existing 8 tests (after line 104).\n\n```bash\n# ============================================================\n# Direct function tests (sourced from statusline-utils.sh)\n# ============================================================\n\n# --- 9. visible_width: plain text ---\n@test \"visible_width returns correct count for plain text\" {\n  local result\n  result=$(visible_width \"hello world\")\n  [ \"$result\" -eq 11 ]\n}\n\n# --- 10. visible_width: ANSI colored text ---\n@test \"visible_width strips ANSI SGR codes\" {\n  local colored=$'\\033[31mred text\\033[0m'\n  local result\n  result=$(visible_width \"$colored\")\n  [ \"$result\" -eq 8 ]  # \"red text\" = 8 chars\n}\n\n# --- 11. visible_width: OSC 8 hyperlink ---\n@test \"visible_width strips OSC 8 hyperlinks\" {\n  local linked=$'\\033]8;;https://github.com/example\\033\\\\Link Text\\033]8;;\\033\\\\'\n  local result\n  result=$(visible_width \"$linked\")\n  [ \"$result\" -eq 9 ]  # \"Link Text\" = 9 chars\n}\n\n# --- 12. visible_width: mixed ANSI + OSC 8 ---\n@test \"visible_width handles mixed ANSI and OSC 8\" {\n  local mixed=$'\\033[1m\\033[36m\\033]8;;https://example.com\\033\\\\bold cyan link\\033]8;;\\033\\\\\\033[0m plain'\n  local result\n  result=$(visible_width \"$mixed\")\n  [ \"$result\" -eq 21 ]  # \"bold cyan link plain\" = 15 + 1 + 5 = 21 chars\n}\n\n# --- 13. visible_width: non-m CSI sequence (C1 critique) ---\n@test \"visible_width strips non-m CSI sequences like erase-line\" {\n  local with_erase=$'hello\\033[Kworld'\n  local result\n  result=$(visible_width \"$with_erase\")\n  [ \"$result\" -eq 10 ]  # \"helloworld\" = 10 chars (\\033[K is invisible)\n}\n\n# --- 14. strip_osc8_links: replaces hyperlink with visible text ---\n@test \"strip_osc8_links replaces hyperlink with visible text\" {\n  local linked=$'prefix \\033]8;;https://github.com/repo\\033\\\\repo:main\\033]8;;\\033\\\\ suffix'\n  local result\n  result=$(strip_osc8_links \"$linked\")\n  [ \"$result\" = \"prefix repo:main suffix\" ]\n}\n\n# --- 15. strip_ansi: returns visible-only text ---\n@test \"strip_ansi removes all escape sequences\" {\n  local complex=$'\\033[1m\\033[36mBold Cyan\\033[0m \\033]8;;https://x.com\\033\\\\Link\\033]8;;\\033\\\\ end'\n  local result\n  result=$(strip_ansi \"$complex\")\n  [ \"$result\" = \"Bold Cyan Link end\" ]\n}\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. Source path: `source \"$SCRIPTS_DIR/statusline-utils.sh\"` where SCRIPTS_DIR is set by common.bash to `$PROJECT_ROOT/scripts`. This makes visible_width, strip_ansi, strip_osc8_links, truncate_line, compute_bar_width available as functions.\n2. Use `$'...'` syntax for literal ESC characters in test strings. `$'\\033'` = ESC (0x1b). `$'\\033\\\\'` = ESC + backslash (the ST = String Terminator for OSC 8).\n3. OSC 8 format: `ESC]8;;URL ST visible_text ESC]8;; ST` where ST = `ESC \\\\`.\n4. Test 12 (mixed): Count carefully. `bold cyan link` = 14 chars, space = 1, `plain` = 5. Total = 20... verify by counting: b-o-l-d-' '-c-y-a-n-' '-l-i-n-k = 14, ' ' = 1, p-l-a-i-n = 5. Total = 20. Adjust the expected value accordingly. Actually recount: 'bold cyan link plain' -- b(1)o(2)l(3)d(4) (5)c(6)y(7)a(8)n(9) (10)l(11)i(12)n(13)k(14) (15)p(16)l(17)a(18)i(19)n(20). So result should be 20.\n5. Test 13 (C1 critique): Specifically tests a non-m CSI sequence `\\033[K` (erase line). This verifies the regex uses `[a-zA-Z]` as final byte, not just `m`.\n6. The existing 8 tests (lines 42-104) must NOT be modified. New tests are appended after them.\n7. Bats convention: Use descriptive @test names that map to the function being tested."}
{"id":"T2","tp":"auto","a":"Add tests for truncate_line and compute_bar_width using direct function calls. Tests: (1) truncate_line returns unchanged string when under limit, (2) truncate_line truncates long plain text, (3) truncate_line preserves ANSI reset on truncation, (4) truncate_line handles empty string, (5) truncate_line with custom max_width param, (6) compute_bar_width returns 20 for large budget, (7) compute_bar_width returns MIN_BAR for tight budget, (8) compute_bar_width returns 0 for insufficient budget.","f":["tests/unit/yolo-statusline.bats"],"ts":"8 tests for truncate_line and compute_bar_width","v":"8 truncate_line/compute_bar_width tests pass","done":"8 passing direct function tests for truncate_line and compute_bar_width","td":["T1"],"spec":"APPEND to tests/unit/yolo-statusline.bats (after the T1 tests).\n\n```bash\n# ============================================================\n# truncate_line tests\n# ============================================================\n\n# --- 16. truncate_line: under limit returns unchanged ---\n@test \"truncate_line returns unchanged string when under MAX_WIDTH\" {\n  MAX_WIDTH=120  # Ensure it is set\n  local short=\"Hello World\"\n  local result\n  result=$(truncate_line \"$short\")\n  [ \"$result\" = \"$short\" ]\n}\n\n# --- 17. truncate_line: long plain text truncated ---\n@test \"truncate_line truncates long plain text to MAX_WIDTH\" {\n  MAX_WIDTH=10\n  local long=\"abcdefghijklmnopqrstuvwxyz\"\n  local result\n  result=$(truncate_line \"$long\")\n  local width\n  width=$(visible_width \"$result\")\n  [ \"$width\" -le 10 ]\n  # Verify it starts with the expected prefix\n  [[ \"$result\" == abcdefghij* ]]\n}\n\n# --- 18. truncate_line: preserves ANSI reset on truncation ---\n@test \"truncate_line appends reset code when truncating colored text\" {\n  MAX_WIDTH=5\n  local colored=$'\\033[31mredredredredred\\033[0m'\n  local result\n  result=$(truncate_line \"$colored\")\n  # Result should end with reset code \\033[0m\n  [[ \"$result\" == *$'\\033[0m' ]]\n  # Visible width should be <= 5\n  local width\n  width=$(visible_width \"$result\")\n  [ \"$width\" -le 5 ]\n}\n\n# --- 19. truncate_line: empty string returns empty ---\n@test \"truncate_line returns empty for empty input\" {\n  local result\n  result=$(truncate_line \"\")\n  [ -z \"$result\" ]\n}\n\n# --- 20. truncate_line: custom max_width parameter ---\n@test \"truncate_line respects custom max_width parameter\" {\n  MAX_WIDTH=120  # Default is large\n  local long=\"abcdefghijklmnopqrstuvwxyz\"\n  local result\n  result=$(truncate_line \"$long\" 15)  # Override to 15\n  local width\n  width=$(visible_width \"$result\")\n  [ \"$width\" -le 15 ]\n  [ \"$width\" -ge 14 ]  # Should use most of the budget\n}\n\n# ============================================================\n# compute_bar_width tests\n# ============================================================\n\n# --- 21. compute_bar_width: large budget returns MAX_BAR ---\n@test \"compute_bar_width returns 20 for large budget\" {\n  local result\n  result=$(compute_bar_width 100 2)\n  [ \"$result\" -eq 20 ]  # 100/2=50, clamped to MAX_BAR=20\n}\n\n# --- 22. compute_bar_width: tight budget returns MIN_BAR ---\n@test \"compute_bar_width returns MIN_BAR for tight budget\" {\n  local result\n  result=$(compute_bar_width 12 4)\n  [ \"$result\" -eq 3 ]  # 12/4=3, exactly MIN_BAR\n}\n\n# --- 23. compute_bar_width: insufficient budget returns 0 (drop signal) ---\n@test \"compute_bar_width returns 0 for insufficient budget\" {\n  local result\n  result=$(compute_bar_width 8 4)\n  [ \"$result\" -eq 0 ]  # 8/4=2, below MIN_BAR -> drop signal\n}\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. truncate_line tests override MAX_WIDTH directly since the variable is sourced into the test shell from statusline-utils.sh. Setting `MAX_WIDTH=10` before calling truncate_line changes its behavior.\n2. Test 17: After truncation, visible_width of result should be <= MAX_WIDTH. The actual visible content should be the first 10 chars of the input.\n3. Test 18: Verifies that truncation of a colored string appends `\\033[0m` reset. Use `[[ == *pattern ]]` for suffix matching.\n4. Test 20: truncate_line takes optional $2 for max_width override. This tests the parameter passing.\n5. compute_bar_width tests use the MIN_BAR=3, MAX_BAR=20 constants from statusline-utils.sh.\n6. Test 21: 100/2=50, but MAX_BAR=20, so clamped to 20.\n7. Test 22: 12/4=3, exactly MIN_BAR=3, returned as-is.\n8. Test 23: 8/4=2, below MIN_BAR=3, returns 0 (drop signal)."}
{"id":"T3","tp":"auto","a":"Add integration tests for L3 and L1 width compliance. Create mock fixtures that trigger all 4 usage segments. Test that L3 visible width <= MAX_WIDTH with all segments active. Test L1 with long branch name and OSC 8 link stays within MAX_WIDTH. Test execution mode L1 with long plan name.","f":["tests/unit/yolo-statusline.bats"],"ts":"4 integration tests: L3 with all usage data, L3 with YOLO_MAX_WIDTH=80, L1 with long branch, L1 in execution mode","v":"L3 and L1 width assertion tests pass","done":"4 L3+L1 integration width tests pass","td":["T1"],"spec":"APPEND to tests/unit/yolo-statusline.bats (after the T2 tests).\n\nThese are INTEGRATION tests that run the full statusline script and measure output line widths. They depend on plan 01-02 being implemented (the budget construction for L1/L3). However, even before 01-02, the truncate_line safety net from 01-01 T4 will ensure width compliance. The tests validate the end result regardless of which mechanism enforces it.\n\n```bash\n# ============================================================\n# Integration: L3 width compliance\n# ============================================================\n\n# Helper: extract Nth line from statusline output and measure visible width\n_measure_line_width() {\n  local line_num=\"$1\"\n  local line\n  line=$(echo \"$output\" | sed -n \"${line_num}p\")\n  visible_width \"$line\"\n}\n\n# --- 24. L3 fits within MAX_WIDTH with all 4 usage segments ---\n@test \"L3 visible width <= 120 with all usage segments\" {\n  # Create mock OAuth cache that returns all 4 segments\n  mkdir -p \"$TEST_WORKDIR/bin\"\n  local cache_file=\"/tmp/yolo-${_VER:-0}-$(id -u)-slow\"\n  # Format: FIVE_PCT|FIVE_EPOCH|WEEK_PCT|WEEK_EPOCH|SONNET_PCT|EXTRA_ENABLED|EXTRA_PCT|EXTRA_USED_C|EXTRA_LIMIT_C|FETCH_OK|UPDATE_AVAIL\n  printf '%s\\n' \"75|0|42|0|88|1|65|1500|5000|ok|\" > \"$cache_file\"\n  chmod 600 \"$cache_file\"\n  \n  run_statusline\n  assert_success\n  \n  # L3 is line 3 of output\n  local l3_width\n  l3_width=$(_measure_line_width 3)\n  [ \"$l3_width\" -le 120 ]\n  \n  rm -f \"$cache_file\"\n}\n\n# --- 25. L3 fits within narrow MAX_WIDTH ---\n@test \"L3 visible width <= 80 with YOLO_MAX_WIDTH=80\" {\n  local cache_file=\"/tmp/yolo-${_VER:-0}-$(id -u)-slow\"\n  printf '%s\\n' \"75|0|42|0|88|1|65|1500|5000|ok|\" > \"$cache_file\"\n  chmod 600 \"$cache_file\"\n  \n  # Override MAX_WIDTH via env var\n  run bash -c \"cd '$TEST_WORKDIR' && YOLO_MAX_WIDTH=80 PATH='$TEST_WORKDIR/bin:$PATH' printf '%s' '$STATUS_INPUT' | bash '$SUT'\"\n  assert_success\n  \n  local l3_width\n  local line3\n  line3=$(echo \"$output\" | sed -n '3p')\n  l3_width=$(visible_width \"$line3\")\n  [ \"$l3_width\" -le 80 ]\n  \n  rm -f \"$cache_file\"\n}\n\n# ============================================================\n# Integration: L1 width compliance\n# ============================================================\n\n# --- 26. L1 fits within MAX_WIDTH with long branch and OSC 8 ---\n@test \"L1 visible width <= 120 with long branch name\" {\n  mk_planning_dir\n  mk_state_json 2 5 \"executing\"\n  \n  # Create a git repo with a long branch name\n  cd \"$TEST_WORKDIR\"\n  git init -q\n  git config user.email \"test@test.com\"\n  git config user.name \"Test\"\n  echo init > README.md\n  git add README.md && git commit -q -m \"init\"\n  git checkout -q -b feature/very-long-branch-name-that-might-cause-overflow-issues\n  # Add a remote to trigger OSC 8 link\n  git remote add origin https://github.com/example/my-really-long-repository-name.git\n  \n  run_statusline\n  assert_success\n  \n  # L1 is line 1 of output\n  local l1_width\n  local line1\n  line1=$(echo \"$output\" | sed -n '1p')\n  l1_width=$(visible_width \"$line1\")\n  [ \"$l1_width\" -le 120 ]\n}\n\n# --- 27. L1 in execution mode fits within MAX_WIDTH ---\n@test \"L1 visible width <= 120 in execution mode with long plan name\" {\n  mk_planning_dir\n  # Create execution state with a long plan name\n  cat > \"$TEST_WORKDIR/.yolo-planning/.execution-state.json\" <<'EXEC_EOF'\n{\"status\":\"running\",\"wave\":2,\"total_waves\":3,\"plans\":[{\"status\":\"complete\"},{\"status\":\"complete\"},{\"status\":\"running\",\"title\":\"Implement comprehensive error handling and validation for all API endpoints\"},{\"status\":\"pending\"},{\"status\":\"pending\"}]}\nEXEC_EOF\n  \n  run_statusline\n  assert_success\n  \n  local l1_width\n  local line1\n  line1=$(echo \"$output\" | sed -n '1p')\n  l1_width=$(visible_width \"$line1\")\n  [ \"$l1_width\" -le 120 ]\n}\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. The _measure_line_width helper uses `sed -n Np` to extract the Nth line from multi-line output. It calls visible_width (sourced from statusline-utils.sh) to measure.\n2. Mock slow cache: The slow cache file format is `FIVE_PCT|FIVE_EPOCH|WEEK_PCT|WEEK_EPOCH|SONNET_PCT|EXTRA_ENABLED|EXTRA_PCT|EXTRA_USED_C|EXTRA_LIMIT_C|FETCH_OK|UPDATE_AVAIL`. Setting SONNET_PCT=88 and EXTRA_ENABLED=1 triggers all 4 segments.\n3. Cache file ownership: Use `chmod 600` and ensure it is owned by current user (created in test = owned by test user). The script checks `[ -O \"$cache_file\" ]` (owned by effective UID).\n4. The _VER variable in cache file name: statusline reads VERSION from `$(dirname \"$0\")/../VERSION`. In tests, SUT points to the real script, so VERSION is read from the real file. Use the same _VER construction to build the cache path.\n5. Test 25 (narrow MAX_WIDTH): Uses YOLO_MAX_WIDTH=80 env var in the run command. Cannot just set MAX_WIDTH because the script sources statusline-utils.sh which sets MAX_WIDTH from YOLO_MAX_WIDTH.\n6. Test 26 (long branch): Creates a real git repo with a 60+ char branch name and a remote URL to trigger OSC 8 link generation. The combination of YOLO header + phase info + long OSC 8 link + git stats would exceed 120 chars without width budgeting.\n7. Test 27 (execution mode): Creates .execution-state.json with status=running and a long plan title. The exec mode L1 format includes the plan title which can push it over.\n8. Clean up cache files in both the test and teardown. The existing teardown already removes `/tmp/yolo-*-$(id -u)*`."}
{"id":"T4","tp":"auto","a":"Add tests for L2 and L4 width compliance, and verify all existing tests still pass. Test L2 with large token counts (force long formatted numbers). Test L4 with update available and multiple agents. Verify visible width <= 120 for both. Run full test suite to confirm no regressions in existing 8 tests.","f":["tests/unit/yolo-statusline.bats"],"ts":"4 tests: L2 width compliance, L4 width compliance, L4 with narrow MAX_WIDTH, regression check (existing 8 tests pass)","v":"L2+L4 width tests pass, all existing tests pass","done":"All width tests pass, no regressions in existing 8 tests","td":["T1"],"spec":"APPEND to tests/unit/yolo-statusline.bats (after the T3 tests).\n\n```bash\n# ============================================================\n# Integration: L2 and L4 width compliance\n# ============================================================\n\n# --- 28. L2 fits within MAX_WIDTH with large token counts ---\n@test \"L2 visible width <= 120 with large token counts\" {\n  # Use STATUS_INPUT with large token values\n  local big_input='{\"context_window\":{\"used_percentage\":95,\"remaining_percentage\":5,\"current_usage\":{\"input_tokens\":5500000,\"output_tokens\":1200000,\"cache_creation_input_tokens\":3500000,\"cache_read_input_tokens\":8500000},\"context_window_size\":200000},\"cost\":{\"total_cost_usd\":45.67,\"total_duration_ms\":7200000,\"total_api_duration_ms\":5400000,\"total_lines_added\":5000,\"total_lines_removed\":2000},\"model\":{\"display_name\":\"Claude Sonnet\"},\"version\":\"1.2.3\"}'\n  \n  run_statusline \"$big_input\"\n  assert_success\n  \n  # L2 is line 2 of output\n  local l2_width\n  local line2\n  line2=$(echo \"$output\" | sed -n '2p')\n  l2_width=$(visible_width \"$line2\")\n  [ \"$l2_width\" -le 120 ]\n}\n\n# --- 29. L4 fits within MAX_WIDTH with update and agents ---\n@test \"L4 visible width <= 120 with update notification\" {\n  # Create slow cache with update available\n  local cache_file=\"/tmp/yolo-${_VER:-0}-$(id -u)-slow\"\n  printf '%s\\n' \"50|0|30|0|-1|0|-1|0|0|ok|9.9.9\" > \"$cache_file\"\n  chmod 600 \"$cache_file\"\n  \n  # Stub pgrep to return multiple agents\n  printf '#!/bin/bash\\necho 5\\n' > \"$TEST_WORKDIR/bin/pgrep\"\n  chmod +x \"$TEST_WORKDIR/bin/pgrep\"\n  \n  # Force fast cache refresh\n  rm -f \"/tmp/yolo-${_VER:-0}-$(id -u)-fast\" 2>/dev/null\n  \n  run_statusline\n  assert_success\n  \n  # L4 is line 4 of output\n  local l4_width\n  local line4\n  line4=$(echo \"$output\" | sed -n '4p')\n  l4_width=$(visible_width \"$line4\")\n  [ \"$l4_width\" -le 120 ]\n  \n  rm -f \"$cache_file\"\n}\n\n# --- 30. L4 fits within narrow MAX_WIDTH ---\n@test \"L4 visible width <= 70 with YOLO_MAX_WIDTH=70\" {\n  local cache_file=\"/tmp/yolo-${_VER:-0}-$(id -u)-slow\"\n  printf '%s\\n' \"50|0|30|0|-1|0|-1|0|0|ok|9.9.9\" > \"$cache_file\"\n  chmod 600 \"$cache_file\"\n  \n  printf '#!/bin/bash\\necho 4\\n' > \"$TEST_WORKDIR/bin/pgrep\"\n  chmod +x \"$TEST_WORKDIR/bin/pgrep\"\n  \n  rm -f \"/tmp/yolo-${_VER:-0}-$(id -u)-fast\" 2>/dev/null\n  \n  run bash -c \"cd '$TEST_WORKDIR' && YOLO_MAX_WIDTH=70 PATH='$TEST_WORKDIR/bin:$PATH' printf '%s' '$STATUS_INPUT' | bash '$SUT'\"\n  assert_success\n  \n  local l4_width\n  local line4\n  line4=$(echo \"$output\" | sed -n '4p')\n  l4_width=$(visible_width \"$line4\")\n  [ \"$l4_width\" -le 70 ]\n  \n  rm -f \"$cache_file\"\n}\n\n# --- 31. All 4 lines respect MAX_WIDTH simultaneously ---\n@test \"all 4 output lines fit within MAX_WIDTH\" {\n  mk_planning_dir\n  mk_state_json 2 5 \"executing\"\n  \n  run_statusline\n  assert_success\n  \n  # Check all 4 lines\n  local i line width\n  for i in 1 2 3 4; do\n    line=$(echo \"$output\" | sed -n \"${i}p\")\n    width=$(visible_width \"$line\")\n    [ \"$width\" -le 120 ]\n  done\n}\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. Test 28 (L2): Uses large token counts (5.5M input, 1.2M output, 3.5M cache write, 8.5M cache read) to produce long formatted numbers like `5.5M`, `1.2M`, `3.5M`, `8.5M`. With all labels, L2 would be: `Context: [20-char bar] 95% 17.7M/200.0K | Tokens: 5.5M in  1.2M out | Prompt Cache: 48% hit 3.5M write 8.5M read` = ~95 chars. Should fit at 120 but tests the measurement.\n2. Test 29 (L4): Creates slow cache with UPDATE_AVAIL=9.9.9 to trigger the update notification. Stubs pgrep to return 5 (4 agents after -1). L4 with update + agents: `Model: Claude Sonnet | Time: 2h 0m (API: 1h 30m) | * 4 agents working | YOLO 0.2.2 -> 9.9.9 /yolo:update | CC 1.2.3` = ~100 chars.\n3. Test 30 (narrow L4): YOLO_MAX_WIDTH=70 forces the budget to be tight. L4 should drop update text and possibly agents.\n4. Test 31 (comprehensive): Checks ALL 4 lines simultaneously. This is the integration smoke test.\n5. The _VER variable construction matches the script: `cat \"$(dirname \"$0\")/../VERSION\"`. In tests, this reads the real VERSION file. To construct the cache path, read the same file or use a known fallback.\n6. All tests use the teardown() function which cleans `/tmp/yolo-*-$(id -u)*`, so cache files are auto-cleaned.\n7. The total test count after all T1-T4: 8 (existing) + 7 (T1) + 8 (T2) + 4 (T3) + 4 (T4) = 31 tests."}
