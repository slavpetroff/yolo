{"p":"01","n":"02","t":"Apply width budget to L1-L4 line construction","w":2,"d":["01-01"],"xd":[],"mh":{"tr":["L3 with all 4 usage segments (session+weekly+sonnet+extra) does not exceed 120 visible chars","L1 with full git info and OSC 8 link does not exceed 120 visible chars","Progress bars shrink before text segments are dropped","OSC 8 hyperlinks are dropped when they push line over budget","Rightmost segments are dropped after bars are minimized"],"ar":[{"p":"scripts/statusline-utils.sh","pv":"compute_bar_width","c":"compute_bar_width"},{"p":"scripts/statusline-utils.sh","pv":"visible_width","c":"visible_width"},{"p":"scripts/statusline-utils.sh","pv":"strip_osc8_links","c":"strip_osc8_links"},{"p":"scripts/yolo-statusline.sh","pv":"L3=","c":"USAGE_LINE"},{"p":"scripts/yolo-statusline.sh","pv":"L1=","c":"L1_PROJECT"},{"p":"scripts/yolo-statusline.sh","pv":"L2=","c":"L2_CONTEXT"},{"p":"scripts/yolo-statusline.sh","pv":"L4=","c":"L4_MODEL"}],"kl":[{"fr":"L3 usage rendering","to":"compute_bar_width","vi":"L3 uses compute_bar_width to size session/weekly/sonnet/extra bars"},{"fr":"L1 GH_LINK","to":"visible_width","vi":"L1 measures with visible_width to decide OSC 8 vs plain text"},{"fr":"L1 GH_LINK","to":"strip_osc8_links","vi":"L1 calls strip_osc8_links to degrade hyperlink when over budget"},{"fr":"L2 context bar","to":"visible_width","vi":"L2 measures after build, shrinks bar if over"}]},"obj":"Integrate adaptive width budgeting into all 4 line construction blocks so content gracefully degrades within MAX_WIDTH","sk":["commit"],"fm":["scripts/yolo-statusline.sh"]}
{"id":"T1","tp":"auto","a":"Refactor L3 (usage line, lines 307-349) to use two-pass adaptive bar widths per TD4. Count active segments, build skeleton with [BAR] placeholders, measure skeleton, compute per-bar width via compute_bar_width, rebuild with real bars. If bars at minimum, drop rightmost segments (extra first, then sonnet).","f":["scripts/yolo-statusline.sh"],"ts":"Test L3 with all 4 segments uses bars smaller than 20 and fits within 120 chars. Test L3 with YOLO_MAX_WIDTH=80 drops extra segment. Test L3 with YOLO_MAX_WIDTH=60 drops both extra and sonnet.","v":"L3 visible width <= MAX_WIDTH with all 4 usage segments active","done":"L3 uses compute_bar_width via two-pass construction, drops segments when over budget","td":[],"spec":"MODIFY scripts/yolo-statusline.sh: Replace the L3 usage rendering block (lines 308-342, inside the `if [ \"$FETCH_OK\" = \"ok\" ]` branch, after the countdown helper and FIVE_REM/WEEK_REM assignments, starting at line 331 `USAGE_LINE=\"Session:...` through line 342 `fi`).\n\nReplace the direct USAGE_LINE construction with two-pass budgeted construction per TD4:\n\n```bash\n  # --- Two-pass L3 construction (TD4) ---\n  # Segments: session (always), weekly (always), sonnet (conditional), extra (conditional)\n  # Pass 1: Build skeleton with [BAR] placeholders to measure non-bar overhead\n  # Pass 2: Compute bar widths from remaining budget, rebuild with real bars\n\n  # Determine which segments are active\n  L3_SEGMENTS=(\"session\" \"weekly\")\n  [ \"${SONNET_PCT:--1}\" -ge 0 ] 2>/dev/null && L3_SEGMENTS+=(\"sonnet\")\n  [ \"${EXTRA_ENABLED:-0}\" = \"1\" ] && [ \"${EXTRA_PCT:--1}\" -ge 0 ] 2>/dev/null && L3_SEGMENTS+=(\"extra\")\n\n  # Build skeleton function (placeholder = \"[BAR]\" = 5 visible chars)\n  _build_l3_skeleton() {\n    local segments=(\"$@\")\n    local skel=\"Session: [BAR] ${FIVE_PCT:-0}%\"\n    [ -n \"$FIVE_REM\" ] && skel=\"$skel $FIVE_REM\"\n    skel=\"$skel ${D}|${X} Weekly: [BAR] ${WEEK_PCT:-0}%\"\n    [ -n \"$WEEK_REM\" ] && skel=\"$skel $WEEK_REM\"\n    local has_sonnet=0 has_extra=0\n    local s; for s in \"${segments[@]}\"; do\n      [ \"$s\" = \"sonnet\" ] && has_sonnet=1\n      [ \"$s\" = \"extra\" ] && has_extra=1\n    done\n    if [ \"$has_sonnet\" = \"1\" ]; then\n      skel=\"$skel ${D}|${X} Sonnet: [BAR] ${SONNET_PCT}%\"\n    fi\n    if [ \"$has_extra\" = \"1\" ]; then\n      EXTRA_USED_D=\"$((EXTRA_USED_C / 100)).$( printf '%02d' $((EXTRA_USED_C % 100)) )\"\n      EXTRA_LIMIT_D=\"$((EXTRA_LIMIT_C / 100)).$( printf '%02d' $((EXTRA_LIMIT_C % 100)) )\"\n      skel=\"$skel ${D}|${X} Extra: [BAR] ${EXTRA_PCT}% \\$${EXTRA_USED_D}/\\$${EXTRA_LIMIT_D}\"\n    fi\n    printf '%s' \"$skel\"\n  }\n\n  # Pass 1: Measure skeleton\n  _l3_rebuild() {\n    local segments=(\"$@\")\n    local num_bars=${#segments[@]}\n    local skeleton\n    skeleton=$(_build_l3_skeleton \"${segments[@]}\")\n    local skel_width\n    skel_width=$(visible_width \"$skeleton\")\n    # Add back placeholder widths (each [BAR] = 5 visible chars)\n    local available=$(( MAX_WIDTH - skel_width + (num_bars * 5) ))\n    local bar_w\n    bar_w=$(compute_bar_width \"$available\" \"$num_bars\")\n\n    # If bar_w = 0, drop rightmost segment and retry\n    if [ \"$bar_w\" -eq 0 ]; then\n      return 1  # Signal caller to drop a segment\n    fi\n\n    # Pass 2: Build real line with computed bar widths\n    local line=\"Session: $(progress_bar \"${FIVE_PCT:-0}\" \"$bar_w\") ${FIVE_PCT:-0}%\"\n    [ -n \"$FIVE_REM\" ] && line=\"$line $FIVE_REM\"\n    line=\"$line ${D}|${X} Weekly: $(progress_bar \"${WEEK_PCT:-0}\" \"$bar_w\") ${WEEK_PCT:-0}%\"\n    [ -n \"$WEEK_REM\" ] && line=\"$line $WEEK_REM\"\n    local has_sonnet=0 has_extra=0\n    local s; for s in \"${segments[@]}\"; do\n      [ \"$s\" = \"sonnet\" ] && has_sonnet=1\n      [ \"$s\" = \"extra\" ] && has_extra=1\n    done\n    if [ \"$has_sonnet\" = \"1\" ]; then\n      line=\"$line ${D}|${X} Sonnet: $(progress_bar \"${SONNET_PCT}\" \"$bar_w\") ${SONNET_PCT}%\"\n    fi\n    if [ \"$has_extra\" = \"1\" ]; then\n      line=\"$line ${D}|${X} Extra: $(progress_bar \"${EXTRA_PCT}\" \"$bar_w\") ${EXTRA_PCT}% \\$${EXTRA_USED_D}/\\$${EXTRA_LIMIT_D}\"\n    fi\n    printf '%s' \"$line\"\n  }\n\n  # Iterative segment dropping: try with all segments, drop rightmost on failure\n  USAGE_LINE=\"\"\n  _l3_segs=(\"${L3_SEGMENTS[@]}\")\n  while [ ${#_l3_segs[@]} -gt 0 ]; do\n    USAGE_LINE=$(_l3_rebuild \"${_l3_segs[@]}\")\n    if [ $? -eq 0 ] && [ -n \"$USAGE_LINE\" ]; then\n      break\n    fi\n    # Drop rightmost segment\n    unset '_l3_segs[${#_l3_segs[@]}-1]'\n    _l3_segs=(\"${_l3_segs[@]}\")\n  done\n  # Fallback: if all segments dropped, show minimal\n  [ -z \"$USAGE_LINE\" ] && USAGE_LINE=\"Session: ${FIVE_PCT:-0}% ${D}|${X} Weekly: ${WEEK_PCT:-0}%\"\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. The existing separator character is `│` (U+2502 BOX DRAWINGS LIGHT VERTICAL) wrapped in dim. Use the same character, not ASCII `|`. The placeholder uses `|` but the actual line uses `│`.\n2. EXTRA_USED_D and EXTRA_LIMIT_D computation must happen before use (currently at lines 339-340). Move inside the skeleton/rebuild functions or compute once before the two-pass block.\n3. The [BAR] placeholder is 5 visible chars. The formula: available = MAX_WIDTH - skel_width + (num_bars * 5) adds back the placeholder widths to get the real available space for bars.\n4. compute_bar_width returns 0 when per_bar < MIN_BAR (3). This triggers segment dropping. Drop order: extra -> sonnet -> (session and weekly are always kept).\n5. The two-pass approach means progress_bar is called once (in pass 2), not twice. This is efficient.\n6. The dim separator `${D}│${X}` contributes 1 visible char per separator (the │ itself; ANSI codes are invisible).\n7. Leave the `elif/else` branches (lines 343-349: auth/fail/N-A messages) UNCHANGED. They are short strings that will never exceed MAX_WIDTH."}
{"id":"T2","tp":"auto","a":"Refactor L1 (project line, lines 368-407) to use width budget. After constructing L1 with all segments, measure visible_width. If over MAX_WIDTH: first replace OSC 8 GH_LINK with plain text via strip_osc8_links. If still over, drop rightmost segments (Diff, then Commits, then Files, then QA). During execution mode (lines 368-372), apply same strategy: drop EXEC_CURRENT text if over budget.","f":["scripts/yolo-statusline.sh"],"ts":"Test L1 drops OSC 8 link first, then rightmost segments when over budget. Test with YOLO_MAX_WIDTH=60 and long branch name. Test execution mode L1 drops current plan text when over budget.","v":"L1 visible width <= MAX_WIDTH with full git info","done":"L1 drops OSC 8 then rightmost segments on overflow; execution mode L1 handles overflow","td":[],"spec":"MODIFY scripts/yolo-statusline.sh: Add an L1 width-budget pass AFTER the existing L1 construction block (after line 407 `fi`) and BEFORE L2 construction (line 409).\n\nThe existing L1 construction (lines 368-407) remains unchanged. We add a post-construction budget check that measures and degrades:\n\n```bash\n# --- L1 width budget (IP3) ---\n# Measure L1 visible width. If over MAX_WIDTH, degrade in order:\n# 1. Replace OSC 8 hyperlink with plain text (repo:branch)\n# 2. Drop Diff segment\n# 3. Drop Commits segment\n# 4. Drop Files segment\n# 5. Drop QA segment\nif [ \"$(visible_width \"$L1\")\" -gt \"$MAX_WIDTH\" ]; then\n  # Step 1: Degrade OSC 8 hyperlink to plain text\n  L1=$(printf '%s' \"$L1\" | sed -E \"s/${ESC}\\]8;[^${ESC}]*${ESC}\\\\\\\\([^${ESC}]*)${ESC}\\]8;;${ESC}\\\\\\\\/\\1/g\")\nfi\nif [ \"$(visible_width \"$L1\")\" -gt \"$MAX_WIDTH\" ]; then\n  # Step 2: Drop Diff segment (rightmost): \" <dim>Diff:</dim> <green>+N</green> <red>-N</red>\"\n  L1=$(printf '%s' \"$L1\" | sed -E \"s/ ${ESC}\\[2mDiff:${ESC}\\[0m ${ESC}\\[32m\\+[0-9]+${ESC}\\[0m ${ESC}\\[31m-[0-9]+${ESC}\\[0m//\")\nfi\nif [ \"$(visible_width \"$L1\")\" -gt \"$MAX_WIDTH\" ]; then\n  # Step 3: Drop Commits segment: \" <dim>Commits:</dim> <cyan>upN</cyan>\"\n  L1=$(printf '%s' \"$L1\" | sed -E \"s/ ${ESC}\\[2mCommits:${ESC}\\[0m ${ESC}\\[36m[^${ESC}]+${ESC}\\[0m//\")\nfi\nif [ \"$(visible_width \"$L1\")\" -gt \"$MAX_WIDTH\" ]; then\n  # Step 4: Drop Files segment: \" <dim>Files:</dim> ...\"\n  L1=$(printf '%s' \"$L1\" | sed -E \"s/ ${ESC}\\[2mFiles:${ESC}\\[0m [^${ESC}]*(${ESC}[^m]*m[^${ESC}]*)*//\")\nfi\nif [ \"$(visible_width \"$L1\")\" -gt \"$MAX_WIDTH\" ]; then\n  # Step 5: Drop QA segment\n  L1=$(printf '%s' \"$L1\" | sed -E \"s/ ${ESC}\\[2m[|]${ESC}\\[0m ${ESC}\\[(32|2)mQA: [a-z-]+${ESC}\\[0m//\")\nfi\n```\n\nALTERNATIVE APPROACH (RECOMMENDED — simpler and more robust):\nInstead of complex sed on ANSI strings, reconstruct L1 with fewer segments. This is more reliable:\n\n```bash\n# --- L1 width budget (IP3) ---\n_l1_width=$(visible_width \"$L1\")\nif [ \"$_l1_width\" -gt \"$MAX_WIDTH\" ] && [ -n \"$GH_LINK\" ]; then\n  # Rebuild L1 without OSC 8 (use plain GH_NAME:BR instead)\n  _GH_PLAIN=\"\"\n  [ -n \"$GH_URL\" ] && _GH_PLAIN=\"$(basename \"$GH_URL\")${BR:+:$BR}\"\n  # Rebuild L1 from scratch with progressively fewer segments\n  _l1_rebuild() {\n    local include_diff=\"$1\" include_commits=\"$2\" include_files=\"$3\" include_qa=\"$4\"\n    local line\n    if [ \"$EXEC_STATUS\" = \"running\" ] && [ \"${EXEC_TOTAL:-0}\" -gt 0 ] 2>/dev/null; then\n      EXEC_PCT=$((EXEC_DONE * 100 / EXEC_TOTAL))\n      line=\"${C}${B}[YOLO]${X} Build: $(progress_bar \"$EXEC_PCT\" 8) ${EXEC_DONE}/${EXEC_TOTAL} plans\"\n      [ \"${EXEC_TWAVES:-0}\" -gt 1 ] 2>/dev/null && line=\"$line ${D}|${X} Wave ${EXEC_WAVE}/${EXEC_TWAVES}\"\n      # Drop EXEC_CURRENT if over budget (handled by caller measuring)\n    elif [ -d \".yolo-planning\" ]; then\n      line=\"${C}${B}[YOLO]${X}\"\n      [ \"$TT\" -gt 0 ] 2>/dev/null && line=\"$line Phase ${PH}/${TT}\" || line=\"$line Phase ${PH:-?}\"\n      [ \"$PT\" -gt 0 ] 2>/dev/null && line=\"$line ${D}|${X} Plans: ${PD}/${PT} (${PPD} this phase)\"\n      line=\"$line ${D}|${X} Effort: $EF ${D}|${X} Model: $MP\"\n      if [ \"$include_qa\" = \"1\" ]; then\n        if [ \"$QA\" = \"pass\" ]; then line=\"$line ${D}|${X} ${G}QA: pass${X}\"\n        else line=\"$line ${D}|${X} ${D}QA: --${X}\"; fi\n      fi\n    else\n      line=\"${C}${B}[YOLO]${X} ${D}no project${X}\"\n    fi\n    if [ -n \"$BR\" ]; then\n      [ -n \"$_GH_PLAIN\" ] && line=\"$line ${D}|${X} $_GH_PLAIN\" || line=\"$line ${D}|${X} $BR\"\n      if [ \"$include_files\" = \"1\" ]; then\n        local git_ind=\"\"\n        [ \"${GIT_STAGED:-0}\" -gt 0 ] 2>/dev/null && git_ind=\"${G}+${GIT_STAGED}${X}\"\n        [ \"${GIT_MODIFIED:-0}\" -gt 0 ] 2>/dev/null && git_ind=\"${git_ind}${Y}~${GIT_MODIFIED}${X}\"\n        [ -n \"$git_ind\" ] && line=\"$line ${D}Files:${X} $git_ind\"\n      fi\n      [ \"$include_commits\" = \"1\" ] && [ \"${GIT_AHEAD:-0}\" -gt 0 ] 2>/dev/null && \\\n        line=\"$line ${D}Commits:${X} ${C}up${GIT_AHEAD}${X}\"\n      [ \"$include_diff\" = \"1\" ] && \\\n        line=\"$line ${D}Diff:${X} ${G}+${ADDED}${X} ${R}-${REMOVED}${X}\"\n    fi\n    printf '%s' \"$line\"\n  }\n  # Try progressively dropping segments\n  L1=$(_l1_rebuild 1 1 1 1)  # All segments, no OSC 8\n  if [ \"$(visible_width \"$L1\")\" -gt \"$MAX_WIDTH\" ]; then\n    L1=$(_l1_rebuild 0 1 1 1)  # Drop Diff\n  fi\n  if [ \"$(visible_width \"$L1\")\" -gt \"$MAX_WIDTH\" ]; then\n    L1=$(_l1_rebuild 0 0 1 1)  # Drop Commits\n  fi\n  if [ \"$(visible_width \"$L1\")\" -gt \"$MAX_WIDTH\" ]; then\n    L1=$(_l1_rebuild 0 0 0 1)  # Drop Files\n  fi\n  if [ \"$(visible_width \"$L1\")\" -gt \"$MAX_WIDTH\" ]; then\n    L1=$(_l1_rebuild 0 0 0 0)  # Drop QA\n  fi\nfi\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. Use the RECOMMENDED approach (rebuild-based) over the sed approach. Parsing ANSI strings with sed is fragile. Rebuilding from variables is deterministic.\n2. The separator character in the existing code is `│` (U+2502), not ASCII `|`. Match exactly.\n3. GH_LINK is the OSC 8 version. _GH_PLAIN is the plain text fallback. The rebuild function uses _GH_PLAIN when OSC 8 is dropped.\n4. Execution mode (EXEC_STATUS=running) has its own L1 format. The rebuild must handle both modes.\n5. For execution mode overflow: drop EXEC_CURRENT (the running plan name) first, then wave info.\n6. The ESC variable is defined in statusline-utils.sh (sourced). Use it for sed patterns.\n7. The `_l1_rebuild` helper is defined inside the budget block. It uses variables from the outer scope (PH, TT, EF, MP, QA, BR, GIT_STAGED, GIT_MODIFIED, GIT_AHEAD, ADDED, REMOVED, EXEC_*).\n8. The rebuild function uses the `${D}|${X}` separator. Must use the actual Unicode box-drawing char `│`."}
{"id":"T3","tp":"auto","a":"Refactor L2 (context line, lines 409-411) to use width budget. L2 has one progress bar (context bar, 20 chars). If visible_width exceeds MAX_WIDTH: shrink context bar (20 -> 12 -> 8), then abbreviate cache labels (write->wr, read->rd). L2 is less likely to overflow but must be handled for completeness.","f":["scripts/yolo-statusline.sh"],"ts":"Test L2 shrinks context bar when over budget with YOLO_MAX_WIDTH=70. Test L2 abbreviates labels with YOLO_MAX_WIDTH=60. Test L2 at default MAX_WIDTH=120 is unchanged.","v":"L2 visible width <= MAX_WIDTH with large token counts","done":"L2 shrinks bar and abbreviates labels on overflow","td":[],"spec":"MODIFY scripts/yolo-statusline.sh: Replace L2 construction (lines 409-411) and the context bar computation (lines 363-366) with a budgeted version.\n\nThe current L2 construction is:\n```bash\n[ \"$PCT\" -ge 90 ] && BC=\"$R\" || { [ \"$PCT\" -ge 70 ] && BC=\"$Y\" || BC=\"$G\"; }\nFL=$((PCT * 20 / 100)); EM=$((20 - FL))\nCTX_BAR=\"\"; [ \"$FL\" -gt 0 ] && CTX_BAR=$(printf \"%${FL}s\" | tr ' ' '|')\n[ \"$EM\" -gt 0 ] && CTX_BAR=\"${CTX_BAR}$(printf \"%${EM}s\" | tr ' ' '|')\"\n...\nL2=\"Context: ${BC}${CTX_BAR}${X} ${BC}${PCT}%${X} ${CTX_USED_FMT}/${CTX_SIZE_FMT}\"\nL2=\"$L2 ${D}│${X} Tokens: ${IN_TOK_FMT} in  ${OUT_TOK_FMT} out\"\nL2=\"$L2 ${D}│${X} Prompt Cache: ${CACHE_COLOR}${CACHE_HIT_PCT}% hit${X} ${CACHE_W_FMT} write ${CACHE_R_FMT} read\"\n```\n\nReplace with budgeted construction:\n```bash\n[ \"$PCT\" -ge 90 ] && BC=\"$R\" || { [ \"$PCT\" -ge 70 ] && BC=\"$Y\" || BC=\"$G\"; }\n\n_build_l2() {\n  local bar_w=\"$1\" abbrev=\"$2\"\n  local fl=$((PCT * bar_w / 100)); local em=$((bar_w - fl))\n  local ctx_bar=\"\"\n  [ \"$fl\" -gt 0 ] && ctx_bar=$(printf \"%${fl}s\" | tr ' ' '▓')\n  [ \"$em\" -gt 0 ] && ctx_bar=\"${ctx_bar}$(printf \"%${em}s\" | tr ' ' '░')\"\n  local line=\"Context: ${BC}${ctx_bar}${X} ${BC}${PCT}%${X} ${CTX_USED_FMT}/${CTX_SIZE_FMT}\"\n  line=\"$line ${D}│${X} Tokens: ${IN_TOK_FMT} in  ${OUT_TOK_FMT} out\"\n  if [ \"$abbrev\" = \"1\" ]; then\n    line=\"$line ${D}│${X} Cache: ${CACHE_COLOR}${CACHE_HIT_PCT}%${X} ${CACHE_W_FMT} wr ${CACHE_R_FMT} rd\"\n  else\n    line=\"$line ${D}│${X} Prompt Cache: ${CACHE_COLOR}${CACHE_HIT_PCT}% hit${X} ${CACHE_W_FMT} write ${CACHE_R_FMT} read\"\n  fi\n  printf '%s' \"$line\"\n}\n\n# Try bar sizes 20, 12, 8 with full labels, then 8 with abbreviated labels\nL2=$(_build_l2 20 0)\nif [ \"$(visible_width \"$L2\")\" -gt \"$MAX_WIDTH\" ]; then\n  L2=$(_build_l2 12 0)\nfi\nif [ \"$(visible_width \"$L2\")\" -gt \"$MAX_WIDTH\" ]; then\n  L2=$(_build_l2 8 0)\nfi\nif [ \"$(visible_width \"$L2\")\" -gt \"$MAX_WIDTH\" ]; then\n  L2=$(_build_l2 8 1)  # Abbreviate: \"Prompt Cache: N% hit\" -> \"Cache: N%\", \"write\" -> \"wr\", \"read\" -> \"rd\"\nfi\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. The context bar uses `▓` (U+2593 DARK SHADE) for filled and `░` (U+2591 LIGHT SHADE) for empty. These are DIFFERENT from progress_bar's `█` (U+2588 FULL BLOCK). Match the existing characters exactly.\n2. The bar width steps are 20 -> 12 -> 8 per the degradation order. Not continuous shrinking.\n3. Abbreviation replaces \"Prompt Cache: N% hit\" with \"Cache: N%\" and \"write\" with \"wr\", \"read\" with \"rd\". This saves ~15 visible chars.\n4. Remove the old standalone CTX_BAR computation (lines 363-366) since _build_l2 now handles bar construction internally.\n5. Keep the BC (bar color) computation outside _build_l2 since it does not change with bar width.\n6. At default MAX_WIDTH=120, the first try (bar_w=20, abbrev=0) should pass for all realistic token counts. The shrinking is a safety net for YOLO_MAX_WIDTH overrides or extreme values."}
{"id":"T4","tp":"auto","a":"Refactor L4 (model line, lines 414-420) to use width budget. L4 has no progress bars. If visible_width exceeds MAX_WIDTH: drop update notification text first (keep just the arrow), then drop agent line, then abbreviate version strings. L4 overflow is rare but handle gracefully.","f":["scripts/yolo-statusline.sh"],"ts":"Test L4 drops update text when over budget with YOLO_MAX_WIDTH=60. Test L4 with update and agents at default 120 fits. Test L4 drops agent line after dropping update text.","v":"L4 visible width <= MAX_WIDTH with update and agents","done":"L4 drops update text and agent line on overflow","td":[],"spec":"MODIFY scripts/yolo-statusline.sh: Replace L4 construction (lines 414-420) with budgeted version.\n\nCurrent L4 construction:\n```bash\nL4=\"Model: ${D}${MODEL}${X} ${D}│${X} Time: ${DUR_FMT} (API: ${API_DUR_FMT})\"\n[ -n \"$AGENT_LINE\" ] && L4=\"$L4 ${D}│${X} ${AGENT_LINE}\"\nif [ -n \"$UPDATE_AVAIL\" ]; then\n  L4=\"$L4 ${D}│${X} ${Y}${B}YOLO ${_VER:-?} → ${UPDATE_AVAIL}${X} ${Y}/yolo:update${X} ${D}│${X} ${D}CC ${VER}${X}\"\nelse\n  L4=\"$L4 ${D}│${X} ${D}YOLO ${_VER:-?}${X} ${D}│${X} ${D}CC ${VER}${X}\"\nfi\n```\n\nReplace with:\n```bash\n_build_l4() {\n  local include_update=\"$1\" include_agents=\"$2\" abbrev_ver=\"$3\"\n  local line=\"Model: ${D}${MODEL}${X} ${D}│${X} Time: ${DUR_FMT} (API: ${API_DUR_FMT})\"\n  if [ \"$include_agents\" = \"1\" ] && [ -n \"$AGENT_LINE\" ]; then\n    line=\"$line ${D}│${X} ${AGENT_LINE}\"\n  fi\n  if [ \"$include_update\" = \"1\" ] && [ -n \"$UPDATE_AVAIL\" ]; then\n    line=\"$line ${D}│${X} ${Y}${B}YOLO ${_VER:-?} → ${UPDATE_AVAIL}${X} ${Y}/yolo:update${X} ${D}│${X} ${D}CC ${VER}${X}\"\n  elif [ \"$abbrev_ver\" = \"1\" ]; then\n    line=\"$line ${D}│${X} ${D}Y${_VER:-?}${X} ${D}│${X} ${D}C${VER}${X}\"\n  else\n    line=\"$line ${D}│${X} ${D}YOLO ${_VER:-?}${X} ${D}│${X} ${D}CC ${VER}${X}\"\n  fi\n  printf '%s' \"$line\"\n}\n\n# Progressive degradation: full -> drop update -> drop agents -> abbreviate versions\nL4=$(_build_l4 1 1 0)\nif [ \"$(visible_width \"$L4\")\" -gt \"$MAX_WIDTH\" ]; then\n  L4=$(_build_l4 0 1 0)  # Drop update notification\nfi\nif [ \"$(visible_width \"$L4\")\" -gt \"$MAX_WIDTH\" ]; then\n  L4=$(_build_l4 0 0 0)  # Drop agents\nfi\nif [ \"$(visible_width \"$L4\")\" -gt \"$MAX_WIDTH\" ]; then\n  L4=$(_build_l4 0 0 1)  # Abbreviate: \"YOLO\" -> \"Y\", \"CC\" -> \"C\"\nfi\n```\n\nCRITICAL IMPLEMENTATION NOTES:\n1. Degradation order per architecture: drop update text -> drop agent line -> abbreviate versions. The update text is the longest optional segment (`YOLO 0.2.2 -> 0.2.3 /yolo:update` = ~30 chars).\n2. When update is dropped, the non-update version line is used (`YOLO 0.2.2 | CC 1.2.3`).\n3. Version abbreviation: `YOLO 0.2.2` -> `Y0.2.2`, `CC 1.2.3` -> `C1.2.3`. Saves ~6 chars.\n4. The `→` character (U+2192 RIGHTWARDS ARROW) in the update text is a single-width character.\n5. AGENT_LINE includes its own ANSI codes (cyan diamond + text). It is already constructed at line 202-205.\n6. At default MAX_WIDTH=120, L4 should always fit. This budget is a safety net for YOLO_MAX_WIDTH overrides.\n7. L4 does NOT use two-pass construction (no progress bars). It uses post-construction measurement only.\n8. The separator character is `│` (U+2502), not ASCII `|`. Match exactly from existing code."}
