{"ts":"2026-02-16T00:00:00Z","agent":"architect","task":"scoping","dec":"4 phases: abstraction -> department-teams -> shared-tasks -> graceful-degradation","reason":"Each phase is independently testable. Abstraction first ensures zero regression. Department teams before shared tasks because teams must exist before task lists can be shared. Degradation last because fallback patterns cut across all prior work.","alts":["3 phases (merge degradation into each phase)","5 phases (separate config from abstraction)"]}
{"ts":"2026-02-16T00:00:01Z","agent":"architect","task":"scoping","dec":"team_mode config flag with values task|teammate|auto, default task","reason":"Opt-in activation prevents breaking existing installs. Auto mode enables smart detection of Teammate API availability. Task remains the proven fallback.","alts":["Boolean flag team_api_enabled","No config flag (always attempt Teammate API)"]}
{"ts":"2026-02-16T00:00:02Z","agent":"architect","task":"scoping","dec":"Additive migration: keep Task tool path permanently, add Teammate API as parallel path","reason":"Teammate API is experimental with known limitations (no session resumption, task status lag, no nested teams). Task tool is proven across 3 milestones and 209+ tests. Removal would be premature.","alts":["Full replacement of Task tool path","Temporary dual mode with Task tool removal in future phase"]}
{"ts":"2026-02-16T00:00:03Z","agent":"architect","task":"scoping","dec":"One Teammate API team per department, department Lead as team lead","reason":"Maps directly to API constraint: no nested teams, one team per session. Department is the natural team boundary. Lead already orchestrates specialists within department.","alts":["One mega-team with all agents","Team per workflow step (planning team, execution team, QA team)"]}
{"ts":"2026-02-16T00:00:04Z","agent":"architect","task":"scoping","dec":"Prompt-level integration for Teammate API, not script-level","reason":"spawnTeam, SendMessage, TaskCreate are Claude Code tools invoked by agents, not bash APIs. Shell scripts handle config resolution and state reporting only. Coordination signals shift from file sentinels to SendMessage in agent prompts.","alts":["Wrapper scripts that somehow invoke Claude Code tools","Pure file-based coordination with Teammate API polling"]}
{"ts":"2026-02-16T12:00:00Z","agent":"lead","task":"planning","dec":"4 plans in 2 waves: config+resolve (W1), agent prompts (W1), spawn routing (W2), testing (W2)","reason":"Wave 1 separates config plumbing (scripts) from agent prompt changes (markdown) to avoid file conflicts in parallel execution. Wave 2 integrates both into command files and validates. Testing as separate plan ensures full regression suite runs after all changes.","alts":["3 plans (merge config+routing into one plan)","5 plans (separate reference doc from agent prompts)"]}
{"ts":"2026-02-16T12:00:01Z","agent":"lead","task":"planning","dec":"resolve-team-mode.sh as new script rather than extending resolve-departments.sh","reason":"Separation of concerns: resolve-departments.sh handles department routing (backend/frontend/uiux), resolve-team-mode.sh handles spawn strategy (task/teammate). Different consumers, different evolution paths. resolve-departments.sh already has 120 lines of department logic.","alts":["Add team_mode output to resolve-departments.sh","Inline team_mode resolution in go.md"]}
{"ts":"2026-02-16T12:00:02Z","agent":"lead","task":"planning","dec":"Teammate API patterns in separate reference file, not inline in each agent","reason":"Single source of truth for API patterns. Agents reference it with @references/teammate-api-patterns.md. Changes propagate to all agents from one edit. Follows existing pattern of references/execute-protocol.md.","alts":["Duplicate full patterns in every agent file","Put patterns in compile-context.sh output only"]}
{"ts":"2026-02-16T12:00:03Z","agent":"lead","task":"planning","dec":"fallback_notice flag in resolve-team-mode.sh output rather than in go.md logic","reason":"Deterministic script output is testable with BATS. go.md reads the flag and displays notice. Keeps LLM logic simple (if flag, display). Follows resolve-departments.sh pattern of key=value output.","alts":["go.md checks env var directly","Fallback notice in compile-context.sh output"]}
{"ts":"2026-02-16T18:00:00Z","agent":"architect","task":"architecture","dec":"resolve-team-mode.sh outputs effective team_mode after all fallback logic (C3/C4/C9 resolution)","reason":"Follows resolve-departments.sh pattern where script resolves final state. Consumer reads team_mode=task or team_mode=teammate directly without interpreting raw+flag combinations. Eliminates risk of go.md forgetting to check fallback_notice for spawn decision.","alts":["Raw config value + separate fallback flag requiring consumer interpretation","go.md checks env var directly and interprets fallback"]}
{"ts":"2026-02-16T18:00:01Z","agent":"architect","task":"architecture","dec":"team_mode and agent_teams are orthogonal with validation (C2 resolution)","reason":"agent_teams=true is feature flag (teams enabled in config). team_mode controls HOW agents spawn (task|teammate). resolve-team-mode.sh validates team_mode=teammate requires agent_teams=true. Clear separation prevents naming confusion while maintaining backward compatibility.","alts":["Replace agent_teams entirely with team_mode","Merge into single field with combined semantics"]}
{"ts":"2026-02-16T18:00:02Z","agent":"architect","task":"architecture","dec":"Phase 1 covers 4 core agents only; QA/Tester/Security/Owner deferred to Phase 2 (C1 resolution)","reason":"lead, dev, senior, architect form the minimum department team hierarchy (Lead as team lead, others as teammates). These establish SendMessage and spawnTeam patterns. Remaining agents become teammates in Phase 2 when team structure exists.","alts":["All 26 agents in Phase 1 (too broad)","Only Lead in Phase 1 (insufficient pattern coverage)"]}
{"ts":"2026-02-16T18:00:03Z","agent":"architect","task":"architecture","dec":"execute-protocol.md scope limited to multi-dept section and top-level spawns (C8 resolution)","reason":"go.md spawns top-level agents (department leads) -- these become Teammate API team leads. Within-team spawning (Lead->Senior, Lead->Dev) is handled by agent prompt conditionals, not execute-protocol steps. Steps 1-9 control within-team operations.","alts":["All 9 execute-protocol spawn points get team_mode conditionals (scope creep for Phase 1)"]}
{"ts":"2026-02-16T18:00:04Z","agent":"architect","task":"architecture","dec":"config.md update deferred to Phase 2 (C6 resolution)","reason":"Phase 1 is expert-only. team_mode is not yet production-ready for /yolo:config exposure. Manual config.json edit is acceptable for early adopters testing teammate mode.","alts":["Add to config.md now with experimental warning"]}
{"ts":"2026-02-16T18:00:05Z","agent":"architect","task":"architecture","dec":"Agent verification uses team_mode=teammate guard pattern, not bare SendMessage (C5 resolution)","reason":"Pre-existing SendMessage references in agent files would cause false positive verification. Grepping for the conditional guard pattern ensures only the new conditional block is detected.","alts":["grep for SendMessage (false positives)","grep for spawnTeam (only covers Lead)"]}
{"ts":"2026-02-17T12:00:00Z","agent":"senior","task":"T1","dec":"Insert team_mode after agent_teams field, not at end of JSON","reason":"Logical grouping: agent_teams (feature flag) and team_mode (spawn strategy) are related. Adjacent placement makes the relationship visible to config readers.","alts":["Append at end of JSON object","Insert alphabetically"]}
{"ts":"2026-02-17T12:00:01Z","agent":"senior","task":"T2","dec":"Fold phase-detect.sh update into T2 spec (C10 resolution)","reason":"C10 critique identified missing config_team_mode output in phase-detect.sh. Since T2 creates the resolution script, it makes sense to also wire team_mode into phase-detect.sh config output in the same task. Keeps config plumbing changes atomic.","alts":["Separate task for phase-detect.sh update","Defer to plan 01-03 with go.md integration"]}
{"ts":"2026-02-17T12:00:02Z","agent":"senior","task":"T2","dec":"Full fallback logic in T2 spec rather than splitting basic read (T2) from validation (T4)","reason":"Architecture spec defines resolve-team-mode.sh as a single coherent script with validation. Splitting implementation across tasks risks inconsistent intermediate state. T2 spec includes all logic; T4 becomes verification-focused with additional edge case tests.","alts":["T2 basic read only, T4 adds validation blocks","Three tasks: read, validate, env check"]}
{"ts":"2026-02-17T12:00:03Z","agent":"senior","task":"T3","dec":"Reuse existing MIGRATE_MARKER for team_mode migration, no separate marker","reason":"Both model_profile and team_mode migrations are version-guarded by the same marker. Running both in one pass is simpler and matches the existing pattern. A new version bump triggers both migrations to re-check.","alts":["Separate marker per migration","Unconditional migration (check every session)"]}
{"ts":"2026-02-17T12:00:04Z","agent":"senior","task":"T1","dec":"T1 has empty ts field (no test spec)","reason":"T1 is a single-line JSON field addition to a config file. Verification is a jq command in the v field. Writing BATS tests for a static JSON file provides no value beyond the verification command.","alts":["BATS test asserting jq output","Integration test with resolve-team-mode.sh"]}
{"ts":"2026-02-17T14:00:00Z","agent":"senior","task":"01-02/T1","dec":"Reference doc structure uses H2 sections matching architecture agent_patterns, not alphabetical ordering","reason":"Architecture.toon agent_patterns section specifies exact patterns: activation guard, team lifecycle (Lead only), intra-team communication (SendMessage), cross-team communication (Lead-to-Lead), task mode fallback. These map directly to H2 headings in the reference doc. Ensures architecture-to-implementation traceability.","alts":["Alphabetical H2 sections","Group by API tool (spawnTeam section, SendMessage section, shutdown section)"]}
{"ts":"2026-02-17T14:00:01Z","agent":"senior","task":"01-02/T1","dec":"Reference doc cross-references handoff-schemas.md for JSON schemas instead of duplicating them","reason":"handoff-schemas.md is the single source of truth for all SendMessage JSON schemas (dev_progress, dev_blocker, senior_spec, code_review_result, etc). Duplicating schemas in teammate-api-patterns.md would create maintenance burden and risk drift. Reference doc shows examples but defers canonical definitions to handoff-schemas.md.","alts":["Duplicate all schemas inline","Include only schema names without examples"]}
{"ts":"2026-02-17T14:00:02Z","agent":"senior","task":"01-02/T2-T4","dec":"New Teammate API section placed between Constraints and Context in agent files","reason":"The new section is a conditional behavior extension. It belongs after all core behavior sections (protocol, escalation, decision logging, constraints) but before the context isolation table. This placement ensures the conditional block does not interrupt the primary workflow documentation. All 4 agent files use consistent placement.","alts":["After Escalation Table","Before Constraints section","At end of file after Context"]}
{"ts":"2026-02-17T14:00:03Z","agent":"senior","task":"01-02/T2-T4","dec":"All ts fields empty for T1-T4 (no test specs)","reason":"All 4 tasks produce or modify markdown documentation files (reference doc and agent prompt files). There is no executable code to test. Verification is via grep commands in the v field (checking for guard patterns like team_mode=teammate and specific keywords like spawnTeam). BATS tests for markdown file content would be fragile and duplicate the grep-based verification.","alts":["BATS tests that grep agent files for expected patterns","Snapshot tests comparing agent file sections"]}
{"ts":"2026-02-17T16:00:00Z","agent":"senior","task":"01-03/T1","dec":"resolve-team-mode.sh call placed AFTER resolve-departments.sh and BEFORE key variables in go.md Context section","reason":"Maintains the existing pattern: each resolution script gets its own labeled block with fenced code. team_mode is conceptually downstream of department routing (you need to know departments before choosing spawn strategy). Placing it last before key variables means all resolution outputs are gathered before mode logic reads them.","alts":["Inline team_mode resolution in phase-detect.sh block","Place before resolve-departments.sh"]}
{"ts":"2026-02-17T16:00:01Z","agent":"senior","task":"01-03/T1","dec":"Fallback echo in go.md uses team_mode=task (not team_mode=task\\nfallback_notice=false)","reason":"The || echo fallback only fires when the script itself fails (not found, permission error). In that case, only team_mode matters for downstream logic. fallback_notice defaults to false implicitly when absent (no display needed). Single-line fallback is cleaner and matches the resolve-departments.sh pattern which echoes only the most critical key.","alts":["Full 2-line fallback matching script output","No fallback (let Context section error propagate)"]}
{"ts":"2026-02-17T16:00:02Z","agent":"senior","task":"01-03/T2","dec":"Fallback notice as step 1.5 in Plan Mode rather than inside step 5/6 spawn logic","reason":"The notice should appear EARLY (before any planning work begins) so the user knows the spawn mode before Lead agents are spawned. Embedding it in step 5/6 would delay the notice until after Phase Discovery and context compilation. Same logic for Execute Mode: notice before routing, not inside routing.","alts":["Display inside step 5/6 spawn blocks","Display only in Execute Mode (not Plan Mode)"]}
{"ts":"2026-02-17T16:00:03Z","agent":"senior","task":"01-03/T2","dec":"team_mode context passed as plain text instruction in Lead spawn prompt, not as structured parameter","reason":"Task tool and Teammate API both accept free-text prompts. Adding team_mode as a structured parameter would require schema changes. Plain text instruction ('team_mode=teammate. Use Teammate API...') is immediately actionable by the Lead agent. The Lead's own prompt file (yolo-lead.md) has conditional sections that activate based on this text.","alts":["Structured JSON parameter in Task tool call","Environment variable passed to agent"]}
{"ts":"2026-02-17T16:00:04Z","agent":"senior","task":"01-03/T3","dec":"execute-protocol.md team_mode additions limited to intro, context scoping, and multi-dept section","reason":"Per architecture.toon execute_protocol_scope: Steps 1-9 internal spawning stays Task tool in Phase 1. Only go.md-level spawns (top-level agent creation) get team_mode conditionals. The execute-protocol steps document within-team operations which are agent-prompt-controlled. Adding team_mode to every step would be scope creep and conflict with C8 resolution.","alts":["Add team_mode conditional to every step's spawn instructions","Only modify multi-dept section (skip intro and context scoping)"]}
{"ts":"2026-02-17T16:00:05Z","agent":"senior","task":"01-03/T4","dec":"Cross-team protocol emphasizes file-based gates are UNCHANGED in teammate mode","reason":"This is the most important design insight: SendMessage only works within a team. Cross-department communication (Lead-to-Lead, Lead-to-Owner) remains file-based because departments are separate teams. The transport table makes this explicit and prevents future confusion about trying to use SendMessage across teams.","alts":["Document SendMessage as cross-team transport (would be incorrect)","Skip cross-team protocol changes entirely (would leave gap)"]}
{"ts":"2026-02-17T16:00:06Z","agent":"senior","task":"01-03/all","dec":"All ts fields empty for T1-T4 (no test specs)","reason":"All 4 tasks modify markdown documentation files (go.md, execute-protocol.md, cross-team-protocol.md). These are prompt/protocol files, not executable code. Verification is via grep commands in each task's v field. Writing BATS tests for markdown prompt content would be fragile and provide no value beyond the grep-based verification already specified.","alts":["BATS tests that grep modified files for expected patterns","Integration test that runs go.md and checks team_mode resolution"]}
