{"p":"03","n":"02","t":"Reference Package Reorganization","w":1,"d":[],"xd":[],"mh":{"tr":["Each agent role has a self-contained reference package TOON file","Package files are smaller than the full reference files they replace","compile-context.sh references packages instead of full reference tree","No agent prompt includes execute-protocol.md (30KB) or company-hierarchy.md (16KB) in full"],"ar":[{"p":"references/packages/dev.toon","pv":"file exists and is non-empty","c":"self-contained Dev reference: only task execution protocol, commit format, escalation to Senior"},{"p":"references/packages/senior.toon","pv":"file exists and is non-empty","c":"self-contained Senior reference: design review + code review protocol, spec enrichment format"},{"p":"references/packages/qa.toon","pv":"file exists and is non-empty","c":"self-contained QA reference: verification protocol, must-have checking, tier resolution"},{"p":"scripts/build-reference-packages.sh","pv":"file exists and is executable","c":"script that validates per-role reference packages against source reference files"}],"kl":[{"fr":"references/packages/dev.toon","to":"references/execute-protocol.md","vi":"contains only Step 6 implementation protocol extract"},{"fr":"references/packages/senior.toon","to":"references/execute-protocol.md","vi":"contains only Step 4 and Step 7 protocol extracts"},{"fr":"scripts/build-reference-packages.sh","to":"references/execute-protocol.md","vi":"validates package keywords match source protocol content"}]},"obj":"Reorganize the large reference files (execute-protocol.md 30KB, company-hierarchy.md 16KB, artifact-formats.md 16KB) into per-role self-contained reference packages. Each agent loads only its package. REQ-05.","sk":["commit"],"fm":["references/packages/architect.toon","references/packages/lead.toon","references/packages/senior.toon","references/packages/dev.toon","references/packages/tester.toon","references/packages/qa.toon","references/packages/qa-code.toon","references/packages/critic.toon","references/packages/security.toon","scripts/build-reference-packages.sh","tests/unit/build-reference-packages.bats"],"auto":true}
{"id":"T1","tp":"auto","a":"Create scripts/build-reference-packages.sh as a SYNC CHECKER (not a generator). Per architecture decision D1, packages are hand-authored static TOON files. This script validates that all 9 packages exist and contain expected keywords from source reference files.","f":["scripts/build-reference-packages.sh"],"v":"Script runs clean with all 9 packages present, outputs JSON {valid:true,missing:[],stale:[]}. Script fails (exit 1) when packages missing.","done":"Sync-checker script validates reference packages against source files","spec":"Create file: scripts/build-reference-packages.sh. Shebang: #!/usr/bin/env bash. set -euo pipefail. SCRIPT_DIR resolution: SCRIPT_DIR=$(cd $(dirname $0) && pwd). PACKAGES_DIR=$SCRIPT_DIR/../references/packages. SOURCE_DIR=$SCRIPT_DIR/../references. Define ROLES array: (architect lead senior dev tester qa qa-code critic security). Define ROLE_KEYWORDS associative-style via case statement (bash 3.2 compatible, NO declare -A). Keywords per role extracted from execute-protocol.md step headers and artifact-formats.md schemas: architect: 'Step 2' 'architecture.toon' 'critique.jsonl' 'tech_decisions'. lead: 'Step 3' 'Step 10' 'plan.jsonl' 'wave' 'execution-state'. senior: 'Step 4' 'Step 7' 'spec' 'code-review.jsonl' 'design_review'. dev: 'Step 6' 'summary.jsonl' 'commit' 'escalat' 'TDD'. tester: 'Step 5' 'test-plan.jsonl' 'RED' 'red'. qa: 'Step 8' 'verification.jsonl' 'tier' 'must_have'. qa-code: 'Step 8' 'qa-code.jsonl' 'TDD' 'lint'. critic: 'Step 1' 'critique.jsonl' 'gap' 'finding'. security: 'Step 9' 'security-audit.jsonl' 'vulnerability' 'FAIL'. Script logic: (1) Check each role has a .toon file in PACKAGES_DIR. Collect missing roles. (2) For each existing package, grep for each keyword (case-insensitive). If any keyword missing, add to stale array with format 'role:missing_keyword'. (3) Output JSON to stdout: {valid:BOOL,missing:[...],stale:[...]}. Use jq to build output: jq -n --argjson valid BOOL --argjson missing '[...]' --argjson stale '[...]' '{valid:$valid,missing:$missing,stale:$stale}'. valid=true only when missing=[] AND stale=[]. Exit code: 0 if valid=true, 1 if valid=false. Support --help flag: print usage and exit 0. Support --quiet flag: suppress stdout, exit code only. chmod +x after creation. Follow existing script patterns: see scripts/detect-stack.sh for jq dependency check pattern (lines 12-15), SCRIPT_DIR resolution pattern (line 19). Do NOT generate or write any package files. This is read-only validation.","ts":"tests/unit/build-reference-packages.bats: BATS framework. Setup: load common/fixtures/mock_stdin helpers via load '../test_helper/common' etc. mk_test_workdir. Create mock references/packages/ dir with 9 mock .toon files containing expected keywords. SUT=$SCRIPTS_DIR/build-reference-packages.sh. Tests: (1) outputs valid JSON when all packages present, (2) exit 0 when all packages valid, (3) exit 1 when a package file missing (remove dev.toon, assert missing contains 'dev'), (4) exit 1 when keyword missing from package (create architect.toon without 'Step 2', assert stale contains 'architect:Step 2'), (5) --help flag prints usage and exits 0, (6) --quiet flag suppresses stdout. Each test: run the script, assert_success or assert_failure, parse output with jq."}
{"id":"T2","tp":"auto","a":"Hand-author 9 reference package TOON files in references/packages/. Per D1, these are static files maintained alongside execute-protocol.md, NOT generated. Each package is self-contained with shared preamble, primary step protocol, artifact schemas, and escalation chain.","f":["references/packages/architect.toon","references/packages/lead.toon","references/packages/senior.toon","references/packages/dev.toon","references/packages/tester.toon","references/packages/qa.toon","references/packages/qa-code.toon","references/packages/critic.toon","references/packages/security.toon"],"v":"All 9 files exist, each under 3KB, each contains role-specific protocol sections, no file contains full execute-protocol.md content","done":"9 hand-authored per-role reference packages, each self-contained","spec":"Create directory: references/packages/. Create 9 TOON files following the references/departments/backend.toon pattern (key:value, indented sub-items, compact notation). EVERY package starts with an identical shared preamble section: preamble: commit_format: {type}({scope}): {desc} -- one commit per task. stage: git add {file} individually, never git add . or git add -A. escalation_protocol: escalate ONLY to direct report-to, include evidence + recommendation, never skip levels. verification_gate: ENTRY check predecessor artifact exists, EXIT verify output artifact + update .execution-state.json + commit state. Then role-specific sections as follows. ARCHITECT.TOON (~2KB): role: architect. step: Step 2 Architecture. protocol: entry_gate (critique.jsonl exists OR step 1 skipped), actions (compile context, provide reqs.jsonl + codebase + research.jsonl + critique.jsonl), output (architecture.toon), exit_gate (architecture.toon non-empty, steps.architecture=complete), commit (docs({phase}): architecture design). escalation: reports_to Lead, escalates_to User via Owner, triggers (design-level decision, scope change). artifact_schemas: architecture.toon format (tech_decisions[N]{decision,rationale,alternatives}, components[N]{name,responsibility,interface}, constraints, risks), decisions.jsonl ({ts,agent,task,dec,reason,alts[]}). cross_refs: reads critique.jsonl + reqs.jsonl + codebase/, addresses critique findings by updating st field. LEAD.TOON (~2KB): role: lead. step: Step 3 Load Plans + Step 10 Sign-off. protocol_step3: entry_gate (architecture.toon exists OR step 2 skipped), actions (glob plan.jsonl, read headers with jq, check summaries, build remaining list, write .execution-state.json), execution_state_schema ({phase,phase_name,status,started_at,step,wave,total_waves,plans:[{id,title,wave,status}],steps:{10 step objects}}), cross_phase_deps verification, exit_gate, commit (chore(state): execution state phase {N}). protocol_step10: entry_gate (security-audit.jsonl OR step 9 skipped + code-review approved), actions (review all artifacts, decide SHIP or HOLD), commit (chore(state): phase {N} complete). escalation: reports_to Architect, directs Senior+Tester+Dev+QA+Debugger. artifact_schemas: plan.jsonl header ({p,n,t,w,d[],xd[],mh,obj,sk[],fm[],auto}), plan.jsonl task ({id,tp,a,f[],v,done,spec,ts}), summary.jsonl ({p,n,t,s,dt,tc,tt,ch[],fm[],dv[],built[],tst}). SENIOR.TOON (~2.5KB): role: senior. step: Step 4 Design Review + Step 7 Code Review. protocol_step4: entry_gate (plan.jsonl exists), actions (read plan, research codebase with Glob/Grep, enrich spec field with EXACT instructions -- file paths, function signatures, imports, error handling, edge cases; enrich ts field with EXACT test instructions -- file, framework, cases, mocks, assertions), spec_quality (Dev needs ZERO creative decisions), ts_quality (Tester needs ZERO ambiguity), exit_gate (all tasks have non-empty spec), commit (docs({phase}): enrich plan {NN-MM} specs). protocol_step7: entry_gate (summary.jsonl valid JSONL), actions (read specs, git diff, review adherence+quality+errors+secrets, TDD compliance), output (code-review.jsonl), verdict_schema ({plan,r:approve|changes_requested,tdd:pass|fail|skip,cycle,dt}), finding_schema ({f,ln,sev,issue,sug}), max_cycles 2, commit (docs({phase}): code review {NN-MM}). escalation: reports_to Lead, directs Dev. decision_logging: append to decisions.jsonl ({ts,agent:senior,task,dec,reason,alts[]}). DEV.TOON (~1.5KB): role: dev. step: Step 6 Implementation. protocol: entry_gate (enriched plan.jsonl + test-plan.jsonl if step 5 ran). stage1: read plan.jsonl, parse header + tasks, each task has spec. stage2 per task: (1) read spec -- EXACT instruction set, (2) TDD RED check if ts+test-plan exist -- run tests verify FAIL, if PASS escalate to Senior, (3) implement files in f field, (4) follow spec precisely, (5) TDD GREEN check -- max 3 attempts then escalate, (6) run verify from v field, (7) validate done, (8) stage individually git add {file}, (9) commit {type}({phase}-{plan}): {task}. remediation: gaps.jsonl st:open fix FIRST. stage3: write summary.jsonl ({p,n,t,s,dt,tc,tt,ch[],fm[],dv[],built[],tst}). tst values: red_green, green_only, no_tests. escalation: reports_to Senior ONLY, never contacts Lead/Architect/QA/Security/User. triggers: spec unclear, blocked, 2 failures, architectural issue, tests pass before impl, 3 GREEN failures. TESTER.TOON (~1.5KB): role: tester. step: Step 5 Test Authoring (RED Phase). protocol: guard (skip if turbo OR no ts fields), entry_gate (enriched plan with spec fields), actions (write failing tests per ts specs, verify ALL FAIL), output (test-plan.jsonl + test files), test_plan_schema ({id,tf[],tc,red:bool,desc}), exit_gate (test-plan.jsonl with red:true all entries), commit (test({phase}): RED phase tests for plan {NN-MM}). escalation: reports_to Senior, triggers (ts unclear, tests pass unexpectedly). QA.TOON (~1.5KB): role: qa. step: Step 8 QA (Plan-level). protocol: guard (skip if --skip-qa OR turbo), entry_gate (code-review.jsonl r:approve), tiers (quick 5-10, standard 15-25, deep 30+), methodology (goal-backward from success criteria, read plan mh tr/ar/kl, read summary, derive checks, execute, collect evidence), output (verification.jsonl), result (PASS all pass, PARTIAL some fail core ok, FAIL critical must_have), remediation (FAIL -> Lead -> Senior -> Dev max 2 cycles), exit_gate, commit. escalation: reports_to Lead. artifact_schemas: verification.jsonl line1 ({tier,r,ps,fl,tt,dt}), lines2+ ({c,r,ev,cat}). QA-CODE.TOON (~1.5KB): role: qa-code. step: Step 8 QA (Code-level). protocol: entry_gate (code-review.jsonl r:approve), actions (TDD compliance, tests, lint, patterns, conventions), tdd_compliance (test-plan.jsonl entries have files, run tests, verify GREEN), output (qa-code.jsonl), remediation_loop (PARTIAL/FAIL -> gaps.jsonl st:open -> Dev fixes st:fixed -> re-verify max 2), exit_gate, commit (docs({phase}): code quality review). escalation: reports_to Lead. artifact_schemas: qa-code.jsonl line1 ({r,tests:{ps,fl,sk},lint:{err,warn},dt}), lines2+ ({f,ln,sev,issue,sug}), gaps.jsonl ({id,sev,desc,exp,act,st,res}). CRITIC.TOON (~1KB): role: critic. step: Step 1 Critique/Brainstorm. protocol: guard (skip if turbo OR critique.jsonl exists), entry_gate (phase dir exists), actions (analyze reqs + PROJECT.md + codebase + research, identify gaps/risks/improvements/questions/alternatives), output (critique.jsonl via SendMessage -- Critic has no Write tool), exit_gate (critique.jsonl valid JSONL), commit (docs({phase}): critique and gap analysis). escalation: reports_to Lead, findings advisory. artifact_schemas: critique.jsonl ({id:C1-CN,cat,sev,q,ctx,sug,st}). SECURITY.TOON (~1KB): role: security. step: Step 9 Security Audit. protocol: guard (skip if --skip-security OR config security_audit!=true), entry_gate (verification.jsonl OR step 8 skipped), actions (audit file list, secrets, deps, OWASP, config), output (security-audit.jsonl), result_handling (PASS continue, WARN display+gate, FAIL HARD STOP), exit_gate, commit (docs({phase}): security audit). escalation: reports_to Lead, FAIL bypasses chain -> User via go.md. artifact_schemas: line1 ({r,findings,critical,dt}), lines2+ ({cat,sev,f,issue,fix}). SIZE CONSTRAINT: Each file MUST be under 3KB. Use TOON compact notation (key:value, indented sub-items, no Markdown # headers). Follow references/departments/backend.toon pattern. Department-prefixed roles (fe-dev, ux-architect, etc.) reuse base-role packages via compile-context.sh BASE_ROLE mapping -- do NOT create separate packages.","ts":""}
{"id":"T3","tp":"auto","a":"Create tests/unit/build-reference-packages.bats: BATS test suite validating the sync-checker script AND verifying package content correctness (drift detection per R1).","f":["tests/unit/build-reference-packages.bats"],"v":"bats tests/unit/build-reference-packages.bats passes all tests","done":"12+ BATS tests covering sync validation, keyword presence, size limits, and missing-package detection","spec":"Create file: tests/unit/build-reference-packages.bats. Follow existing test patterns from tests/unit/compile-context.bats and tests/unit/detect-stack.bats. Setup function: load '../test_helper/common', load '../test_helper/fixtures', load '../test_helper/mock_stdin', mk_test_workdir. SUT=$SCRIPTS_DIR/build-reference-packages.sh. Create a helper function setup_mock_packages() that: (1) creates $TEST_WORKDIR/scripts/ dir and copies SUT there, (2) creates $TEST_WORKDIR/references/packages/ directory, (3) for each of the 9 roles creates a minimal .toon file containing the required keywords. Keywords per role match T1 spec exactly: dev.toon must contain 'Step 6', 'summary.jsonl', 'commit', 'escalat', 'TDD'; architect.toon must contain 'Step 2', 'architecture.toon', 'critique.jsonl', 'tech_decisions'; lead.toon must contain 'Step 3', 'Step 10', 'plan.jsonl', 'wave', 'execution-state'; senior.toon must contain 'Step 4', 'Step 7', 'spec', 'code-review.jsonl', 'design_review'; tester.toon must contain 'Step 5', 'test-plan.jsonl', 'RED', 'red'; qa.toon must contain 'Step 8', 'verification.jsonl', 'tier', 'must_have'; qa-code.toon must contain 'Step 8', 'qa-code.jsonl', 'TDD', 'lint'; critic.toon must contain 'Step 1', 'critique.jsonl', 'gap', 'finding'; security.toon must contain 'Step 9', 'security-audit.jsonl', 'vulnerability', 'FAIL'. Helper run_checker() runs: run bash '$TEST_WORKDIR/scripts/build-reference-packages.sh'. Tests to write (14 total, 7 mock-based + 7 real-package): MOCK-BASED (use TEST_WORKDIR): (1) @test 'outputs valid JSON when all packages present' -- setup_mock_packages, run_checker, assert_success, echo $output | jq . validates. (2) @test 'reports valid:true when all packages have keywords' -- assert jq .valid == true. (3) @test 'reports missing role when package file absent' -- setup_mock_packages, rm dev.toon, run_checker, assert_failure, jq '.missing | index(\"dev\")' is not null. (4) @test 'reports stale when keyword missing from package' -- setup_mock_packages, overwrite architect.toon with content lacking 'Step 2', run_checker, assert_failure, jq '.stale[]' contains 'architect'. (5) @test 'reports multiple missing roles' -- rm dev.toon AND qa.toon, assert missing array length is 2. (6) @test '--help flag prints usage' -- run with --help, assert_success, assert_output --partial 'Usage'. (7) @test '--quiet flag suppresses stdout' -- setup valid, run with --quiet, assert output is empty, assert_success. REAL-PACKAGE (use $PROJECT_ROOT/references/packages/): (8) @test 'actual packages pass sync check' -- run bash $SCRIPTS_DIR/build-reference-packages.sh, assert_success. (9) @test 'dev package contains Step 6 but not Step 2 or Step 4' -- run grep 'Step 6' $PROJECT_ROOT/references/packages/dev.toon assert_success; run grep 'Step 2' same file assert_failure; run grep 'Step 4' same file assert_failure. (10) @test 'senior package contains Step 4 and Step 7' -- grep both, assert_success. (11) @test 'each package is under 3KB' -- for f in $PROJECT_ROOT/references/packages/*.toon; do size=$(wc -c < $f); [ $size -lt 3072 ]; done. (12) @test 'qa package contains verification.jsonl reference' -- grep verification.jsonl qa.toon, assert_success. (13) @test 'security package contains FAIL handling' -- grep FAIL security.toon, assert_success. (14) @test 'all 9 package files exist' -- for each of 9 roles, assert [ -f $PROJECT_ROOT/references/packages/{role}.toon ].","ts":""}
