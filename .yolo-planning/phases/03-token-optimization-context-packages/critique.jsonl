{"id":"C1","cat":"risk","sev":"critical","q":"build-reference-packages.sh uses awk to extract sections by step header from execute-protocol.md but Markdown has nested headers, code blocks with # characters. Fragile awk parsing of Markdown with embedded code blocks is a known failure mode.","ctx":"Plan 03-02 T1 says 'Uses awk to extract sections by step header' against execute-protocol.md (490 lines, 30KB)","sug":"Either add structured delimiters to execute-protocol.md, or hand-author packages (C10 alternative), or use robust parser. Test with actual file content.","st":"open"}
{"id":"C2","cat":"gap","sev":"major","q":"03-02 creates per-role packages for 9 base roles only. 17 department-prefixed roles (fe-dev, ux-architect, etc.) unaddressed.","ctx":"compile-context.sh already maps fe-dev -> BASE_ROLE=dev. Plan is silent on whether fe-dev loads packages/dev.toon or packages/fe-dev.toon.","sug":"Explicitly state department-prefixed roles reuse base-role package. Add BATS test verifying fe-dev context includes packages/dev.toon.","st":"open"}
{"id":"C3","cat":"risk","sev":"major","q":"Plan 03-03 T1 proposes removing Bash tool from library project Dev agents. Dev agents rely on Bash for TDD protocol (run tests, verify FAIL/PASS).","ctx":"Agent yolo-dev.md has tools: Read,Glob,Grep,Write,Edit,Bash. execute-protocol.md Step 6 requires running tests.","sug":"Never remove Bash from Dev. Restrict non-essential tools instead (WebSearch, NotebookEdit for library projects).","st":"open"}
{"id":"C4","cat":"gap","sev":"major","q":"No mechanism specified for HOW resolved tool permissions reach agent spawning. Task tool reads agent YAML frontmatter directly.","ctx":"resolve-tool-permissions.sh outputs JSON but nothing specifies how that JSON gets consumed by Task tool or compile-context.sh.","sug":"Clarify integration path: pass resolved disallowedTools to Task tool prompt, or modify agent YAML at init time, or include in compiled context (soft enforcement).","st":"open"}
{"id":"C5","cat":"gap","sev":"major","q":"No measurable token reduction baseline or target defined. How will acceptance criterion 'measurably reduced' be verified?","ctx":"Smaller compiled context does not equal smaller token usage. No measurement mechanism for actual LLM token consumption.","sug":"Measure compiled context file sizes (chars/4 = approx tokens) before/after for each role. Define minimum reduction target (e.g., 30%). Add BATS test comparing old vs new size.","st":"open"}
{"id":"C6","cat":"risk","sev":"major","q":"Extracted reference packages may lose critical cross-references between steps. Dev package with only Step 6 loses entry gate template, escalation chain, TDD protocol spanning Steps 5-7.","ctx":"Step 6 references Step 5 test-plan.jsonl, Step 7 Senior escalation, Verification Gate Protocol section.","sug":"Include in each package: primary step(s), Verification Gate Protocol template, escalation chain, cross-step references. Add shared preamble.","st":"open"}
{"id":"C7","cat":"question","sev":"major","q":"03-04 says 'backward compatible if packages/ missing' but also 'no full execute-protocol.md reference'. These conflict -- if packages missing AND full files not referenced, agents get no protocol context.","ctx":"Must-have truth says no full file. Fallback says backward compatible.","sug":"Fallback should reference full files when packages/ absent. 'No full file' must-have applies only when packages exist. Add BATS test for fallback.","st":"open"}
{"id":"C8","cat":"risk","sev":"minor","q":"validate-gates.sh must handle complex OR-conditions (artifact exists OR step skipped) for all 10 steps with different artifact types.","ctx":"Each step has conditional entry with .execution-state.json lookups + file existence checks.","sug":"Design as lookup table (step -> artifact path + validation command) rather than hardcoded per-step logic.","st":"open"}
{"id":"C9","cat":"improvement","sev":"minor","q":"compile-context.sh currently does NOT reference protocol files. Adding packages may INCREASE token usage if packages are larger than zero (current compiled context has zero protocol content).","ctx":"compile-context.sh generates .ctx-{role}.toon with phase/goal/reqs/conventions/patterns. Protocol files loaded via agent YAML body or Task prompt.","sug":"Verify WHERE agents currently receive protocol context before modifying compile-context.sh. Map current loading path.","st":"open"}
{"id":"C10","cat":"alternative","sev":"minor","q":"Instead of awk extraction (03-02 T1), hand-author reference packages as TOON files maintained alongside execute-protocol.md.","ctx":"references/departments/ already uses hand-authored TOON pattern. Script extraction introduces fragile generated-from-source pattern.","sug":"Hand-authored packages avoid fragile extraction. Add BATS test validating package content against execute-protocol.md keywords for sync.","st":"open"}
{"id":"C11","cat":"gap","sev":"minor","q":"03-01 T4 specifies 22+ BATS tests but does not mention test fixtures for valid/invalid plans, mock phase dirs.","ctx":"Existing tests use tests/test_helper/ with common.bash and fixtures.bash creating TEST_WORKDIR.","sug":"Add fixture creation to T4: valid-plan.jsonl, invalid-plan.jsonl, mock-phase-dir with various artifact combinations.","st":"open"}
{"id":"C12","cat":"risk","sev":"minor","q":"Wave ordering assumes 03-01 and 03-02 both read execute-protocol.md without modifying it. Only 03-04 modifies it.","ctx":"validate-gates.sh reads enforcement contract table. build-reference-packages.sh extracts step content. Neither modifies in wave 1.","sug":"Document assumption: enforcement contract table stays in execute-protocol.md, not moved to packages.","st":"open"}
