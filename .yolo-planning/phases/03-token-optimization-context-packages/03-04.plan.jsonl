{"p":"03","n":"04","t":"Context Compiler & Protocol Integration","w":2,"d":["03-01","03-02"],"xd":[],"mh":{"tr":["compile-context.sh includes per-role reference packages instead of @-referencing full files","execute-protocol.md references validate-gates.sh and generate-execution-state.sh for Steps 3 and 6-10","Agent spawn in execute-protocol.md passes resolved tool permissions","Token budget enforcement accounts for reference package size","All 606 existing regression tests still pass after integration"],"ar":[{"p":"scripts/compile-context.sh","pv":"file modified to reference packages/","c":"includes per-role reference package path in compiled context instead of full reference tree"},{"p":"references/execute-protocol.md","pv":"file modified to reference new scripts","c":"Steps 3, 6-10 reference validate-gates.sh; Step 3 references generate-execution-state.sh"}],"kl":[{"fr":"scripts/compile-context.sh","to":"references/packages/dev.toon","vi":"dev context includes reference to packages/dev.toon instead of full execute-protocol.md"},{"fr":"references/execute-protocol.md","to":"scripts/validate-gates.sh","vi":"entry gate checks delegate to validate-gates.sh"},{"fr":"references/execute-protocol.md","to":"scripts/generate-execution-state.sh","vi":"Step 3 uses generate-execution-state.sh instead of inline JSON construction"},{"fr":"references/execute-protocol.md","to":"scripts/resolve-tool-permissions.sh","vi":"agent spawn includes resolved tool permissions from project type"}]},"obj":"Integrate all Phase 3 scripts and packages into the existing workflow: update compile-context.sh to use reference packages, update execute-protocol.md to call new validation/generation scripts, wire tool permission resolution into agent spawning. REQ-04, REQ-05, REQ-06.","sk":["commit"],"fm":["scripts/compile-context.sh","references/execute-protocol.md","tests/unit/compile-context-packages.bats","tests/integration/token-optimization.bats"],"auto":true}
{"id":"T1","tp":"auto","a":"Update scripts/compile-context.sh: for each role's context generation, add a reference to the role's package file (references/packages/{base_role}.toon) instead of @-referencing full execute-protocol.md or company-hierarchy.md. Add a new helper get_reference_package() that resolves the package path and includes it in compiled output. Ensure token budget enforcement accounts for package content size. Preserve all existing functionality (backward compatible if packages/ dir missing). REQ-04, REQ-05.","f":["scripts/compile-context.sh"],"v":"Compiled context for dev role references packages/dev.toon, not execute-protocol.md; compiled context for senior references packages/senior.toon; context size is smaller than before","done":"compile-context.sh includes per-role reference packages with backward-compatible fallback","spec":"FILE: scripts/compile-context.sh (MODIFY existing file, 626 lines). All changes ADDITIVE to existing code, preserving all current functionality. --- HELPER 1: get_reference_package() --- Insert after get_dept_conventions() (after line 148, before line 150 get_architecture). Function signature: get_reference_package() with no args (reads globals BASE_ROLE). Logic: (1) Construct path: PACKAGE_PATH=\"references/packages/${BASE_ROLE}.toon\". (2) If [ -f \"$PACKAGE_PATH\" ]; then echo the path; return 0. (3) Else return 1 (no package found). This helper is called by each role's case block. Backward compat: when references/packages/ dir does not exist, function returns 1 and callers skip package inclusion (D6). --- HELPER 2: get_tool_restrictions() --- Insert immediately after get_reference_package(). Function signature: get_tool_restrictions() with no args (reads globals ROLE). Logic: (1) Resolve SCRIPT_DIR from $0 (or use CLAUDE_PLUGIN_ROOT if set): RESOLVE_SCRIPT=\"${CLAUDE_PLUGIN_ROOT:-$(cd \"$(dirname \"$0\")\" && pwd)/..}/scripts/resolve-tool-permissions.sh\". (2) If [ -x \"$RESOLVE_SCRIPT\" ]; then call it: TOOL_JSON=$(bash \"$RESOLVE_SCRIPT\" --role \"$ROLE\" --project-dir \".\") (3) Extract disallowed_tools array: DISALLOWED=$(echo \"$TOOL_JSON\" | jq -r '.disallowed_tools // [] | join(\", \")' 2>/dev/null). (4) If [ -n \"$DISALLOWED\" ]; then emit: echo \"tool_restrictions:\"; echo \"  Do NOT use: $DISALLOWED\". (5) Else return 0 silently (no restrictions for this role/project-type). Fallback: if resolve-tool-permissions.sh does not exist (pre-phase-3), function silently returns 0. --- CASE BLOCK MODIFICATIONS --- For EACH role case (architect, lead, senior, dev, qa, qa-code, tester, security, debugger, critic, owner, scout): Add TWO new sections inside the { ... } > output block, BEFORE the closing } redirect. Section 1 - reference_package: Insert after existing content but before closing: REF_PKG=$(get_reference_package) && { echo ''; echo \"reference_package: @${REF_PKG}\"; } Section 2 - tool_restrictions: Insert after reference_package: get_tool_restrictions. IMPORTANT: Both sections must be inside the { } block that redirects to the output .toon file. Exact insertion points per role: (a) architect (line 290): Insert before '} > \"${PHASE_DIR}/.ctx-${ROLE}.toon\"'. After 'echo \"success_criteria: $PHASE_SUCCESS\"' add newline then REF_PKG line then get_tool_restrictions. (b) lead (line 327): Insert before closing redirect. After 'echo \"success_criteria: $PHASE_SUCCESS\"'. (c) senior (line 371): Insert before closing redirect. After the dept_conventions block (the 'echo \"$DEPT_CONV\" | sed' block). (d) dev (line 419): Insert before closing redirect. After the skills block (the 'done <<< \"$SKILLS\"' + fi + fi). (e) qa (line 444): Insert before closing redirect. After the conventions block. (f) qa-code (line 476): Insert before closing redirect. After 'get_research'. (g) tester (line 509): Insert before closing redirect. After the dept_conventions block. (h) owner (line 533): Insert before closing redirect. After the api_contracts block. (i) security (line 557): Insert before closing redirect. After the dependency_files block. (j) debugger (line 576): Insert before closing redirect. After the gaps block. (k) critic (line 602): Insert before closing redirect. After 'echo \"success_criteria: $PHASE_SUCCESS\"'. (l) scout (line 610): Insert before closing redirect. After 'get_requirements'. --- BUDGET ENFORCEMENT --- No changes needed to enforce_budget() or get_budget(). Package content is included via @-reference (just a path string, ~50 chars) so budget impact is minimal. The @-reference itself is small; the referenced file content is loaded by the consumer (Task tool), not embedded in compiled context. --- BACKWARD COMPATIBILITY (D6) --- get_reference_package() returns 1 when packages/ dir absent. The && { ... } pattern means the echo block only runs if get_reference_package succeeds. When it fails, nothing is emitted. This preserves pre-phase-3 behavior exactly. get_tool_restrictions() silently returns 0 when resolve-tool-permissions.sh is absent. --- CONSTRAINTS --- bash 3.2 compatible (no associative arrays). Uses jq only for JSON parsing in get_tool_restrictions(). All existing compile-context.bats and compile-context-dept.bats tests must still pass after these changes.","ts":""}
{"id":"T2","tp":"auto","a":"Update references/execute-protocol.md: (1) In Verification Gate Protocol section, add instruction to run validate-gates.sh for entry gate checks instead of inline file existence checks. (2) In Step 3 Load Plans, reference generate-execution-state.sh for building .execution-state.json instead of inline JSON schema. (3) In agent spawn sections (Steps 1,2,4,5,6,7,8,9), add note about passing resolved tool permissions via resolve-tool-permissions.sh. (4) Add note in Pre-Execution about running validate-plan.sh on all plan.jsonl files before execution. Keep all existing content -- these are additive references. REQ-04, REQ-06.","f":["references/execute-protocol.md"],"v":"Protocol references all 4 new scripts (validate-plan.sh, validate-gates.sh, generate-execution-state.sh, resolve-tool-permissions.sh); no existing protocol steps removed","done":"execute-protocol.md updated with script references for validation and generation","spec":"FILE: references/execute-protocol.md (MODIFY existing file, 490 lines). ALL changes are ADDITIVE -- no existing content is removed or reworded. Each change adds a new paragraph, note block, or code block after existing content. --- CHANGE 1: Pre-Execution section (after line 17, after step 3 'Resolve models for all agents') --- Add a new step 4 (renumber nothing, just add after the model resolution code block): '4. **Validate all plans:** Before execution, validate every plan.jsonl in the phase directory:\\n   ```bash\\n   for plan in \"${PHASE_DIR}\"/*.plan.jsonl; do\\n     result=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate-plan.sh --plan \"$plan\")\\n     if [ $? -ne 0 ]; then\\n       echo \"Plan validation failed: $plan\" >&2\\n       echo \"$result\" | jq -r '.errors[]' >&2\\n       exit 1\\n     fi\\n   done\\n   ```\\n   This replaces LLM-based plan validation. Invalid plans STOP execution before any agent spawns.' Insert this AFTER the closing ``` of the model resolution code block (line 23) and BEFORE the '### Context Scoping Protocol' header (line 25). --- CHANGE 2: Verification Gate Protocol section (after line 52, after the skip condition bullet) --- Add a new paragraph after the existing 'If NEITHER artifact exists NOR step is skipped' bullet: '\\n> **Script delegation:** Entry gate checks can be delegated to `validate-gates.sh` for deterministic verification:\\n> ```bash\\n> result=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate-gates.sh --step \"{step_name}\" --phase-dir \"{phase-dir}\")\\n> if [ $? -ne 0 ]; then\\n>   echo \"$result\" | jq -r '.missing[]' >&2\\n>   STOP \"{Step N} artifact missing\"\\n> fi\\n> ```\\n> This replaces inline file existence checks with a centralized lookup table (see scripts/validate-gates.sh).' Insert AFTER line 52 ('STOP \"{Step N} artifact missing...' line) and BEFORE the '### State Commit' header (line 54). --- CHANGE 3: Step 3 Load Plans (inside item 7, after the JSON schema block) --- After the closing ``` of the .execution-state.json schema (line 148), add: '\\n   > **Script alternative:** Use `generate-execution-state.sh` to build this JSON deterministically:\\n   > ```bash\\n   > bash ${CLAUDE_PLUGIN_ROOT}/scripts/generate-execution-state.sh --phase-dir \"{phase-dir}\" --phase {N}\\n   > ```\\n   > This replaces inline JSON construction. The script scans *.plan.jsonl files, extracts metadata, and writes the full schema above.' Insert AFTER line 148 (closing ``` of JSON) and BEFORE '   Commit: `chore(state): execution state phase {N}`' (line 149). --- CHANGE 4: Agent spawn tool permissions note --- Add a note block to EACH of the following steps, inserted AFTER the Spawn command/code block and BEFORE the Display line. The note text is identical for all steps: '\\n   > **Tool permissions:** When spawning agents, resolve project-type-specific tool permissions:\\n   > ```bash\\n   > TOOL_PERMS=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/resolve-tool-permissions.sh --role \"{role}\" --project-dir \".\")\\n   > ```\\n   > Include resolved `disallowed_tools` from the output in the agent\\'s compiled context (.ctx-{role}.toon). See D4 in architecture for soft enforcement details.' Steps to add this note: (a) Step 1 item 2 (line 91-92): After 'Spawn yolo-critic with Task tool:' block, before 'Display:' line 96. Use role='critic'. (b) Step 2 item 2 (line 110): After 'Spawn yolo-architect with Task tool:' block, before 'Display:' line 114. Use role='architect'. (c) Step 4 item 3 (line 166): After 'Spawn yolo-senior with Task tool:' block, before 'Display:' line. Use role='senior'. (d) Step 5 item 3 (line 184): After 'Spawn yolo-tester with Task tool:' block, before 'Display:' line. Use role='tester'. (e) Step 6 item 3 (line 202-213): After the TaskCreate code block, before 'Wire dependencies' line 214. Use role='dev'. (f) Step 7 item 2 (line 238-241): After 'Spawn yolo-senior with Task tool:' block, before 'Display:' line. Use role='senior'. (g) Step 8 item 4 (line 271): After 'Spawn yolo-qa:' block, before 'QA Lead produces'. Use role='qa'. Also add after 'Spawn yolo-qa-code:' (line 278) before 'QA Code runs'. Use role='qa-code'. (h) Step 9 item 3 (line 326): After 'Spawn yolo-security:' block, before 'Security produces'. Use role='security'. --- CONSTRAINTS --- Do NOT remove or reword any existing text. Every change is a new block inserted between existing lines. The final file should still be valid Markdown. No line numbers in existing content shift (new content is added, not replacing). Verify by grepping for all 4 script names: validate-plan.sh, validate-gates.sh, generate-execution-state.sh, resolve-tool-permissions.sh.","ts":""}
{"id":"T3","tp":"auto","a":"Create tests/unit/compile-context-packages.bats: test that compile-context.sh correctly includes reference packages. Tests: dev context includes packages/dev.toon reference, senior context includes packages/senior.toon reference, qa context includes packages/qa.toon reference, fallback works when packages/ dir missing, context with packages is smaller than without, all existing compile-context tests still pass. 8+ tests.","f":["tests/unit/compile-context-packages.bats"],"v":"bats tests/unit/compile-context-packages.bats passes all tests","done":"8+ BATS tests verifying reference package integration in compile-context.sh","spec":"FILE: tests/unit/compile-context-packages.bats (CREATE new file). Follow exact patterns from tests/unit/compile-context.bats and tests/unit/compile-context-dept.bats. --- SETUP --- setup() function: (1) load '../test_helper/common', load '../test_helper/fixtures', load '../test_helper/mock_stdin'. (2) mk_test_workdir. (3) SUT=\"$SCRIPTS_DIR/compile-context.sh\". (4) Create phase dir: mkdir -p \"$TEST_WORKDIR/.yolo-planning/phases/01-setup\". (5) Create ROADMAP: cat > \"$TEST_WORKDIR/.yolo-planning/ROADMAP.md\" with Phase 1 having Goal/Reqs/Success (copy from compile-context.bats setup). (6) Create conventions.json (copy from compile-context.bats setup). (7) Create reference packages directory and mock package files: mkdir -p \"$TEST_WORKDIR/references/packages\". For each of 9 roles, create a minimal .toon file: echo 'role: {role}' > \"$TEST_WORKDIR/references/packages/{role}.toon\"; echo 'step_protocol: Step {N} extract' >> ...; echo 'escalation: {chain}' >> ... Content should be role-appropriate (~200 bytes each): architect.toon (Step 2), lead.toon (Step 3, 10), senior.toon (Step 4, 7), dev.toon (Step 6), tester.toon (Step 5), qa.toon (Step 8), qa-code.toon (Step 8), critic.toon (Step 1), security.toon (Step 9). (8) Set PHASES_DIR=\"$TEST_WORKDIR/.yolo-planning/phases\". --- HELPER --- run_cc() { local phase=\"$1\" role=\"$2\"; shift 2; run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' '$phase' '$role' '$PHASES_DIR' $*\"; } (same as compile-context.bats). --- TESTS (10 tests) --- Test 1: 'dev context includes reference_package when packages/ exists'. run_cc 01 dev. assert_success. Read .ctx-dev.toon. assert_output --partial 'reference_package:'. assert_output --partial 'packages/dev.toon'. Test 2: 'senior context includes reference_package for senior.toon'. run_cc 01 senior. assert_success. Read .ctx-senior.toon. assert_output --partial 'reference_package:'. assert_output --partial 'packages/senior.toon'. Test 3: 'qa context includes reference_package for qa.toon'. run_cc 01 qa. assert_success. Read .ctx-qa.toon. assert_output --partial 'reference_package:'. assert_output --partial 'packages/qa.toon'. Test 4: 'architect context includes reference_package for architect.toon'. run_cc 01 architect. assert_success. Read .ctx-architect.toon. assert_output --partial 'packages/architect.toon'. Test 5: 'fe-dev context includes packages/dev.toon (BASE_ROLE mapping, D2)'. run_cc 01 fe-dev. assert_success. Read .ctx-fe-dev.toon. assert_output --partial 'packages/dev.toon' (NOT packages/fe-dev.toon). Test 6: 'fallback: no reference_package when packages/ dir missing'. Remove packages dir: rm -rf \"$TEST_WORKDIR/references/packages\". run_cc 01 dev. assert_success. Read .ctx-dev.toon. run grep 'reference_package' on output. assert_failure (grep should NOT find it). Test 7: 'all 9 base roles include reference_package'. For each role in architect lead senior dev qa qa-code security critic: run_cc 01 {role} and verify .ctx-{role}.toon contains 'reference_package:'. For tester: needs plan file -- use fixture: cp \"$FIXTURES_DIR/plans/valid-plan.jsonl\" to phase dir, pass as arg 4. For scout/owner/debugger: these roles may not have packages (no packages/scout.toon, packages/owner.toon, packages/debugger.toon created in setup). Verify they produce output without reference_package (graceful absence). Test 8: 'context with packages is not drastically larger (budget check)'. run_cc 01 dev. Read .ctx-dev.toon. Count chars: chars=$(wc -c < ctx). Compute tokens=$((chars / 4)). Assert tokens -le 2000 (dev budget). Ensures package @-reference does not blow budget. Test 9: 'tool_restrictions section absent when resolve-tool-permissions.sh not available'. Since resolve-tool-permissions.sh does not exist in test environment, run_cc 01 dev. Read output. run grep 'tool_restrictions' on ctx. assert_failure (no tool restrictions emitted). Test 10: 'ux-architect uses packages/architect.toon (dept prefix stripped)'. run_cc 01 ux-architect. assert_success. Read .ctx-ux-architect.toon. assert_output --partial 'packages/architect.toon'. --- FILE HEADER --- #!/usr/bin/env bats with comment: # compile-context-packages.bats -- Tests for reference package integration in compile-context.sh.","ts":"FILE: tests/unit/compile-context-packages.bats. FRAMEWORK: bats-core with bats-support, bats-assert, bats-file (loaded via test_helper/common). TEST CASES (10): (1) dev context includes reference_package @-reference to packages/dev.toon -- assert_output --partial 'reference_package:' and 'packages/dev.toon'. (2) senior context includes packages/senior.toon reference -- same pattern. (3) qa context includes packages/qa.toon reference -- same pattern. (4) architect context includes packages/architect.toon reference. (5) fe-dev resolves to packages/dev.toon via BASE_ROLE mapping (D2) -- assert_output --partial 'packages/dev.toon', refute_output --partial 'packages/fe-dev.toon'. (6) fallback: no reference_package when packages/ dir absent -- rm -rf packages, run, grep reference_package should fail. (7) all 9 base roles include reference_package (loop test). (8) budget not exceeded with package reference (dev context tokens <= 2000). (9) tool_restrictions absent when resolve-tool-permissions.sh not installed. (10) ux-architect maps to packages/architect.toon. MOCKS: Mock package files (~200 bytes each) created in setup. No mock for resolve-tool-permissions.sh (test its absence). ASSERTIONS: assert_success, assert_output --partial, assert_failure on grep, wc -c budget check. All tests must pass: bats tests/unit/compile-context-packages.bats."}
{"id":"T4","tp":"auto","a":"Create tests/integration/token-optimization.bats: end-to-end integration tests measuring token optimization. Tests: validate-plan.sh catches invalid plan and accepts valid plan, validate-gates.sh reports correct gate status for each step, generate-execution-state.sh produces valid state from real phase dir, compile-context.sh with packages produces smaller output than without, resolve-tool-permissions.sh returns correct tools for YOLO's own cli-tool type, full pipeline (detect-stack -> resolve-permissions -> compile-context) works. 6+ integration tests. Verify 606 regression baseline with dedicated test. REQ-04, REQ-05, REQ-06.","f":["tests/integration/token-optimization.bats"],"v":"bats tests/integration/token-optimization.bats passes all tests","done":"6+ integration tests verifying full token optimization pipeline","spec":"FILE: tests/integration/token-optimization.bats (CREATE new file). Follow patterns from tests/integration/plan-execute-summary.bats and tests/integration/bootstrap-flow.bats. --- SETUP --- setup() function: (1) load '../test_helper/common', load '../test_helper/fixtures', load '../test_helper/mock_stdin'. (2) mk_test_workdir. (3) Set script paths: VALIDATE_PLAN=\"$SCRIPTS_DIR/validate-plan.sh\", VALIDATE_GATES=\"$SCRIPTS_DIR/validate-gates.sh\", GEN_STATE=\"$SCRIPTS_DIR/generate-execution-state.sh\", COMPILE_CTX=\"$SCRIPTS_DIR/compile-context.sh\", RESOLVE_PERMS=\"$SCRIPTS_DIR/resolve-tool-permissions.sh\", DETECT_STACK=\"$SCRIPTS_DIR/detect-stack.sh\". (4) Create full phase environment: mkdir -p \"$TEST_WORKDIR/.yolo-planning/phases/01-setup\"; create ROADMAP.md (copy from compile-context.bats pattern); create conventions.json; create .yolo-planning/codebase/ with INDEX.md, PATTERNS.md from fixtures. (5) Copy valid-plan.jsonl to phase dir as 01-01.plan.jsonl. (6) Create mock reference packages: mkdir -p \"$TEST_WORKDIR/references/packages\"; for each of 9 roles create minimal .toon (~200 bytes). --- HELPER --- run_from_workdir() { run bash -c \"cd '$TEST_WORKDIR' && $*\"; } --- TESTS (8 tests) --- Test 1: 'validate-plan.sh accepts valid plan'. Skip if script not present: [ -x \"$VALIDATE_PLAN\" ] || skip 'validate-plan.sh not yet built (03-01 dependency)'. run_from_workdir bash \"$VALIDATE_PLAN\" --plan \"$TEST_WORKDIR/.yolo-planning/phases/01-setup/01-01.plan.jsonl\". assert_success. Run jq -r '.valid' on output. assert_output 'true'. Test 2: 'validate-plan.sh rejects invalid plan'. Skip if not present. Create invalid plan (echo '{\"bad\":true}' > invalid.plan.jsonl). run_from_workdir bash \"$VALIDATE_PLAN\" --plan invalid.plan.jsonl. assert_failure. Test 3: 'generate-execution-state.sh produces valid state from phase dir'. Skip if not present. run_from_workdir bash \"$GEN_STATE\" --phase-dir \"$TEST_WORKDIR/.yolo-planning/phases/01-setup\" --phase 1. assert_success. Verify .execution-state.json created and has correct schema: jq -r '.status' should be 'running', jq -r '.plans | length' should be > 0, jq -r '.steps.critique.status' should be 'pending'. Test 4: 'compile-context.sh with packages includes reference_package section'. run_from_workdir bash \"$COMPILE_CTX\" 01 dev \"$TEST_WORKDIR/.yolo-planning/phases\" \"$TEST_WORKDIR/.yolo-planning/phases/01-setup/01-01.plan.jsonl\". assert_success. Read the output .ctx-dev.toon file. assert_output --partial 'reference_package:'. Test 5: 'compile-context.sh without packages omits reference_package section'. rm -rf \"$TEST_WORKDIR/references/packages\". run_from_workdir bash \"$COMPILE_CTX\" 01 dev \"$TEST_WORKDIR/.yolo-planning/phases\" \"$TEST_WORKDIR/.yolo-planning/phases/01-setup/01-01.plan.jsonl\". assert_success. Read .ctx-dev.toon. run grep 'reference_package' on ctx. assert_failure. Test 6: 'full pipeline: compile-context.sh output is valid TOON with all sections'. Recreate packages dir (setup again or conditional). run_from_workdir bash \"$COMPILE_CTX\" 01 senior \"$TEST_WORKDIR/.yolo-planning/phases\". assert_success. Read .ctx-senior.toon. Verify it contains: 'phase: 01', 'goal:', 'conventions', 'reference_package:'. Verify tokens within budget: chars=$(wc -c < ctx); tokens=$((chars / 4)); [ \"$tokens\" -le 4000 ]. Test 7: 'resolve-tool-permissions.sh returns JSON for dev role'. Skip if not present. run_from_workdir bash \"$RESOLVE_PERMS\" --role dev --project-dir \"$TEST_WORKDIR\". assert_success. Validate output is JSON: echo \"$output\" | jq empty. Verify has 'role' and 'tools' keys. Test 8: 'validate-gates.sh checks critique gate for step 1'. Skip if not present. Create mock execution state with critique pending. run_from_workdir bash \"$VALIDATE_GATES\" --step critique --phase-dir \"$TEST_WORKDIR/.yolo-planning/phases/01-setup\". The gate should pass (Step 1 entry gate is just phase dir existence) or fail with structured JSON depending on whether critique.jsonl exists. Either way: verify output is valid JSON (echo \"$output\" | jq empty succeeds). --- NOTES --- Tests 1,2,3,7,8 use 'skip' guard for scripts from 03-01 and 03-03 that may not exist yet. This makes the integration test suite runnable at any point during phase 3 execution. Tests 4,5,6 test compile-context.sh which IS being modified in this plan (T1). --- FILE HEADER --- #!/usr/bin/env bats with comment: # token-optimization.bats -- Integration tests for Phase 3 token optimization pipeline.","ts":"FILE: tests/integration/token-optimization.bats. FRAMEWORK: bats-core with bats-support, bats-assert, bats-file (loaded via test_helper/common). TEST CASES (8): (1) validate-plan.sh accepts valid plan -- skip guard, assert_success, jq .valid==true. (2) validate-plan.sh rejects invalid plan -- skip guard, assert_failure. (3) generate-execution-state.sh produces valid state -- skip guard, verify schema keys. (4) compile-context with packages includes reference_package -- assert_output --partial. (5) compile-context without packages omits reference_package -- rm packages, grep should fail. (6) full pipeline senior context is valid and within budget -- verify sections + token count <= 4000. (7) resolve-tool-permissions.sh returns valid JSON for dev -- skip guard, jq empty on output. (8) validate-gates.sh returns structured JSON -- skip guard, jq empty on output. MOCKS: Mock package files (~200 bytes each), valid-plan.jsonl fixture, mock execution state. Scripts from 03-01/03-03 guarded with skip. ASSERTIONS: assert_success, assert_failure, assert_output --partial, jq schema validation, wc -c budget check. All tests must pass: bats tests/integration/token-optimization.bats."}
