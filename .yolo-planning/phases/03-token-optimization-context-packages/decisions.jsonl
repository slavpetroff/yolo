{"ts":"2026-02-16T22:00:00Z","agent":"lead","task":"phase-3-decomposition","dec":"4 plans across 2 waves: script offloading (W1) + reference packages (W1) then tool permissions (W2) + integration (W2)","reason":"Wave 1 plans have zero file overlap and can execute in parallel. Wave 2 plans depend on Wave 1 outputs but not on each other.","alts":["3 plans (merge scripts + packages into one large plan)","5 plans (split integration into protocol update + context update)"]}
{"ts":"2026-02-16T22:01:00Z","agent":"lead","task":"phase-3-decomposition","dec":"3 new scripts for REQ-04: validate-plan.sh, validate-gates.sh, generate-execution-state.sh","reason":"These 3 replace the most token-heavy LLM work: plan structure validation (QA agent), gate artifact checking (execute-protocol inline), and state JSON construction (Step 3 inline). Each is deterministic and needs no LLM reasoning.","alts":["validate-summary.sh (already exists)","generate-summary-scaffold.sh (lower token savings, summary content needs LLM)"]}
{"ts":"2026-02-16T22:02:00Z","agent":"lead","task":"phase-3-decomposition","dec":"Reference packages as static TOON files in references/packages/, generated by build-reference-packages.sh","reason":"Per-role packages are deterministic extracts from execute-protocol.md. A script can extract the right sections via awk. Static files avoid runtime generation overhead. TOON format matches existing compile-context.sh patterns.","alts":["Dynamic extraction at compile-context.sh runtime (slower, redundant work per invocation)","Manual per-role reference files (unmaintainable, drift from source)"]}
{"ts":"2026-02-16T22:03:00Z","agent":"lead","task":"phase-3-decomposition","dec":"Tool permissions resolved at runtime via config+script, not by modifying agent YAML files","reason":"Agent YAML files are static plugin assets. Modifying them per-project would break the plugin model. Runtime resolution via resolve-tool-permissions.sh + config/tool-permissions.json preserves static YAMLs while enabling dynamic adaptation.","alts":["Generate project-specific agent YAML copies (complex, maintenance burden)","Per-project overrides in .yolo-planning/config.json (mixing concerns)"]}
{"ts":"2026-02-16T22:30:00Z","agent":"architect","task":"architecture-design","dec":"Hand-author reference packages instead of awk-based extraction (C1, C10)","reason":"execute-protocol.md has nested headers, code blocks with # chars, embedded JSON. awk extraction is fragile. references/departments/ already uses hand-authored TOON pattern. Sync-checker BATS test prevents drift from source.","alts":["awk extraction with structured delimiters","robust Markdown parser (not bash/jq compatible)"]}
{"ts":"2026-02-16T22:31:00Z","agent":"architect","task":"architecture-design","dec":"Department-prefixed roles reuse base-role packages (C2)","reason":"compile-context.sh already maps fe-dev to BASE_ROLE=dev. 9 base packages cover all 26 agents. No need for 17 additional department-specific packages.","alts":["separate fe-dev.toon packages (153 files)","dept-prefix lookup table"]}
{"ts":"2026-02-16T22:32:00Z","agent":"architect","task":"architecture-design","dec":"Never remove Bash from Dev agents (C3)","reason":"TDD RED/GREEN protocol requires Bash for test execution. Restrict non-essential tools only: WebSearch, WebFetch, NotebookEdit per project type.","alts":["remove Bash for library projects (breaks TDD)"]}
{"ts":"2026-02-16T22:33:00Z","agent":"architect","task":"architecture-design","dec":"Soft enforcement for tool permissions via compiled context (C4)","reason":"Task tool reads agent YAML frontmatter directly — no runtime injection mechanism. Soft enforcement via 'Do NOT use: {tools}' in compiled context covers 95% of cases. Hard enforcement reserved for EnterPlanMode/ExitPlanMode.","alts":["modify YAML at init (breaks plugin model)","pass to Task tool prompt directly (no centralized config)"]}
{"ts":"2026-02-16T22:34:00Z","agent":"architect","task":"architecture-design","dec":"Token reduction measured by compiled context file size, 25% minimum target (C5)","reason":"No LLM token consumption API available. chars/4 approximates tokens. 25% target achievable given packages (1-3KB) replace full @-references (30KB execute-protocol.md).","alts":["token counting API (unavailable)","manual measurement (not repeatable)"]}
{"ts":"2026-02-16T22:35:00Z","agent":"architect","task":"architecture-design","dec":"Fallback: packages absent means full @-reference files used (C7)","reason":"Resolves contradiction between backward compatibility and no-full-file rule. 'No full file' applies only when packages/ exists. When absent, full files used as before.","alts":["always require packages (breaks backward compat)","always include full files (no savings)"]}
{"ts":"2026-02-16T22:36:00Z","agent":"architect","task":"architecture-design","dec":"validate-gates.sh uses case-statement lookup table (C8)","reason":"10 steps with different artifacts and skip conditions. Data-driven lookup more maintainable than hardcoded branches. bash 3.2 compatible (no associative arrays).","alts":["hardcoded per-step if/then","external JSON config"]}
{"ts":"2026-02-16T22:37:00Z","agent":"architect","task":"architecture-design","dec":"Wave ordering assumption documented: execute-protocol.md read-only in wave 1 (C12)","reason":"validate-gates.sh and hand-authored packages both read execute-protocol.md. Only 03-04 modifies it. Enforcement contract table stays in execute-protocol.md.","alts":["move enforcement table to separate file"]}
{"ts":"2026-02-16T23:00:00Z","agent":"senior","task":"T1-spec-enrichment","dec":"Corrected T1 plan: library type does NOT remove Bash from Dev — removes WebFetch from Lead only","reason":"Original plan T1 said library:{dev:{remove_tools:[\"Bash\"]}} which contradicts Architecture D3 and Critique C3. Dev agents need Bash for TDD. Only non-essential tools (WebSearch, WebFetch, NotebookEdit) are valid remove_tools candidates. Actual agent YAML analysis shows Dev/Senior/Tester never have WebSearch/WebFetch in base tools, so remove_tools only applies to roles that have those tools (architect, lead, scout, critic).","alts":["Remove WebSearch from library Dev (Dev doesn't have WebSearch in YAML — no-op)","Add no overrides for library at all (misses opportunity to restrict Lead WebFetch)"]}
{"ts":"2026-02-16T23:01:00Z","agent":"senior","task":"T2-spec-enrichment","dec":"resolve-tool-permissions.sh uses BASE_ROLE for config lookup, not full ROLE","reason":"Config maps base roles only (dev, not fe-dev). Department-prefixed roles already resolved via compile-context.sh BASE_ROLE mapping (D2). Script reuses same case pattern from compile-context.sh lines 25-30 for consistency.","alts":["Map both full role and base role in config (17 extra entries, unmaintainable)","Use ROLE directly and require config to list all 26 agents (defeats D2)"]}
{"ts":"2026-02-16T23:02:00Z","agent":"senior","task":"T2-spec-enrichment","dec":"Protected tools guard is runtime enforcement in script, not just config convention","reason":"Even if someone edits tool-permissions.json to add Bash in remove_tools, the script silently drops it. Belt-and-suspenders approach: config convention (_protected_tools documentation) + runtime guard in script. Prevents accidental TDD breakage.","alts":["Config-only enforcement (fragile, human error)","Hard error on protected tool in config (too strict, blocks legitimate experimentation)"]}
{"ts":"2026-02-16T23:10:00Z","agent":"senior","task":"03-01-T1","dec":"validate-plan.sh uses positional arg not --plan flag","reason":"Single-input validator with one file path. Positional is simpler. Architecture C1 says --plan but positional is more natural for standalone validation scripts.","alts":["--plan flag per architecture C1 interface"]}
{"ts":"2026-02-16T23:11:00Z","agent":"senior","task":"03-01-T1","dec":"Header-only plan (no task lines) is valid","reason":"During step 3, plans may exist with header only before tasks are added. Rejecting header-only plans would break the workflow at planning stage.","alts":["Require at least 1 task line"]}
{"ts":"2026-02-16T23:12:00Z","agent":"senior","task":"03-01-T2","dec":"validate-gates.sh uses -s (non-empty) not -f for artifact checks","reason":"Empty artifact files should not pass gate checks. A zero-byte critique.jsonl is not valid.","alts":["Use -f only (file existence)"]}
{"ts":"2026-02-16T23:13:00Z","agent":"senior","task":"03-01-T3","dec":"generate-execution-state.sh includes --force flag for overwrite safety","reason":"Prevents accidental loss of in-progress execution state. Without --force, refuses to overwrite running or complete state.","alts":["Always overwrite","Interactive prompt (not possible in non-interactive scripts)"]}
{"ts":"2026-02-16T23:14:00Z","agent":"senior","task":"03-01-T3","dec":"Auto-detect completed steps from existing artifacts in phase dir","reason":"When generating state for a phase with existing critique.jsonl and architecture.toon, mark those steps complete. Enables correct resume without manual tracking.","alts":["All steps start as pending regardless"]}
{"ts":"2026-02-16T23:15:00Z","agent":"senior","task":"03-01-T4","dec":"Test fixtures created inline per-test via heredocs, not in shared fixtures/","reason":"Architecture R4 requires fixtures as part of test task. Inline heredocs make each test self-contained. Follows dept-gate.bats pattern.","alts":["Add to tests/fixtures/ directory","Shared setup function"]}
