{"plan":"03-*","r":"approve","tdd":"skip","cycle":1,"dt":"2026-02-16"}
{"f":"references/execute-protocol.md","ln":27,"sev":"major","issue":"Interface mismatch: execute-protocol.md calls validate-plan.sh with --plan flag but the script uses positional args. Line reads: result=$(bash ... validate-plan.sh --plan \"$plan\") but script expects: validate-plan.sh <path>. The --plan flag will be treated as the positional path argument, causing file-not-found error because the file path ends up as $2 not $1.","sug":"Change line 27 to: result=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate-plan.sh \"$plan\") -- remove the --plan flag to match the actual script interface. Alternatively, update validate-plan.sh to accept --plan flag (but that would also require updating all tests)."}
{"f":"scripts/validate-gates.sh","ln":125,"sev":"minor","issue":"Duplicated spec-check logic between test_authoring (lines 125-149) and implementation (lines 152-183) cases. The plan-scanning and spec-field checking code is identical (~20 lines).","sug":"Extract into a helper function check_plans_have_spec_field() and call from both cases. This reduces maintenance surface and follows the existing helper function pattern (check_step_skipped, check_artifact_exists)."}
{"f":"scripts/validate-gates.sh","ln":127,"sev":"nit","issue":"Underscore-prefixed variables (_gate_plans, _has_missing_spec, etc.) used in case statement body are non-standard bash convention. While not harmful in a single-execution script, they suggest function-local scope that does not exist.","sug":"Consider using descriptive names without underscore prefix or extract case bodies into functions with proper local declarations. Low priority since script works correctly."}
{"f":"scripts/validate-plan.sh","ln":9,"sev":"nit","issue":"Usage comment says 'Usage: validate-plan.sh <path-to-plan.jsonl>' (positional) which is correct for the implementation, but architecture.toon C1 interface says 'INPUT --plan {path}'. The decisions.jsonl (line 16) documents this deviation but it should be reflected in the architecture.","sug":"No code change needed. Architecture divergence is documented in decisions.jsonl. Just noting for awareness."}
{"f":"scripts/compile-context.sh","ln":166,"sev":"nit","issue":"get_tool_restrictions() RESOLVE_SCRIPT path resolution uses cd+dirname in a subshell which is correct, but the double-fallback pattern (CLAUDE_PLUGIN_ROOT -> dirname) could resolve incorrectly if compile-context.sh is called from an unexpected working directory and CLAUDE_PLUGIN_ROOT is empty.","sug":"The current implementation matches patterns used by resolve-agent-model.sh and other scripts. Acceptable as-is since CLAUDE_PLUGIN_ROOT is always set in production context, and the fallback is development-only."}
{"f":"scripts/generate-execution-state.sh","ln":132,"sev":"nit","issue":"PHASE_NUM=$((10#$PHASE)) uses base-10 forced interpretation which is correct for handling leading zeros (e.g. '03' -> 3). Good defensive coding practice.","sug":"No change needed. Noting as positive pattern."}
{"f":"references/packages/dev.toon","ln":1,"sev":"nit","issue":"All 9 reference packages are well-structured, under 3KB, contain required keywords, and follow the TOON pattern from references/departments/backend.toon. The shared preamble is consistent across all packages.","sug":"No change needed. Noting as positive observation for completeness."}
{"f":"config/tool-permissions.json","ln":1,"sev":"nit","issue":"cli-tool and library types define role entries with empty add_tools/remove_tools arrays (e.g. architect: {add_tools:[], remove_tools:[]}). These are effectively no-ops since the script handles missing role entries the same as empty arrays.","sug":"Could simplify by removing no-op entries. However, keeping them makes the intent explicit (architect was considered and deliberately left unchanged). Acceptable either way."}
