{"p":"03","n":"01","t":"Validation & Generation Script Offloading","w":1,"d":[],"xd":[],"mh":{"tr":["All 3 new scripts exit 0 on valid input and exit 1 on invalid input","Scripts use jq for JSON parsing, never grep/sed on JSON","Scripts are bash 3.2 compatible (no associative arrays)","Existing 606 regression tests still pass"],"ar":[{"p":"scripts/validate-plan.sh","pv":"file exists and is executable","c":"validates plan.jsonl structure: header keys, task keys, wave ordering, no circular deps"},{"p":"scripts/validate-gates.sh","pv":"file exists and is executable","c":"checks entry/exit gate artifacts per execute-protocol verification gate contract"},{"p":"scripts/generate-execution-state.sh","pv":"file exists and is executable","c":"generates initial .execution-state.json from plan.jsonl files in phase dir"}],"kl":[{"fr":"scripts/validate-plan.sh","to":"references/artifact-formats.md","vi":"validates against JSONL key dictionary"},{"fr":"scripts/validate-gates.sh","to":"references/execute-protocol.md","vi":"checks gate artifacts from enforcement contract table"},{"fr":"scripts/generate-execution-state.sh","to":"references/execute-protocol.md","vi":"generates state schema from Step 3 item 7"}]},"obj":"Create 3 new shell scripts that offload validation and generation work from LLM calls to deterministic bash+jq scripts. REQ-04.","sk":["commit"],"fm":["scripts/validate-plan.sh","scripts/validate-gates.sh","scripts/generate-execution-state.sh","tests/unit/validate-plan.bats","tests/unit/validate-gates.bats","tests/unit/generate-execution-state.bats"],"auto":true}
{"id":"T1","tp":"auto","a":"Create scripts/validate-plan.sh: validates plan.jsonl structure. Checks: line 1 has required header keys (p,n,t,w,d,mh,obj), lines 2+ have required task keys (id,tp,a,f,v,done), wave ordering is valid (no task depends on same-or-higher wave), no circular dependencies in d field, all file paths in f are relative. Input: path to plan.jsonl. Output: JSON {valid:bool,errors:[]}. REQ-04.","f":["scripts/validate-plan.sh"],"v":"bash scripts/validate-plan.sh tests/fixtures/valid-plan.jsonl exits 0; bash scripts/validate-plan.sh tests/fixtures/invalid-plan.jsonl exits 1 with error details","done":"Script validates plan.jsonl structure with clear error messages","spec":"FILE: scripts/validate-plan.sh. SHEBANG: #!/usr/bin/env bash. HEADER: set -euo pipefail. PATTERN: Follow scripts/dept-gate.sh structure (jq dependency check, arg parsing, validation functions, JSON output via jq -n). --- ARG PARSING: Manual positional. Usage: validate-plan.sh <path-to-plan.jsonl>. Store as PLAN_FILE=$1. If $# -lt 1 or file not found, print usage to stderr + exit 1. --- JQ DEPENDENCY CHECK: Copy pattern from scripts/detect-stack.sh lines 12-15. If jq not found, echo JSON error to stderr + exit 1. --- GLOBAL STATE: Use two parallel arrays for bash 3.2 compat: ERRORS=() to accumulate error strings. VALID=true, set to false on any error. --- FUNCTION validate_header(): Read line 1 of PLAN_FILE via head -1. Parse with jq. Check required keys exist and are correct type: p (string), n (string), t (string), w (number), d (array), mh (object), obj (string). For each missing/wrong-type key, append to ERRORS array: 'Header missing required key: {key}'. Also check optional keys if present have correct types: xd (array), sk (array), fm (array), auto (boolean). --- FUNCTION validate_tasks(): Read lines 2+ via tail -n +2. For each line, parse with jq. Check required keys: id (string matching /^T[0-9]+$/), tp (string), a (string), f (array), v (string), done (string). For missing keys: append 'Task {id}: missing required key: {key}'. For each path in f array: check it does not start with / (must be relative). If absolute: append 'Task {id}: absolute path in f: {path}'. --- FUNCTION validate_waves(): Read header line 1 w field as PLAN_WAVE. Read all tasks. For each task with d field (dependencies array): each dep is a plan ID like '03-01'. If a dep refers to the SAME plan (same p+n as header), it means task-level dep which is not supported at plan level -- skip. If dep refers to a different plan with wave >= PLAN_WAVE, append 'Plan depends on same-or-higher wave plan: {dep} (wave {dep_wave} >= {PLAN_WAVE})'. NOTE: Wave validation requires reading OTHER plan files. For 03-01 plan scope (d:[] in header), this is a no-op. Implementation: if d array is non-empty AND plans are in same phase dir, read each dep plan header to get its wave. Use dirname of PLAN_FILE to find sibling plans. --- FUNCTION validate_no_circular_deps(): Check header d field for self-reference (plan depends on itself). Extract plan ID as '{p}-{n}' from header. If plan ID appears in d array, append 'Circular dependency: plan depends on itself'. For task-level: not applicable (tasks have no d field in current schema). --- MAIN FLOW: (1) validate_header, (2) validate_tasks, (3) validate_waves, (4) validate_no_circular_deps. --- OUTPUT: Use jq -n to build JSON. If ERRORS is empty: {\"valid\":true,\"errors\":[]} + exit 0. If ERRORS has items: build errors array from ERRORS, output {\"valid\":false,\"errors\":[...]} + exit 1. Build errors array by joining ERRORS with jq --arg for each, or printf them as JSON array string. Pattern: printf '%s\\n' \"${ERRORS[@]}\" | jq -R . | jq -s '{valid:false,errors:.}'. --- EDGE CASES: Empty file -> error 'Empty plan file'. File with only header (no tasks) -> valid (header-only plan is allowed during planning step). Non-JSON line -> error 'Line {N}: invalid JSON'. Binary/non-text file -> jq will fail, catch with || and report error. --- BASH 3.2: No associative arrays. Use indexed arrays ERRORS=(). No declare -A. No ${!arr[@]} on associative. --- EXIT CODES: 0 = valid plan, 1 = invalid plan or usage error.","ts":"TEST FILE: tests/unit/validate-plan.bats. FRAMEWORK: BATS with bats-support, bats-assert, bats-file. SETUP: load common.bash + fixtures.bash. mk_test_workdir. Set SUT=$SCRIPTS_DIR/validate-plan.sh. --- FIXTURES: Create inline in setup or per-test using heredocs in TEST_WORKDIR. Do NOT modify tests/fixtures/ directory (those are shared fixtures). --- 8 TEST CASES: (1) 'valid plan passes validation' - Create valid plan.jsonl with proper header (p,n,t,w,d,mh,obj) + 2 tasks with all required keys. run bash $SUT $plan_file. assert_success. Parse output with jq, assert .valid==true, .errors length 0. (2) 'missing header key p fails' - Create plan.jsonl header missing p key. run bash $SUT $file. assert_failure. assert output contains 'missing required key'. (3) 'missing task key id fails' - Create plan with valid header but task line missing id. run bash $SUT $file. assert_failure. Output JSON .errors should mention 'missing required key: id'. (4) 'circular self-dependency detected' - Create plan header with d array containing own plan ID (e.g. p=03,n=01,d=[\"03-01\"]). run bash $SUT $file. assert_failure. Output should contain 'Circular dependency'. (5) 'absolute path in task f field fails' - Create task with f:[\"/usr/local/bin/foo\"]. run bash $SUT $file. assert_failure. Output should contain 'absolute path'. (6) 'empty file fails' - Create empty file. run bash $SUT $file. assert_failure. Output should contain error. (7) 'non-JSON content fails' - Create file with plain text. run bash $SUT $file. assert_failure. (8) 'header-only plan (no tasks) passes' - Create file with only valid header line. run bash $SUT $file. assert_success. Output .valid==true."}
{"id":"T2","tp":"auto","a":"Create scripts/validate-gates.sh: validates verification gate artifacts for a given step. Input: --step {step_name} --phase-dir {path}. Checks entry artifact existence per execute-protocol.md enforcement contract table. Also checks skip status in .execution-state.json. Output: JSON {gate:pass|fail,step:str,missing:[]}. Covers all 10 steps. REQ-04.","f":["scripts/validate-gates.sh"],"v":"Script correctly identifies missing artifacts for each step; correctly handles skipped steps","done":"Script validates all 10 entry gates with correct artifact paths","spec":"FILE: scripts/validate-gates.sh. SHEBANG: #!/usr/bin/env bash. HEADER: set -euo pipefail. PATTERN: Follow scripts/dept-gate.sh structure (arg parsing with while/case, validation, function dispatch). --- JQ DEPENDENCY CHECK: Same pattern as detect-stack.sh lines 12-15. --- ARG PARSING: while [ $# -gt 0 ]; case $1 in --step) STEP=$2; shift 2;; --phase-dir) PHASE_DIR=$2; shift 2;; *) echo 'Unknown flag: $1' >&2; exit 1;; esac; done. Validate both required: if [ -z $STEP ] || [ -z $PHASE_DIR ]; usage to stderr; exit 1. --- STATE FILE: STATE_FILE=$PHASE_DIR/.execution-state.json. --- HELPER FUNCTION check_step_skipped(step_name): If STATE_FILE does not exist, return 1 (not skipped). Otherwise: jq -r \".steps.${step_name}.status\" $STATE_FILE. If result is 'skipped', return 0. Else return 1. --- HELPER FUNCTION check_artifact_exists(artifact_path): Test -f on the path. If file exists and is non-empty ([ -s ]), return 0. Else return 1. --- HELPER FUNCTION check_glob_exists(pattern): Use ls $pattern 2>/dev/null | head -1. If result non-empty, return 0. Else return 1. --- LOOKUP TABLE (case statement per D7, bash 3.2 compatible): FUNCTION get_gate_check(): case $STEP in critique) ENTRY_DESC='Phase dir exists'; check: [ -d $PHASE_DIR ] ;; architecture) ENTRY_DESC='critique.jsonl OR step 1 skipped'; check: check_artifact_exists $PHASE_DIR/critique.jsonl OR check_step_skipped critique ;; planning) ENTRY_DESC='architecture.toon OR step 2 skipped'; check: check_artifact_exists $PHASE_DIR/architecture.toon OR check_step_skipped architecture ;; design_review) ENTRY_DESC='*.plan.jsonl exists'; check: check_glob_exists \"$PHASE_DIR/*.plan.jsonl\" ;; test_authoring) ENTRY_DESC='enriched plan.jsonl with spec fields'; check: For each *.plan.jsonl, verify tasks have spec field via jq: tail -n +2 $plan | jq -e '.spec // empty' >/dev/null 2>&1. If any plan has tasks without spec, gate fails. ;; implementation) ENTRY_DESC='enriched plan.jsonl + test-plan.jsonl (if step 5 ran)'; check: Same as test_authoring spec check. Additionally if step test_authoring status is 'complete' in state, check test-plan.jsonl exists. If test_authoring is 'skipped', test-plan.jsonl not required. ;; code_review) ENTRY_DESC='summary.jsonl for each plan'; check: For each *.plan.jsonl, derive plan_id from header (p+n), check ${plan_id}.summary.jsonl exists. ;; qa) ENTRY_DESC='code-review.jsonl with r:approve'; check: check_artifact_exists $PHASE_DIR/code-review.jsonl AND jq -e '.r == \"approve\"' on line 1. ;; security) ENTRY_DESC='verification.jsonl OR step 8 skipped'; check: check_artifact_exists $PHASE_DIR/verification.jsonl OR check_step_skipped qa ;; signoff) ENTRY_DESC='security-audit.jsonl OR step 9 skipped + code-review approved'; check: (check_artifact_exists $PHASE_DIR/security-audit.jsonl OR check_step_skipped security) AND (check code-review.jsonl line 1 has r:approve). ;; *) echo 'ERROR: Unknown step: $STEP' >&2; exit 1 ;; esac --- MAIN FLOW: (1) Validate args. (2) Run get_gate_check which sets GATE_RESULT (pass/fail) and MISSING array. (3) Output JSON. --- OUTPUT: Use jq -n. On pass: {\"gate\":\"pass\",\"step\":\"$STEP\",\"missing\":[]} + exit 0. On fail: Build missing array from MISSING parallel array. {\"gate\":\"fail\",\"step\":\"$STEP\",\"missing\":[...]} + exit 1. Build missing with: printf '%s\\n' \"${MISSING[@]}\" | jq -R . | jq -s --arg g fail --arg s $STEP '{gate:$g,step:$s,missing:.}'. --- VALID STEP NAMES (10 total): critique, architecture, planning, design_review, test_authoring, implementation, code_review, qa, security, signoff. --- BASH 3.2: No associative arrays. Case statement is the lookup table. MISSING=() indexed array. --- EXIT CODES: 0 = gate passes, 1 = gate fails or usage error.","ts":"TEST FILE: tests/unit/validate-gates.bats. FRAMEWORK: BATS with bats-support, bats-assert, bats-file. SETUP: load common.bash + fixtures.bash. mk_test_workdir. SUT=$SCRIPTS_DIR/validate-gates.sh. Create PHASE_DIR=$TEST_WORKDIR/phase-test; mkdir -p $PHASE_DIR. --- FIXTURES: Create inline per-test. Build .execution-state.json with jq -n for skip scenarios. Create artifact files (critique.jsonl, architecture.toon, plan.jsonl, etc.) as needed per test. --- 10 TEST CASES: (1) 'critique gate passes when phase dir exists' - mkdir -p $PHASE_DIR. run bash $SUT --step critique --phase-dir $PHASE_DIR. assert_success. Output .gate==\"pass\". (2) 'architecture gate passes with critique.jsonl' - echo '{\"id\":\"C1\"}' > $PHASE_DIR/critique.jsonl. run bash $SUT --step architecture --phase-dir $PHASE_DIR. assert_success. (3) 'architecture gate passes when critique skipped' - Create .execution-state.json with steps.critique.status=skipped. No critique.jsonl. run bash $SUT --step architecture --phase-dir $PHASE_DIR. assert_success. (4) 'architecture gate fails without critique.jsonl or skip' - No critique.jsonl, no state file. run bash $SUT --step architecture --phase-dir $PHASE_DIR. assert_failure. Output .missing should list critique.jsonl. (5) 'design_review gate passes with plan.jsonl' - Create 01-01.plan.jsonl. run bash $SUT --step design_review --phase-dir $PHASE_DIR. assert_success. (6) 'design_review gate fails without plan files' - Empty phase dir (no plan.jsonl). run bash $SUT --step design_review --phase-dir $PHASE_DIR. assert_failure. (7) 'qa gate passes with approved code-review' - echo '{\"r\":\"approve\"}' > $PHASE_DIR/code-review.jsonl. run bash $SUT --step qa --phase-dir $PHASE_DIR. assert_success. (8) 'qa gate fails with changes_requested code-review' - echo '{\"r\":\"changes_requested\"}' > $PHASE_DIR/code-review.jsonl. run bash $SUT --step qa --phase-dir $PHASE_DIR. assert_failure. (9) 'unknown step name exits with error' - run bash $SUT --step nonexistent --phase-dir $PHASE_DIR. assert_failure. assert_output --partial 'Unknown step'. (10) 'security gate passes when qa step skipped' - Create .execution-state.json with steps.qa.status=skipped. No verification.jsonl. run bash $SUT --step security --phase-dir $PHASE_DIR. assert_success."}
{"id":"T3","tp":"auto","a":"Create scripts/generate-execution-state.sh: generates initial .execution-state.json from plan.jsonl files in a phase directory. Input: --phase-dir {path} --phase {N}. Scans *.plan.jsonl, extracts plan metadata (id, title, wave), builds the full state schema from execute-protocol.md Step 3 item 7. Output: writes .execution-state.json to phase dir. REQ-04.","f":["scripts/generate-execution-state.sh"],"v":"Generated state.json has correct schema with all 10 step entries, plan list matches *.plan.jsonl files","done":"Script generates valid execution state JSON from phase plan files","spec":"FILE: scripts/generate-execution-state.sh. SHEBANG: #!/usr/bin/env bash. HEADER: set -euo pipefail. PATTERN: Follow scripts/dept-status.sh structure (arg parsing, jq JSON construction, atomic write via temp+mv). --- JQ DEPENDENCY CHECK: Same pattern as detect-stack.sh lines 12-15. --- ARG PARSING: while [ $# -gt 0 ]; case $1 in --phase-dir) PHASE_DIR=$2; shift 2;; --phase) PHASE=$2; shift 2;; --force) FORCE=true; shift;; *) echo 'Unknown flag: $1' >&2; exit 1;; esac; done. Validate both required. If PHASE_DIR does not exist ([ ! -d $PHASE_DIR ]), error + exit 1. --- CONSTANTS: OUTPUT_FILE=$PHASE_DIR/.execution-state.json. STEP_NAMES='critique architecture planning design_review test_authoring implementation code_review qa security signoff' (space-separated, bash 3.2 safe). --- RESUME CHECK: If OUTPUT_FILE already exists AND FORCE is not true, check its status field. If status is 'running', print 'Existing state found (status: running). Use --force to regenerate.' to stderr + exit 1. If status is 'complete', print 'Phase already complete.' to stderr + exit 1. This prevents accidental overwrite of in-progress state. --- EXTRACT PHASE_NAME: Derive from PHASE_DIR basename. Example: /path/to/03-token-optimization -> phase_name='token-optimization'. Use: PHASE_NAME=$(basename $PHASE_DIR | sed 's/^[0-9]*-//'). --- SCAN PLANS: PLAN_FILES=$(ls $PHASE_DIR/*.plan.jsonl 2>/dev/null). If empty, echo 'No plan.jsonl files found in $PHASE_DIR' to stderr + exit 1. --- BUILD PLANS ARRAY: For each plan file, read line 1 (header) with head -1 | jq. Extract: id as '{p}-{n}' (e.g. '03-01'), title from t field, wave from w field. Determine status: if corresponding ${id}.summary.jsonl exists in PHASE_DIR with s:complete, status='complete'. Else status='pending'. Build JSON array of plan objects. Use a temp file to accumulate: PLANS_JSON='[]'. For each plan: PLANS_JSON=$(echo $PLANS_JSON | jq --arg id $id --arg title $title --argjson wave $wave --arg status $status '. + [{id:$id,title:$title,wave:$wave,status:$status}]'). --- COMPUTE WAVES: TOTAL_WAVES=$(echo $PLANS_JSON | jq '[.[].wave] | max'). CURRENT_WAVE: Find lowest wave with status!=complete. If all complete, use max wave. --- BUILD STEPS OBJECT: Create JSON object with all 10 steps. Each step: {status:'pending',started_at:'',completed_at:'',artifact:'',reason:''}. For steps that can be detected as already done (check artifact existence): critique -> if critique.jsonl exists, status='complete'. architecture -> if architecture.toon exists, status='complete'. planning -> will be set to 'complete' since we are generating state. Build with jq. Start with template of all 10 steps as pending, then overlay detected completions. --- ASSEMBLE FULL STATE: Use jq -n to build the complete schema matching execute-protocol.md Step 3 item 7: {phase: $PHASE (as number), phase_name: $PHASE_NAME, status: 'running', started_at: $(date -u +%Y-%m-%dT%H:%M:%SZ), step: 'planning', wave: $CURRENT_WAVE, total_waves: $TOTAL_WAVES, plans: $PLANS_JSON, steps: $STEPS_JSON}. --- ATOMIC WRITE: Write to temp file TEMP=$OUTPUT_FILE.tmp.$$, then mv $TEMP $OUTPUT_FILE. Pattern from scripts/dept-status.sh line 116-128. --- OUTPUT: Print path to generated file on stdout: echo $OUTPUT_FILE. --- BASH 3.2: No associative arrays. Build JSON incrementally with jq. Use indexed arrays or temp files for plan iteration. --- EXIT CODES: 0 = success, 1 = error (missing args, no plans, existing state without --force).","ts":"TEST FILE: tests/unit/generate-execution-state.bats. FRAMEWORK: BATS with bats-support, bats-assert, bats-file. SETUP: load common.bash + fixtures.bash. mk_test_workdir. SUT=$SCRIPTS_DIR/generate-execution-state.sh. --- FIXTURES: Create plan.jsonl files inline per-test using heredocs. Create PHASE_DIR=$TEST_WORKDIR/03-test-phase; mkdir -p $PHASE_DIR. --- 8 TEST CASES: (1) 'generates state from single plan' - Create $PHASE_DIR/03-01.plan.jsonl with valid header (p=03,n=01,t=Test,w=1,d=[],mh={},obj=test). run bash $SUT --phase-dir $PHASE_DIR --phase 03. assert_success. Verify .execution-state.json exists. Parse with jq: .phase==3, .status=='running', .step=='planning', .plans length 1, .plans[0].id=='03-01', .plans[0].status=='pending'. Verify all 10 steps exist in .steps object. (2) 'generates state from multiple plans' - Create 03-01.plan.jsonl (w=1) and 03-02.plan.jsonl (w=1) and 03-03.plan.jsonl (w=2). run bash $SUT --phase-dir $PHASE_DIR --phase 03. assert_success. Parse: .plans length 3, .total_waves==2, .wave==1. (3) 'detects completed plans from summary.jsonl' - Create 03-01.plan.jsonl + 03-01.summary.jsonl with {s:'complete'}. Create 03-02.plan.jsonl (no summary). run bash $SUT --phase-dir $PHASE_DIR --phase 03. assert_success. .plans[0].status=='complete' (the one with summary), .plans[1].status=='pending'. (4) 'refuses to overwrite existing running state' - Create .execution-state.json with status:running. run bash $SUT --phase-dir $PHASE_DIR --phase 03. assert_failure. assert_output --partial 'Existing state found'. (5) '--force overwrites existing state' - Create .execution-state.json with status:running + a plan.jsonl. run bash $SUT --phase-dir $PHASE_DIR --phase 03 --force. assert_success. Verify new state generated. (6) 'fails with no plan files' - Empty PHASE_DIR. run bash $SUT --phase-dir $PHASE_DIR --phase 03. assert_failure. assert_output --partial 'No plan.jsonl files'. (7) 'detects completed critique step from artifact' - Create critique.jsonl in PHASE_DIR + a plan.jsonl. run bash $SUT --phase-dir $PHASE_DIR --phase 03. assert_success. Parse: .steps.critique.status=='complete'. (8) 'phase_name extracted from directory name' - PHASE_DIR=$TEST_WORKDIR/03-token-optimization. mkdir -p $PHASE_DIR. Create plan.jsonl there. run bash $SUT --phase-dir $PHASE_DIR --phase 03. assert_success. Parse: .phase_name=='token-optimization'."}
{"id":"T4","tp":"auto","a":"Create BATS test suites for all 3 scripts: tests/unit/validate-plan.bats (8+ tests: valid plan, missing header keys, missing task keys, circular deps, invalid wave ordering, empty file, non-jsonl input, multiple plans), tests/unit/validate-gates.bats (8+ tests: each step gate pass/fail, skipped step handling, missing state file), tests/unit/generate-execution-state.bats (6+ tests: single plan, multiple plans, wave ordering, resume state, empty dir, existing state).","f":["tests/unit/validate-plan.bats","tests/unit/validate-gates.bats","tests/unit/generate-execution-state.bats"],"v":"All tests pass with bats tests/unit/validate-plan.bats && bats tests/unit/validate-gates.bats && bats tests/unit/generate-execution-state.bats","done":"22+ BATS tests covering all 3 new scripts, all green","spec":"NOTE: This task is the test implementation. The ts fields on T1, T2, T3 define the exact test cases. This task implements those test specs as actual BATS files. --- FILE 1: tests/unit/validate-plan.bats. Structure: setup() loads common.bash + fixtures.bash, calls mk_test_workdir, sets SUT=$SCRIPTS_DIR/validate-plan.sh. Each @test block creates its own fixture files in $TEST_WORKDIR using heredocs. Assertions use assert_success/assert_failure from bats-assert and jq to parse JSON output. 8 tests as specified in T1 ts field. HELPER FUNCTION: mk_valid_plan() creates a valid plan.jsonl in $TEST_WORKDIR with proper header + 2 tasks. Used by tests that need a baseline valid plan. --- FILE 2: tests/unit/validate-gates.bats. Structure: setup() loads common.bash + fixtures.bash, calls mk_test_workdir, sets SUT=$SCRIPTS_DIR/validate-gates.sh, creates PHASE_DIR=$TEST_WORKDIR/phase-test; mkdir -p $PHASE_DIR. Each @test creates required artifacts and .execution-state.json as needed. HELPER FUNCTION: mk_exec_state_with_skip(step_name) creates .execution-state.json with that step's status set to 'skipped'. Used for skip-condition tests. 10 tests as specified in T2 ts field. --- FILE 3: tests/unit/generate-execution-state.bats. Structure: setup() loads common.bash + fixtures.bash, calls mk_test_workdir, sets SUT=$SCRIPTS_DIR/generate-execution-state.sh. Creates PHASE_DIR per test. HELPER FUNCTION: mk_plan_header(phase, num, title, wave) creates a valid plan.jsonl header line. Used across tests. 8 tests as specified in T3 ts field. --- TOTAL: 26 test cases. PATTERN: Follow tests/unit/dept-gate.bats for structure (setup pattern, helper functions, assertion style). All test fixtures created via heredocs in TEST_WORKDIR, never modify shared fixtures/. --- IMPORTANT: All 3 test files must work with the scripts created in T1, T2, T3. Tests should be written to match the exact script interfaces defined in those specs.","ts":""}
