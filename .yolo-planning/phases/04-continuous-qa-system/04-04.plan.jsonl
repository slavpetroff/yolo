{"p":"04","n":"04","t":"QA gate JSONL output schemas and reporting","w":2,"d":["04-01","04-03"],"mh":{"tr":["Gate result JSONL is machine-parseable by jq and follows abbreviated key conventions","Each gate level produces distinct JSONL format per artifact-formats.md patterns","Gate results aggregate into phase-level qa-gates.jsonl for dashboard consumption"],"ar":[{"p":"references/artifact-formats.md","pv":"qa-gate-result section exists","c":"Contains JSONL schemas for post-task, post-plan, and post-phase gate results with abbreviated keys"}],"kl":[{"fr":"artifact-formats.md qa-gate schemas","to":"references/qa-output-patterns.md","vi":"JSONL fields map to human-readable output templates from 04-01"},{"fr":"artifact-formats.md qa-gate schemas","to":"references/naming-conventions.md","vi":"File naming follows existing artifact naming patterns"}]}}
{"id":"T1","tp":"auto","a":"Define post-task gate result JSONL schema in references/artifact-formats.md: abbreviated keys (gl=gate_level, r=result, tst=tests, dur=duration_ms, task=task_id, plan=plan_id). Add to Key Dictionary section following existing patterns.","f":["references/artifact-formats.md"],"v":"Post-task gate schema section exists with key table matching existing format","done":"Post-task gate schema documented","spec":"FILE: references/artifact-formats.md (MODIFY). Insert a new section after the existing 'Gaps (gaps.jsonl)' section (after line ~230 area) and before 'Manual QA' section. Title: '### QA Gate Result: Post-Task (.qa-gate-results.jsonl, appended per gate invocation)'. Architecture D3: gate results stored in {phase-dir}/.qa-gate-results.jsonl as append-mode JSONL.\n\nAdd a key table in the EXACT format used by existing sections (e.g., Summary, Verification). Columns: Key | Full Name | Type | Example.\n\nPost-task schema keys:\n| Key | Full Name | Type | Example |\n|-----|-----------|------|--------|\n| `gl` | gate_level | string | \"post-task\" |\n| `r` | result | string | \"PASS\"\\|\"FAIL\"\\|\"WARN\" |\n| `plan` | plan_id | string | \"04-03\" |\n| `task` | task_id | string | \"T1\" |\n| `tst` | tests | object | {\"ps\":12,\"fl\":0} |\n| `dur` | duration_ms | number | 2450 |\n| `f` | files_tested | string[] | [\"tests/unit/resolve-qa-config.bats\"] |\n| `dt` | datetime | string | \"2026-02-17T14:30:00Z\" |\n\nAdd a prose note below the table: 'The tst object uses ps (passed) and fl (failed) sub-keys matching the Verification schema pattern. WARN result indicates infrastructure missing (no bats, no matching tests). Appended to {phase-dir}/.qa-gate-results.jsonl by format-gate-result.sh.'\n\nPattern reference: existing Key Dictionary tables in artifact-formats.md (lines 17-50 for Plan Header/Task, lines 53-69 for Summary). Follow identical Markdown table formatting."}
{"id":"T2","tp":"auto","a":"Define post-plan gate result JSONL schema in references/artifact-formats.md: keys (gl, r, plan, tc=tasks_completed, tt=tasks_total, tst, dur, gates=sub_gate_results). Append after post-task section.","f":["references/artifact-formats.md"],"td":["T1"],"v":"Post-plan gate schema section exists with aggregation fields","done":"Post-plan gate schema documented","spec":"FILE: references/artifact-formats.md (MODIFY). Insert immediately after the post-task gate section added in T1. Title: '### QA Gate Result: Post-Plan (.qa-gate-results.jsonl, appended per gate invocation)'\n\nPost-plan schema keys:\n| Key | Full Name | Type | Example |\n|-----|-----------|------|--------|\n| `gl` | gate_level | string | \"post-plan\" |\n| `r` | result | string | \"PASS\"\\|\"FAIL\"\\|\"WARN\" |\n| `plan` | plan_id | string | \"04-03\" |\n| `tc` | tasks_completed | number | 5 |\n| `tt` | tasks_total | number | 5 |\n| `tst` | tests | object | {\"ps\":45,\"fl\":2} |\n| `dur` | duration_ms | number | 28500 |\n| `mh` | must_have_coverage | object | {\"ps\":3,\"fl\":0,\"tt\":3} |\n| `dt` | datetime | string | \"2026-02-17T14:35:00Z\" |\n\nProse note: 'Post-plan gate runs full test suite (not scoped). The mh field verifies must_have coverage from plan header: ps=passed, fl=failed, tt=total must_have checks. tc/tt fields match Summary schema pattern. Appended to same .qa-gate-results.jsonl file as post-task results.'"}
{"id":"T3","tp":"auto","a":"Define post-phase gate result JSONL schema in references/artifact-formats.md: keys (gl, r, ph=phase, plans=plan_results, tst, dur, esc=escalations). Add qa-gates.jsonl to Phase Directory Structure and naming-conventions.md.","f":["references/artifact-formats.md","references/naming-conventions.md"],"td":["T2"],"v":"Post-phase schema documented, qa-gates.jsonl in directory structure and naming conventions","done":"Post-phase gate schema and naming committed","spec":"TWO FILES to modify.\n\nFILE 1: references/artifact-formats.md (MODIFY). Insert after post-plan gate section from T2. Title: '### QA Gate Result: Post-Phase (.qa-gate-results.jsonl, appended per gate invocation)'\n\nPost-phase schema keys:\n| Key | Full Name | Type | Example |\n|-----|-----------|------|--------|\n| `gl` | gate_level | string | \"post-phase\" |\n| `r` | result | string | \"PASS\"\\|\"FAIL\"\\|\"WARN\" |\n| `ph` | phase | string | \"04\" |\n| `plans` | plan_results | object[] | [{\"plan\":\"04-03\",\"r\":\"PASS\"},{\"plan\":\"04-04\",\"r\":\"PASS\"}] |\n| `tst` | tests | object | {\"ps\":1919,\"fl\":0} |\n| `dur` | duration_ms | number | 185000 |\n| `esc` | escalations | number | 0 |\n| `gates` | gate_check | object | {\"ps\":11,\"fl\":0,\"tt\":11} |\n| `dt` | datetime | string | \"2026-02-17T15:00:00Z\" |\n\nProse note: 'Post-phase gate is the most comprehensive -- runs full test suite, validates all plan gates passed, checks all workflow steps complete via validate-gates.sh. The plans array summarizes per-plan gate results. The gates field aggregates validate-gates.sh step checks (ps=passed, fl=failed, tt=total). esc counts escalation events during the phase. This is a fast automated pre-check before QA agent spawn (architecture C11).'\n\nAlso in artifact-formats.md: Update the Phase Directory Structure section (lines ~333-357). Add this line after 'gaps.jsonl':\n  '  +-- .qa-gate-results.jsonl    # Gate results (append-only, committed)'\nNote the dot-prefix: this is a runtime artifact like .execution-state.json.\n\nFILE 2: references/naming-conventions.md (MODIFY). In Section 1 'File Naming Patterns' table, add a new row:\n| `.qa-gate-results.jsonl` | (dot-prefix, append-only) | Phase directory |\n\nIn Section 6 'Other Artifact Key Conventions', add a new subsection:\n### QA Gate Results (.qa-gate-results.jsonl)\n\nThree schemas per gate level: post-task `{gl, r, plan, task, tst, dur, f, dt}`, post-plan `{gl, r, plan, tc, tt, tst, dur, mh, dt}`, post-phase `{gl, r, ph, plans, tst, dur, esc, gates, dt}`.\nValid `gl`: `\"post-task\"`, `\"post-plan\"`, `\"post-phase\"`.\nValid `r`: `\"PASS\"`, `\"FAIL\"`, `\"WARN\"`."}
{"id":"T4","tp":"auto","a":"Create scripts/format-gate-result.sh that takes gate level (post-task|post-plan|post-phase) and raw JSON input, outputs properly formatted JSONL line using abbreviated keys. Uses jq for transformation.","f":["scripts/format-gate-result.sh"],"td":["T3"],"v":"Script produces valid JSONL for all three gate levels, set -euo pipefail","done":"Gate result formatter committed","spec":"FILE: scripts/format-gate-result.sh (CREATE). Architecture D3: used by all three gate scripts for consistent JSONL output to .qa-gate-results.jsonl.\n\nShebang and flags: #!/usr/bin/env bash, set -euo pipefail.\n\nUsage: format-gate-result.sh <gate-level> [<raw-json>]\n  gate-level: post-task | post-plan | post-phase (required)\n  raw-json: JSON string with gate result data (optional -- if omitted, reads from stdin)\n  Output: stdout = single JSONL line with abbreviated keys per artifact-formats.md schemas\n  Exit 0 on success, exit 1 on invalid gate level or invalid JSON input\n\nPattern reference: scripts/resolve-agent-model.sh (argument validation), scripts/git-commit-serialized.sh (header comment style).\n\njq dependency check: standard pattern.\n\nArgument validation:\n  - First arg must be one of: post-task, post-plan, post-phase. Reject with 'Invalid gate level' to stderr.\n  - If second arg provided, use it as JSON input. If not, read from stdin: INPUT=\"${2:-$(cat)}\".\n  - Validate input is valid JSON: echo \"$INPUT\" | jq empty 2>/dev/null || { echo 'Invalid JSON input' >&2; exit 1; }\n\nTransformation logic per gate level (all add dt field with current ISO8601 timestamp):\n\npost-task:\n  echo \"$INPUT\" | jq --arg gl \"post-task\" --arg dt \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" '{\n    gl: $gl,\n    r: (.result // .r // \"WARN\"),\n    plan: (.plan_id // .plan // \"unknown\"),\n    task: (.task_id // .task // \"unknown\"),\n    tst: (.tests // .tst // {ps:0, fl:0}),\n    dur: (.duration_ms // .dur // 0),\n    f: (.files_tested // .f // []),\n    dt: $dt\n  }'\n\npost-plan:\n  echo \"$INPUT\" | jq --arg gl \"post-plan\" --arg dt \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" '{\n    gl: $gl,\n    r: (.result // .r // \"WARN\"),\n    plan: (.plan_id // .plan // \"unknown\"),\n    tc: (.tasks_completed // .tc // 0),\n    tt: (.tasks_total // .tt // 0),\n    tst: (.tests // .tst // {ps:0, fl:0}),\n    dur: (.duration_ms // .dur // 0),\n    mh: (.must_have_coverage // .mh // {ps:0, fl:0, tt:0}),\n    dt: $dt\n  }'\n\npost-phase:\n  echo \"$INPUT\" | jq --arg gl \"post-phase\" --arg dt \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" '{\n    gl: $gl,\n    r: (.result // .r // \"WARN\"),\n    ph: (.phase // .ph // \"unknown\"),\n    plans: (.plan_results // .plans // []),\n    tst: (.tests // .tst // {ps:0, fl:0}),\n    dur: (.duration_ms // .dur // 0),\n    esc: (.escalations // .esc // 0),\n    gates: (.gate_check // .gates // {ps:0, fl:0, tt:0}),\n    dt: $dt\n  }'\n\nThe jq expressions accept BOTH full-name keys (result, plan_id, etc.) and abbreviated keys (r, plan, etc.) via // fallback. This allows callers to use whichever is convenient.\n\nOutput must be exactly one JSONL line (jq -c flag implied by default jq output with no newlines in values). Verify: output | jq empty succeeds.\n\nMake executable: chmod +x.","ts":"FILE: tests/format-gate-result.bats (CREATE). Place in tests/ root. Framework: bats with test_helper/common, test_helper/fixtures.\n\nsetup(): load helpers, mk_test_workdir, set SUT=$SCRIPTS_DIR/format-gate-result.sh.\n\nTest cases (7 minimum):\n\n1. 'formats post-task result with abbreviated keys' -- Run: echo '{\"result\":\"PASS\",\"plan_id\":\"04-03\",\"task_id\":\"T1\",\"tests\":{\"ps\":5,\"fl\":0},\"duration_ms\":1200,\"files_tested\":[\"tests/foo.bats\"]}' | bash $SUT post-task. Assert output is valid JSON with gl='post-task', r='PASS', plan='04-03', task='T1'. Validate with jq -e '.gl == \"post-task\" and .r == \"PASS\"'.\n\n2. 'formats post-plan result with aggregation fields' -- Provide post-plan JSON input with tasks_completed, tasks_total, must_have_coverage. Assert output has tc, tt, mh fields.\n\n3. 'formats post-phase result with escalations and gate checks' -- Provide post-phase JSON input with phase, plan_results, escalations. Assert output has ph, plans, esc, gates fields.\n\n4. 'rejects invalid gate level' -- Run: bash $SUT invalid-level '{\"r\":\"PASS\"}'. Assert exit 1 and stderr contains 'Invalid gate level'.\n\n5. 'rejects invalid JSON input' -- Run: echo 'not json' | bash $SUT post-task. Assert exit 1 and stderr contains 'Invalid JSON'.\n\n6. 'adds dt timestamp to output' -- Run any valid gate level. Assert output has dt field matching ISO8601 pattern: jq -e '.dt | test(\"^[0-9]{4}-[0-9]{2}-[0-9]{2}T\")' output.\n\n7. 'accepts abbreviated keys in input' -- Run: echo '{\"r\":\"FAIL\",\"plan\":\"04-03\",\"task\":\"T2\",\"tst\":{\"ps\":3,\"fl\":1},\"dur\":500}' | bash $SUT post-task. Assert output preserves abbreviated values correctly."}
{"id":"T5","tp":"auto","a":"Write bats tests for format-gate-result.sh: test each gate level output format, test invalid gate level rejected, test output is valid JSONL parseable by jq. Verify abbreviated keys match artifact-formats.md definitions.","f":["tests/format-gate-result.bats"],"td":["T4"],"v":"All bats tests pass, covers all three levels plus error case","done":"Gate result formatter tests committed","spec":"NOTE: T5 is the implementation of the test file specified in T4's ts field. The test spec in T4.ts IS the spec for this task. Create tests/format-gate-result.bats exactly as described in T4.ts. Use the T4 ts field as the authoritative spec. Ensure all 7 test cases are implemented. Run 'bats tests/format-gate-result.bats' to verify all pass."}
