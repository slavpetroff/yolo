{"p":"04","n":"04","t":"QA gate JSONL output schemas and reporting","w":2,"d":["04-01","04-03"],"mh":{"tr":["Gate result JSONL is machine-parseable by jq and follows abbreviated key conventions","Each gate level produces distinct JSONL format per artifact-formats.md patterns","Gate results aggregate into phase-level qa-gates.jsonl for dashboard consumption"],"ar":[{"p":"references/artifact-formats.md","pv":"qa-gate-result section exists","c":"Contains JSONL schemas for post-task, post-plan, and post-phase gate results with abbreviated keys"}],"kl":[{"fr":"artifact-formats.md qa-gate schemas","to":"references/qa-output-patterns.md","vi":"JSONL fields map to human-readable output templates from 04-01"},{"fr":"artifact-formats.md qa-gate schemas","to":"references/naming-conventions.md","vi":"File naming follows existing artifact naming patterns"}]}}
{"id":"T1","tp":"auto","a":"Define post-task gate result JSONL schema in references/artifact-formats.md: abbreviated keys (gl=gate_level, r=result, tst=tests, dur=duration_ms, task=task_id, plan=plan_id). Add to Key Dictionary section following existing patterns.","f":["references/artifact-formats.md"],"v":"Post-task gate schema section exists with key table matching existing format","done":"Post-task gate schema documented","spec":"FILE: references/artifact-formats.md (MODIFY). Insert a new section after the existing Gaps (gaps.jsonl) section (after line ~230) and before Manual QA section. Title: ### QA Gate Result: Post-Task (.qa-gate-results.jsonl, appended per gate invocation). Architecture D3: gate results stored in {phase-dir}/.qa-gate-results.jsonl as append-mode JSONL. Add a key table in the EXACT format used by existing sections (e.g., Summary, Verification). Columns: Key | Full Name | Type | Example. Post-task schema keys: gl (gate_level, string, \"post-task\"), r (result, string, \"PASS\"|\"FAIL\"|\"WARN\"), plan (plan_id, string, \"04-03\"), task (task_id, string, \"T1\"), tst (tests, object, {\"ps\":12,\"fl\":0}), dur (duration_ms, number, 2450), f (files_tested, string[], [\"tests/unit/resolve-qa-config.bats\"]), dt (datetime, string, \"2026-02-17T14:30:00Z\"). Add prose note below table: The tst object uses ps (passed) and fl (failed) sub-keys matching the Verification schema pattern. WARN result indicates infrastructure missing (no bats, no matching tests). Appended to {phase-dir}/.qa-gate-results.jsonl by format-gate-result.sh. Pattern reference: existing Key Dictionary tables in artifact-formats.md (lines 17-50 for Plan Header/Task, lines 53-69 for Summary). Follow identical Markdown table formatting."}
{"id":"T2","tp":"auto","a":"Define post-plan gate result JSONL schema in references/artifact-formats.md: keys (gl, r, plan, tc=tasks_completed, tt=tasks_total, tst, dur, gates=sub_gate_results). Append after post-task section.","f":["references/artifact-formats.md"],"td":["T1"],"v":"Post-plan gate schema section exists with aggregation fields","done":"Post-plan gate schema documented","spec":"FILE: references/artifact-formats.md (MODIFY). Insert immediately after the post-task gate section added in T1. Title: ### QA Gate Result: Post-Plan (.qa-gate-results.jsonl, appended per gate invocation). Post-plan schema keys: gl (gate_level, string, \"post-plan\"), r (result, string, \"PASS\"|\"FAIL\"|\"WARN\"), plan (plan_id, string, \"04-03\"), tc (tasks_completed, number, 5), tt (tasks_total, number, 5), tst (tests, object, {\"ps\":45,\"fl\":2}), dur (duration_ms, number, 28500), mh (must_have_coverage, object, {\"ps\":3,\"fl\":0,\"tt\":3}), dt (datetime, string, \"2026-02-17T14:35:00Z\"). Prose note: Post-plan gate runs full test suite (not scoped). The mh field verifies must_have coverage from plan header: ps=passed, fl=failed, tt=total must_have checks. tc/tt fields match Summary schema pattern. Appended to same .qa-gate-results.jsonl file as post-task results."}
{"id":"T3","tp":"auto","a":"Define post-phase gate result JSONL schema in references/artifact-formats.md: keys (gl, r, ph=phase, plans=plan_results, tst, dur, esc=escalations). Add qa-gates.jsonl to Phase Directory Structure and naming-conventions.md.","f":["references/artifact-formats.md","references/naming-conventions.md"],"td":["T2"],"v":"Post-phase schema documented, qa-gates.jsonl in directory structure and naming conventions","done":"Post-phase gate schema and naming committed","spec":"TWO FILES to modify. FILE 1: references/artifact-formats.md (MODIFY). Insert after post-plan gate section from T2. Title: ### QA Gate Result: Post-Phase (.qa-gate-results.jsonl, appended per gate invocation). Post-phase schema keys: gl (gate_level, string, \"post-phase\"), r (result, string, \"PASS\"|\"FAIL\"|\"WARN\"), ph (phase, string, \"04\"), plans (plan_results, object[], [{\"plan\":\"04-03\",\"r\":\"PASS\"}]), tst (tests, object, {\"ps\":1919,\"fl\":0}), dur (duration_ms, number, 185000), esc (escalations, number, 0), gates (gate_check, object, {\"ps\":11,\"fl\":0,\"tt\":11}), dt (datetime, string, \"2026-02-17T15:00:00Z\"). Prose note: Post-phase gate is the most comprehensive -- runs full test suite, validates all plan gates passed, checks all workflow steps complete via validate-gates.sh. The plans array summarizes per-plan gate results. The gates field aggregates validate-gates.sh step checks. esc counts escalation events. This is a fast automated pre-check before QA agent spawn (architecture C11). Also in artifact-formats.md: Update the Phase Directory Structure section (lines ~333-357). Add after gaps.jsonl: .qa-gate-results.jsonl # Gate results (append-only, committed). Note the dot-prefix: runtime artifact like .execution-state.json. FILE 2: references/naming-conventions.md (MODIFY). In Section 1 File Naming Patterns table, add row: .qa-gate-results.jsonl | (dot-prefix, append-only) | Phase directory. In Section 6 Other Artifact Key Conventions, add subsection: ### QA Gate Results (.qa-gate-results.jsonl). Three schemas per gate level: post-task {gl, r, plan, task, tst, dur, f, dt}, post-plan {gl, r, plan, tc, tt, tst, dur, mh, dt}, post-phase {gl, r, ph, plans, tst, dur, esc, gates, dt}. Valid gl: post-task, post-plan, post-phase. Valid r: PASS, FAIL, WARN."}
{"id":"T4","tp":"auto","a":"Create scripts/format-gate-result.sh that takes gate level (post-task|post-plan|post-phase) and raw JSON input, outputs properly formatted JSONL line using abbreviated keys. Uses jq for transformation.","f":["scripts/format-gate-result.sh"],"td":["T3"],"v":"Script produces valid JSONL for all three gate levels, set -euo pipefail","done":"Gate result formatter committed","spec":"FILE: scripts/format-gate-result.sh (CREATE). Architecture D3: used by all three gate scripts for consistent JSONL output to .qa-gate-results.jsonl. Shebang and flags: #!/usr/bin/env bash, set -euo pipefail. Usage: format-gate-result.sh <gate-level> [<raw-json>]. gate-level: post-task|post-plan|post-phase (required). raw-json: JSON string with gate result data (optional -- if omitted, reads from stdin). Output: stdout = single JSONL line with abbreviated keys per artifact-formats.md schemas. Exit 0 on success, exit 1 on invalid gate level or invalid JSON input. Pattern reference: scripts/resolve-agent-model.sh (argument validation), scripts/git-commit-serialized.sh (header comment style). jq dependency check: standard pattern. Argument validation: first arg must be one of post-task, post-plan, post-phase. Reject with 'Invalid gate level' to stderr. If second arg provided, use as JSON input. If not, read from stdin: INPUT=\"${2:-$(cat)}\". Validate input is valid JSON: echo \"$INPUT\" | jq empty 2>/dev/null || { echo 'Invalid JSON input' >&2; exit 1; }. Transformation per gate level (all add dt field with current ISO8601): post-task jq: {gl: \"post-task\", r: (.result // .r // \"WARN\"), plan: (.plan_id // .plan // \"unknown\"), task: (.task_id // .task // \"unknown\"), tst: (.tests // .tst // {ps:0,fl:0}), dur: (.duration_ms // .dur // 0), f: (.files_tested // .f // []), dt: $dt}. post-plan jq: {gl: \"post-plan\", r: (.result // .r // \"WARN\"), plan: (.plan_id // .plan // \"unknown\"), tc: (.tasks_completed // .tc // 0), tt: (.tasks_total // .tt // 0), tst: (.tests // .tst // {ps:0,fl:0}), dur: (.duration_ms // .dur // 0), mh: (.must_have_coverage // .mh // {ps:0,fl:0,tt:0}), dt: $dt}. post-phase jq: {gl: \"post-phase\", r: (.result // .r // \"WARN\"), ph: (.phase // .ph // \"unknown\"), plans: (.plan_results // .plans // []), tst: (.tests // .tst // {ps:0,fl:0}), dur: (.duration_ms // .dur // 0), esc: (.escalations // .esc // 0), gates: (.gate_check // .gates // {ps:0,fl:0,tt:0}), dt: $dt}. The jq expressions accept BOTH full-name keys and abbreviated keys via // fallback. Output must be exactly one JSONL line (jq -c). Make executable: chmod +x.","ts":"FILE: tests/format-gate-result.bats (CREATE). Place in tests/ root. Framework: bats with test_helper/common, test_helper/fixtures. setup(): load helpers, mk_test_workdir, set SUT=$SCRIPTS_DIR/format-gate-result.sh. Test cases (7): 1. 'formats post-task result with abbreviated keys' -- echo full-name JSON input, pipe to SUT post-task. Assert output has gl=post-task, r=PASS, plan and task fields. Validate with jq -e. 2. 'formats post-plan result with aggregation fields' -- Provide post-plan JSON with tasks_completed, tasks_total, must_have_coverage. Assert output has tc, tt, mh fields. 3. 'formats post-phase result with escalations and gate checks' -- Provide post-phase JSON. Assert output has ph, plans, esc, gates fields. 4. 'rejects invalid gate level' -- Run with invalid-level. Assert exit 1 and stderr contains Invalid gate level. 5. 'rejects invalid JSON input' -- echo 'not json' | SUT post-task. Assert exit 1 and stderr contains Invalid JSON. 6. 'adds dt timestamp to output' -- Run any valid gate level. Assert output has dt field matching ISO8601 pattern. 7. 'accepts abbreviated keys in input' -- echo abbreviated JSON input. Assert output preserves values correctly."}
{"id":"T5","tp":"auto","a":"Write bats tests for format-gate-result.sh: test each gate level output format, test invalid gate level rejected, test output is valid JSONL parseable by jq. Verify abbreviated keys match artifact-formats.md definitions.","f":["tests/format-gate-result.bats"],"td":["T4"],"v":"All bats tests pass, covers all three levels plus error case","done":"Gate result formatter tests committed","spec":"T5 is the implementation of the test file specified in T4.ts. The test spec in T4.ts IS the spec for this task. Create tests/format-gate-result.bats exactly as described in T4.ts. Ensure all 7 test cases are implemented. Run bats tests/format-gate-result.bats to verify all pass."}
