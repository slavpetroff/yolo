{"p":"04","n":"03","t":"QA gate config schema and defaults","w":2,"d":["04-01","04-02"],"mh":{"tr":["New QA gate config fields have sensible defaults so existing configs work unchanged","Each gate level (post-task, post-plan, post-phase) is independently toggleable","Config changes validated by validate-plan.sh and jq-parseable"],"ar":[{"p":"config/defaults.json","pv":"qa_gates key exists with three sub-keys","c":"Contains post_task, post_plan, post_phase enable/disable toggles plus timeout and threshold settings"}],"kl":[{"fr":"config/defaults.json qa_gates","to":"REQ-07 gate definitions","vi":"Each gate level from REQ-07 has a corresponding config toggle"},{"fr":"config/defaults.json qa_gates","to":"references/qa-output-patterns.md gate levels","vi":"Config gate names match output pattern gate levels from 04-01"}]}}
{"id":"T1","tp":"auto","a":"Add qa_gates object to config/defaults.json with three sub-keys: post_task (true), post_plan (true), post_phase (true), plus timeout_seconds (300) and failure_threshold (critical). All defaults enable gates so continuous QA is on by default.","f":["config/defaults.json"],"v":"qa_gates key exists in defaults.json with all five fields, valid JSON","done":"qa_gates config defaults committed","spec":"FILE: config/defaults.json (MODIFY). Add qa_gates object as a new top-level key. Architecture D1: 04-03 is SOLE owner of this schema -- no other plan writes qa_gates to defaults.json. Insert after the existing cross_team_handoff key (last current key). Exact JSON to add: \"qa_gates\": { \"post_task\": true, \"post_plan\": true, \"post_phase\": true, \"timeout_seconds\": 300, \"failure_threshold\": \"critical\" }. Field types: post_task/post_plan/post_phase are booleans (gate enable/disable toggles). timeout_seconds is a positive integer (seconds). failure_threshold is a string enum: critical|major|minor (minimum severity to fail the gate). All gates default to enabled (true) so continuous QA is active by default -- projects that want to disable specific gates override via .yolo-planning/config.json. Use jq to validate the result: jq -e '.qa_gates | (.post_task, .post_plan, .post_phase | type == \"boolean\") and (.timeout_seconds | type == \"number\") and (.failure_threshold | test(\"^(critical|major|minor)$\"))' config/defaults.json. Pattern reference: existing top-level keys in config/defaults.json (effort, autonomy, approval_gates, departments). The qa_gates object follows the same nesting pattern as approval_gates."}
{"id":"T2","tp":"auto","a":"Add qa_gates fields to all three test fixture configs (balanced, quality, budget). Quality: all gates on, timeout 600. Balanced: all gates on, timeout 300. Budget: post_task off, post_plan on, post_phase on, timeout 120.","f":["tests/fixtures/config/balanced-config.json","tests/fixtures/config/quality-config.json","tests/fixtures/config/budget-config.json"],"td":["T1"],"v":"All three fixture configs have valid qa_gates objects, jq-parseable","done":"Fixture configs updated with qa_gates","spec":"FILES: tests/fixtures/config/balanced-config.json, quality-config.json, budget-config.json (all MODIFY). Add qa_gates object to each fixture after the existing cross_team_handoff key. Pattern: follow existing fixture structure -- each fixture already mirrors config/defaults.json with profile-specific overrides. balanced-config.json: qa_gates with post_task:true, post_plan:true, post_phase:true, timeout_seconds:300, failure_threshold:critical. quality-config.json: qa_gates with post_task:true, post_plan:true, post_phase:true, timeout_seconds:600, failure_threshold:major (quality profile: longer timeout for thoroughness, lower threshold catches more issues). budget-config.json: qa_gates with post_task:false, post_plan:true, post_phase:true, timeout_seconds:120, failure_threshold:critical (budget profile: skip per-task gates to save time/cost, shorter timeout, only fail on critical). Validate each with: jq -e '.qa_gates' <file> >/dev/null. All three must be valid JSON after modification. Use jq for modification, not sed: jq '. + {\"qa_gates\": {...}}' file > file.tmp && mv file.tmp file."}
{"id":"T3","tp":"auto","a":"Create scripts/resolve-qa-config.sh that reads qa_gates from config.json with graceful fallback to defaults.json when keys are missing. Output: JSON object with resolved gate settings. Uses jq // operator for backward compat.","f":["scripts/resolve-qa-config.sh"],"td":["T1"],"v":"Script outputs valid JSON, handles missing keys with defaults, set -euo pipefail","done":"resolve-qa-config.sh committed","spec":"FILE: scripts/resolve-qa-config.sh (CREATE). Pattern reference: scripts/resolve-agent-model.sh (same resolve-with-fallback pattern). Architecture: used by qa-gate.sh (04-05), qa-gate-post-task.sh (04-06), qa-gate-post-plan.sh (04-07), qa-gate-post-phase.sh (04-07). Shebang and flags: #!/usr/bin/env bash, set -euo pipefail. Usage: resolve-qa-config.sh <config-path> <defaults-path>. config-path: path to .yolo-planning/config.json. defaults-path: path to config/defaults.json. Output: stdout = JSON object with all 5 resolved qa_gates fields. Exit 0 on success, exit 1 on usage error. Fail-open: if both files missing or jq fails, output hardcoded defaults JSON and exit 0. Argument validation: exactly 2 args required. Print usage to stderr and exit 1 if wrong count. jq dependency check: if ! command -v jq &>/dev/null; then output hardcoded defaults and exit 0. Resolution logic (single jq call pattern from resolve-agent-model.sh): 1. Read defaults.json for base qa_gates values. 2. Read config.json for user overrides. 3. Merge with jq // operator: config value wins, fallback to defaults, fallback to hardcoded. Exact jq expression: jq -n --slurpfile defaults \"$DEFAULTS_PATH\" --slurpfile config \"$CONFIG_PATH\" '($defaults[0].qa_gates // {}) as $d | ($config[0].qa_gates // {}) as $c | { post_task: ($c.post_task // $d.post_task // true), post_plan: ($c.post_plan // $d.post_plan // true), post_phase: ($c.post_phase // $d.post_phase // true), timeout_seconds: ($c.timeout_seconds // $d.timeout_seconds // 300), failure_threshold: ($c.failure_threshold // $d.failure_threshold // \"critical\") }'. Edge cases: config.json does not exist: use /dev/null or empty JSON as slurpfile input. defaults.json does not exist: same. qa_gates key absent from both: hardcoded defaults via //. Partial override: user sets only post_task=false in config.json, other 4 fields come from defaults. Hardcoded fallback (when jq or both files fail): echo '{\"post_task\":true,\"post_plan\":true,\"post_phase\":true,\"timeout_seconds\":300,\"failure_threshold\":\"critical\"}'. Make executable: chmod +x.","ts":"FILE: tests/resolve-qa-config.bats (CREATE). Framework: bats with test_helper/common, test_helper/fixtures, test_helper/mock_stdin (same setup as tests/unit/resolve-agent-model.bats). Place in tests/ root per task description. setup(): load helpers, mk_test_workdir, set SUT=$SCRIPTS_DIR/resolve-qa-config.sh. Test cases (6): 1. 'resolves defaults when config has no qa_gates key' -- Create minimal config.json without qa_gates. Run SUT with config + defaults.json. Assert output matches defaults.json qa_gates values. 2. 'per-gate override from config wins' -- Create config.json with qa_gates.post_task=false. Run SUT. Assert post_task=false, other fields from defaults. 3. 'missing qa_gates key in both files falls back to hardcoded' -- Create empty JSON files for both args. Run SUT. Assert output has all 5 fields with hardcoded defaults. 4. 'invalid config path fails gracefully' -- Run SUT with nonexistent config path. Assert exit 0 (fail-open) and valid JSON output. 5. 'partial override preserves unset fields' -- Create config.json with qa_gates containing only timeout_seconds:600. Assert timeout=600, all other fields from defaults. 6. 'rejects wrong argument count' -- Run with 0 args and 1 arg. Assert exit 1 and stderr contains Usage."}
{"id":"T4","tp":"auto","a":"Write bats tests for resolve-qa-config.sh: test default resolution, test per-gate override, test missing qa_gates key fallback, test invalid values rejected. Place in tests/ following existing test patterns.","f":["tests/resolve-qa-config.bats"],"td":["T3"],"v":"All bats tests pass, covers default, override, fallback, and invalid cases","done":"QA config resolution tests committed","spec":"T4 is the implementation of the test file specified in T3.ts. The test spec in T3.ts IS the spec for this task. Create tests/resolve-qa-config.bats exactly as described in T3.ts. Ensure all 6 test cases are implemented. Run bats tests/resolve-qa-config.bats to verify all pass."}
{"id":"T5","tp":"auto","a":"Add qa_gates config validation to scripts/validate-config.sh (or create if not exists): verify qa_gates.post_task/post_plan/post_phase are booleans, timeout_seconds is positive integer, failure_threshold is one of critical/major/minor. Return structured error JSON on invalid.","f":["scripts/validate-config.sh"],"td":["T3"],"v":"Validation catches invalid qa_gates values, passes on valid configs","done":"Config validation for qa_gates committed","spec":"FILE: scripts/validate-config.sh (CREATE -- no existing validate-config.sh exists). Architecture D6: this script is wired into session-start.sh in a later task (not this one), but must be designed for that call site (warn-only, non-blocking). Shebang and flags: #!/usr/bin/env bash, set -euo pipefail. Usage: validate-config.sh <config-path> [<defaults-path>]. config-path: path to config file to validate. defaults-path: optional. Output: stdout = JSON {\"valid\":true,\"errors\":[]} or {\"valid\":false,\"errors\":[...]}. Exit 0 = valid, exit 1 = invalid. Pattern reference: scripts/validate-plan.sh (same output format, same ERRORS array accumulation pattern). jq dependency check: same pattern as validate-plan.sh. Argument parsing: 1-2 args, print usage to stderr and exit 1 if wrong. Validation logic (if qa_gates key exists in config -- skip validation entirely if absent for backward compat): 1. Check qa_gates is object: jq -e '.qa_gates | type == \"object\"'. 2. Check post_task is boolean (if present): jq -e '.qa_gates.post_task | type == \"boolean\"'. 3. Same for post_plan, post_phase. 4. Check timeout_seconds is positive number (if present): jq -e '.qa_gates.timeout_seconds | (type == \"number\") and (. > 0)'. 5. Check failure_threshold is valid enum (if present): jq -e '.qa_gates.failure_threshold | test(\"^(critical|major|minor)$\")'. Error accumulation: ERRORS=() pattern from validate-plan.sh. Output: same jq-based JSON construction as validate-plan.sh lines 299-305. Edge cases: no qa_gates key = valid:true (backward compat). qa_gates not an object = error. string 'true' instead of boolean = error. timeout 0 or negative = error. threshold 'high' = error. Multiple errors accumulated. Make executable: chmod +x.","ts":"FILE: tests/validate-config.bats (CREATE). Place in tests/ root. Framework: bats with test_helper/common, test_helper/fixtures. setup(): load helpers, mk_test_workdir, set SUT=$SCRIPTS_DIR/validate-config.sh. Test cases (8): 1. 'valid config with qa_gates passes' -- Create config with valid qa_gates. Assert exit 0 and valid:true. 2. 'config without qa_gates key passes (backward compat)' -- Config without qa_gates. Assert exit 0, valid:true. 3. 'rejects non-boolean post_task' -- qa_gates.post_task='yes'. Assert exit 1 and errors contains boolean error. 4. 'rejects non-boolean post_plan' -- Same for post_plan. 5. 'rejects zero timeout_seconds' -- timeout_seconds:0. Assert exit 1 and error about positive number. 6. 'rejects invalid failure_threshold' -- failure_threshold:'high'. Assert exit 1 and error about valid values. 7. 'accumulates multiple errors' -- post_task='yes' AND timeout_seconds=-1 AND failure_threshold='bad'. Assert exit 1 and errors array has 3 entries. 8. 'rejects wrong argument count' -- Run with 0 args. Assert exit 1 and stderr contains Usage."}
