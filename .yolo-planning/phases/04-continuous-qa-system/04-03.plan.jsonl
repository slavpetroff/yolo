{"p":"04","n":"03","t":"QA gate config schema and defaults","w":2,"d":["04-01","04-02"],"mh":{"tr":["New QA gate config fields have sensible defaults so existing configs work unchanged","Each gate level (post-task, post-plan, post-phase) is independently toggleable","Config changes validated by validate-plan.sh and jq-parseable"],"ar":[{"p":"config/defaults.json","pv":"qa_gates key exists with three sub-keys","c":"Contains post_task, post_plan, post_phase enable/disable toggles plus timeout and threshold settings"}],"kl":[{"fr":"config/defaults.json qa_gates","to":"REQ-07 gate definitions","vi":"Each gate level from REQ-07 has a corresponding config toggle"},{"fr":"config/defaults.json qa_gates","to":"references/qa-output-patterns.md gate levels","vi":"Config gate names match output pattern gate levels from 04-01"}]}}
{"id":"T1","tp":"auto","a":"Add qa_gates object to config/defaults.json with three sub-keys: post_task (true), post_plan (true), post_phase (true), plus timeout_seconds (300) and failure_threshold (critical). All defaults enable gates so continuous QA is on by default.","f":["config/defaults.json"],"v":"qa_gates key exists in defaults.json with all five fields, valid JSON","done":"qa_gates config defaults committed","spec":"FILE: config/defaults.json (MODIFY). Add qa_gates object as a new top-level key. Architecture D1: 04-03 is SOLE owner of this schema -- no other plan writes qa_gates to defaults.json. Insert after the existing 'cross_team_handoff' key (last current key). Exact JSON to add:\n\n  \"qa_gates\": {\n    \"post_task\": true,\n    \"post_plan\": true,\n    \"post_phase\": true,\n    \"timeout_seconds\": 300,\n    \"failure_threshold\": \"critical\"\n  }\n\nField types: post_task/post_plan/post_phase are booleans (gate enable/disable toggles). timeout_seconds is a positive integer (seconds). failure_threshold is a string enum: 'critical'|'major'|'minor' (minimum severity to fail the gate). All gates default to enabled (true) so continuous QA is active by default -- projects that want to disable specific gates override via .yolo-planning/config.json. Use jq to validate the result: jq -e '.qa_gates | (.post_task, .post_plan, .post_phase | type == \"boolean\") and (.timeout_seconds | type == \"number\") and (.failure_threshold | test(\"^(critical|major|minor)$\"))' config/defaults.json. Pattern reference: existing top-level keys in config/defaults.json (effort, autonomy, approval_gates, departments). The qa_gates object follows the same nesting pattern as approval_gates."}
{"id":"T2","tp":"auto","a":"Add qa_gates fields to all three test fixture configs (balanced, quality, budget). Quality: all gates on, timeout 600. Balanced: all gates on, timeout 300. Budget: post_task off, post_plan on, post_phase on, timeout 120.","f":["tests/fixtures/config/balanced-config.json","tests/fixtures/config/quality-config.json","tests/fixtures/config/budget-config.json"],"td":["T1"],"v":"All three fixture configs have valid qa_gates objects, jq-parseable","done":"Fixture configs updated with qa_gates","spec":"FILES: tests/fixtures/config/balanced-config.json, tests/fixtures/config/quality-config.json, tests/fixtures/config/budget-config.json (all MODIFY). Add qa_gates object to each fixture after the existing 'cross_team_handoff' key. Pattern: follow existing fixture structure -- each fixture already mirrors config/defaults.json with profile-specific overrides.\n\nbalanced-config.json -- add:\n  \"qa_gates\": {\n    \"post_task\": true,\n    \"post_plan\": true,\n    \"post_phase\": true,\n    \"timeout_seconds\": 300,\n    \"failure_threshold\": \"critical\"\n  }\n\nquality-config.json -- add:\n  \"qa_gates\": {\n    \"post_task\": true,\n    \"post_plan\": true,\n    \"post_phase\": true,\n    \"timeout_seconds\": 600,\n    \"failure_threshold\": \"major\"\n  }\n(Quality profile: longer timeout for thoroughness, lower threshold catches more issues.)\n\nbudget-config.json -- add:\n  \"qa_gates\": {\n    \"post_task\": false,\n    \"post_plan\": true,\n    \"post_phase\": true,\n    \"timeout_seconds\": 120,\n    \"failure_threshold\": \"critical\"\n  }\n(Budget profile: skip per-task gates to save time/cost, shorter timeout, only fail on critical.)\n\nValidate each with: jq -e '.qa_gates' <file> >/dev/null. All three must be valid JSON after modification. Use jq for modification, not sed: jq '. + {\"qa_gates\": {...}}' file > file.tmp && mv file.tmp file."}
{"id":"T3","tp":"auto","a":"Create scripts/resolve-qa-config.sh that reads qa_gates from config.json with graceful fallback to defaults.json when keys are missing. Output: JSON object with resolved gate settings. Uses jq // operator for backward compat.","f":["scripts/resolve-qa-config.sh"],"td":["T1"],"v":"Script outputs valid JSON, handles missing keys with defaults, set -euo pipefail","done":"resolve-qa-config.sh committed","spec":"FILE: scripts/resolve-qa-config.sh (CREATE). Pattern reference: scripts/resolve-agent-model.sh (same resolve-with-fallback pattern). Architecture: used by qa-gate.sh (04-05), qa-gate-post-task.sh (04-06), qa-gate-post-plan.sh (04-07), qa-gate-post-phase.sh (04-07).\n\nShebang and flags: #!/usr/bin/env bash, set -euo pipefail.\n\nUsage: resolve-qa-config.sh <config-path> <defaults-path>\n  config-path: path to .yolo-planning/config.json\n  defaults-path: path to config/defaults.json\n  Output: stdout = JSON object with all 5 resolved qa_gates fields\n  Exit 0 on success, exit 1 on usage error\n  Fail-open: if both files missing or jq fails, output hardcoded defaults JSON and exit 0\n\nArgument validation: exactly 2 args required. Print usage to stderr and exit 1 if wrong count.\n\njq dependency check: if ! command -v jq &>/dev/null; then output hardcoded defaults and exit 0.\n\nResolution logic (single jq call pattern from resolve-agent-model.sh):\n  1. Read defaults.json for base qa_gates values\n  2. Read config.json for user overrides\n  3. Merge with jq // operator: config value wins, fallback to defaults, fallback to hardcoded\n\nExact jq expression:\n  jq -n --slurpfile defaults \"$DEFAULTS_PATH\" --slurpfile config \"$CONFIG_PATH\" '\n    ($defaults[0].qa_gates // {}) as $d |\n    ($config[0].qa_gates // {}) as $c |\n    {\n      post_task: ($c.post_task // $d.post_task // true),\n      post_plan: ($c.post_plan // $d.post_plan // true),\n      post_phase: ($c.post_phase // $d.post_phase // true),\n      timeout_seconds: ($c.timeout_seconds // $d.timeout_seconds // 300),\n      failure_threshold: ($c.failure_threshold // $d.failure_threshold // \"critical\")\n    }\n  '\n\nEdge cases:\n  - config.json does not exist: use defaults only (check -f before --slurpfile, use /dev/null or empty JSON)\n  - defaults.json does not exist: use hardcoded defaults (same check)\n  - qa_gates key absent from both: hardcoded defaults apply via // operator\n  - Partial override: user sets only post_task=false in config.json, other 4 fields come from defaults\n\nHardcoded fallback (when jq or both files fail):\n  echo '{\"post_task\":true,\"post_plan\":true,\"post_phase\":true,\"timeout_seconds\":300,\"failure_threshold\":\"critical\"}'\n\nMake executable: chmod +x. Script header comment matches resolve-agent-model.sh style.","ts":"FILE: tests/resolve-qa-config.bats (CREATE). Framework: bats with test_helper/common, test_helper/fixtures, test_helper/mock_stdin (same setup as tests/unit/resolve-agent-model.bats). Place in tests/ (root tests dir, not tests/unit/) per task description.\n\nsetup(): load helpers, mk_test_workdir, set SUT=$SCRIPTS_DIR/resolve-qa-config.sh, set DEFAULTS=$CONFIG_DIR/../defaults.json (or use $FIXTURES_DIR path).\n\nTest cases (5 minimum):\n\n1. 'resolves defaults when config has no qa_gates key' -- Create minimal config.json without qa_gates. Run SUT with config + defaults.json. Assert output matches defaults.json qa_gates values. Validate with jq -e '.post_task == true'.\n\n2. 'per-gate override from config wins' -- Create config.json with qa_gates.post_task=false. Run SUT. Assert post_task=false, other fields from defaults.\n\n3. 'missing qa_gates key in both files falls back to hardcoded' -- Create empty JSON files for both args. Run SUT. Assert output has all 5 fields with hardcoded defaults (post_task:true, timeout_seconds:300, etc.).\n\n4. 'invalid config path fails gracefully' -- Run SUT with nonexistent config path. Assert exit 0 (fail-open) and valid JSON output.\n\n5. 'partial override preserves unset fields' -- Create config.json with qa_gates containing only timeout_seconds:600. Assert timeout_seconds=600, all other fields from defaults.\n\n6. 'rejects wrong argument count' -- Run SUT with 0 args and 1 arg. Assert exit 1 and stderr contains 'Usage'."}
{"id":"T4","tp":"auto","a":"Write bats tests for resolve-qa-config.sh: test default resolution, test per-gate override, test missing qa_gates key fallback, test invalid values rejected. Place in tests/ following existing test patterns.","f":["tests/resolve-qa-config.bats"],"td":["T3"],"v":"All bats tests pass, covers default, override, fallback, and invalid cases","done":"QA config resolution tests committed","spec":"NOTE: T4 is the implementation of the test file specified in T3's ts field. The test spec in T3.ts IS the spec for this task. Create tests/resolve-qa-config.bats exactly as described in T3.ts. Use the T3 ts field as the authoritative spec. Ensure all 6 test cases are implemented. Run 'bats tests/resolve-qa-config.bats' to verify all pass."}
{"id":"T5","tp":"auto","a":"Add qa_gates config validation to scripts/validate-config.sh (or create if not exists): verify qa_gates.post_task/post_plan/post_phase are booleans, timeout_seconds is positive integer, failure_threshold is one of critical/major/minor. Return structured error JSON on invalid.","f":["scripts/validate-config.sh"],"td":["T3"],"v":"Validation catches invalid qa_gates values, passes on valid configs","done":"Config validation for qa_gates committed","spec":"FILE: scripts/validate-config.sh (CREATE -- no existing validate-config.sh exists). Architecture D6: this script is wired into session-start.sh in a later task (not this one), but must be designed for that call site (warn-only, non-blocking).\n\nShebang and flags: #!/usr/bin/env bash, set -euo pipefail.\n\nUsage: validate-config.sh <config-path> [<defaults-path>]\n  config-path: path to config file to validate (.yolo-planning/config.json or fixture)\n  defaults-path: optional, path to defaults.json (for cross-reference)\n  Output: stdout = JSON {\"valid\":true,\"errors\":[]} or {\"valid\":false,\"errors\":[\"...\"]}\n  Exit 0 = valid, exit 1 = invalid\n  Pattern reference: scripts/validate-plan.sh (same output format, same error accumulation pattern)\n\njq dependency check: same pattern as validate-plan.sh lines 14-17.\n\nArgument parsing: 1-2 args. If no config path, print usage to stderr and exit 1.\n\nValidation logic (if qa_gates key exists in config -- skip validation entirely if absent for backward compat):\n\n  1. Check qa_gates is an object: jq -e '.qa_gates | type == \"object\"'\n  2. Check post_task is boolean (if present): jq -e '.qa_gates.post_task | type == \"boolean\"'\n  3. Check post_plan is boolean (if present): jq -e '.qa_gates.post_plan | type == \"boolean\"'\n  4. Check post_phase is boolean (if present): jq -e '.qa_gates.post_phase | type == \"boolean\"'\n  5. Check timeout_seconds is positive number (if present): jq -e '.qa_gates.timeout_seconds | (type == \"number\") and (. > 0)'\n  6. Check failure_threshold is valid enum (if present): jq -e '.qa_gates.failure_threshold | test(\"^(critical|major|minor)$\")'\n\nError accumulation: use bash array ERRORS=() pattern from validate-plan.sh. Append error strings for each failed check.\n\nOutput: same jq-based JSON construction as validate-plan.sh lines 299-305:\n  if [ ${#ERRORS[@]} -eq 0 ]; then\n    jq -n '{\"valid\":true,\"errors\":[]}'\n    exit 0\n  else\n    printf '%s\\n' \"${ERRORS[@]}\" | jq -R . | jq -s '{\"valid\":false,\"errors\":.}'\n    exit 1\n  fi\n\nEdge cases:\n  - Config file has no qa_gates key: output {\"valid\":true,\"errors\":[]} (backward compat)\n  - qa_gates exists but is not an object (e.g., string): error 'qa_gates must be an object'\n  - post_task is string 'true' instead of boolean true: error 'qa_gates.post_task must be boolean'\n  - timeout_seconds is 0 or negative: error 'qa_gates.timeout_seconds must be positive number'\n  - failure_threshold is 'high': error 'qa_gates.failure_threshold must be critical, major, or minor'\n  - Multiple errors: all accumulated and returned in errors array\n\nMake executable: chmod +x.","ts":"FILE: tests/validate-config.bats (CREATE). Place in tests/ root. Framework: bats with test_helper/common, test_helper/fixtures.\n\nsetup(): load helpers, mk_test_workdir, set SUT=$SCRIPTS_DIR/validate-config.sh.\n\nTest cases (7 minimum):\n\n1. 'valid config with qa_gates passes' -- Create config with valid qa_gates. Assert exit 0 and output contains '\"valid\":true'.\n\n2. 'config without qa_gates key passes (backward compat)' -- Create config without qa_gates. Assert exit 0 and valid:true.\n\n3. 'rejects non-boolean post_task' -- Create config with qa_gates.post_task='yes'. Assert exit 1 and errors array contains boolean error.\n\n4. 'rejects non-boolean post_plan' -- Same pattern for post_plan.\n\n5. 'rejects zero timeout_seconds' -- Create config with qa_gates.timeout_seconds=0. Assert exit 1 and error about positive number.\n\n6. 'rejects invalid failure_threshold' -- Create config with failure_threshold='high'. Assert exit 1 and error about valid values.\n\n7. 'accumulates multiple errors' -- Create config with post_task='yes' AND timeout_seconds=-1 AND failure_threshold='bad'. Assert exit 1 and errors array has 3 entries.\n\n8. 'rejects wrong argument count' -- Run with 0 args. Assert exit 1 and stderr contains 'Usage'."}
