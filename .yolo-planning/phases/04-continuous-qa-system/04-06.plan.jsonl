{"p":"04","n":"06","t":"Post-task QA gate script","w":2,"d":[],"mh":{"tr":["Post-task QA gate runs test-summary.sh and exits non-zero on failure","Gate accepts --phase-dir and --plan and --task flags to scope test runs","Gate works identically in team_mode=task and team_mode=teammate","Gate outputs structured JSON result: {gate,level,r,tests,dt}","Gate is fail-open on missing test infrastructure (no bats = warn, not block)"],"ar":[{"p":"scripts/qa-gate-post-task.sh","pv":"file exists and is executable","c":"Contains post-task QA gate logic: runs test-summary.sh, parses TAP output, exits 0 on pass, exits 1 on fail, outputs JSON result"},{"p":"tests/unit/qa-gate-post-task.bats","pv":"file exists","c":"Tests for post-task gate: pass/fail/no-tests/timeout scenarios, JSON output validation, fail-open behavior"}],"kl":[{"fr":"scripts/qa-gate-post-task.sh","to":"scripts/test-summary.sh","vi":"Post-task gate invokes test-summary.sh for test execution"},{"fr":"scripts/qa-gate-post-task.sh","to":"references/qa-output-patterns.md","vi":"Gate output follows UX-defined output templates from 04-01"}]},"obj":"Create the post-task QA gate script that runs unit tests after each Senior-approved task batch, with structured JSON output and fail-open safety","sk":["commit"],"fm":["scripts/qa-gate-post-task.sh","tests/unit/qa-gate-post-task.bats"]}
{"id":"T1","tp":"auto","a":"Create scripts/qa-gate-post-task.sh: accepts --phase-dir, --plan, --task flags. Runs test-summary.sh, captures output and exit code. Produces JSON result {gate:pass|fail|warn,level:post-task,r:PASS|FAIL|WARN,tests:{ps:N,fl:N},dt:YYYY-MM-DD}. Exit 0 on pass, exit 1 on fail. Fail-open: if bats/test-summary.sh missing, output warn and exit 0. Use set -u, jq for JSON output. REQ-07 post-task gate.","f":["scripts/qa-gate-post-task.sh"],"v":"Script exists, is executable, accepts all three flags, produces valid JSON on stdout","done":"Post-task QA gate script committed and executable","spec":"File: scripts/qa-gate-post-task.sh (new, chmod +x). Shebang: #!/usr/bin/env bash. Use set -u (not set -euo pipefail -- fail-open requires manual error handling). Structure: (1) CONSTANTS: SCRIPT_DIR resolve via cd/dirname/pwd pattern (copy from test-summary.sh lines 10-11). DEFAULT_TIMEOUT=30. (2) ARG PARSING: while [ $# -gt 0 ]; case --phase-dir, --plan, --task, --scope, --files, --timeout. Store in PHASE_DIR, PLAN_ID, TASK_ID, SCOPE_MODE (boolean default false), FILES_LIST, TIMEOUT. Validate PHASE_DIR is set (required), PLAN_ID and TASK_ID optional but logged. (3) FAIL-OPEN CHECKS: if ! command -v bats >/dev/null 2>&1; then output warn JSON and exit 0. If ! [ -x \"$SCRIPT_DIR/test-summary.sh\" ]; then output warn JSON and exit 0. (4) TEST EXECUTION: Run test-summary.sh via timeout command: timeout \"$TIMEOUT\" bash \"$SCRIPT_DIR/test-summary.sh\" and capture output+exit code. Parse output: PASS line gives pass count via grep/sed, FAIL line gives fail/total counts. On timeout (exit 124): treat as warn, not fail. (5) JSON OUTPUT: Use jq -n with --arg/--argjson to build result object. Schema: {gate:\"pass\"|\"fail\"|\"warn\", level:\"post-task\", r:\"PASS\"|\"FAIL\"|\"WARN\", plan:\"$PLAN_ID\", task:\"$TASK_ID\", tst:{ps:N,fl:N}, dur:N, dt:\"$(date +%Y-%m-%d)\"}. Output to stdout. (6) RESULT PERSISTENCE: Append result line to $PHASE_DIR/.qa-gate-results.jsonl using flock serialization (per architecture D3/D5). Copy flock+mkdir pattern from git-commit-serialized.sh: LOCK_FILE=\"$PHASE_DIR/.qa-gate-results.lock\", MAX_RETRIES=5, BASE_DELAY_MS=200. Use has_flock/acquire_lock_flock/acquire_lock_mkdir/release_lock_mkdir/sleep_ms helpers (copy directly from git-commit-serialized.sh lines 18-55). Append via: echo \"$RESULT_JSON\" >> \"$PHASE_DIR/.qa-gate-results.jsonl\". (7) EXIT: exit 0 on pass/warn, exit 1 on fail. Key patterns to copy: git-commit-serialized.sh for flock (lines 12-55, 59-110), test-summary.sh for path resolution (lines 10-11) and bats detection (lines 14-17). Error handling: every external command wrapped in || to prevent unintended exits under set -u. jq dependency check at script top (copy from validate-gates.sh lines 16-19).","ts":"File: tests/unit/qa-gate-post-task.bats (new). Framework: bats with load '../test_helper/common' and load '../test_helper/fixtures'. Setup: mk_test_workdir, SUT=\"$SCRIPTS_DIR/qa-gate-post-task.sh\", PHASE_DIR=\"$TEST_WORKDIR/phase-test\", mkdir -p \"$PHASE_DIR\". Test cases (minimum 8): (1) 'exits 0 and outputs pass JSON when test-summary returns PASS' -- create mock test-summary.sh in PATH that echoes 'PASS (10 tests)' and exits 0, run SUT --phase-dir $PHASE_DIR --plan 04-06 --task T1, assert_success, parse output with jq, verify gate=pass and r=PASS and tst.ps=10. (2) 'exits 1 and outputs fail JSON when test-summary returns FAIL' -- mock test-summary.sh echoes 'FAIL (2/10 failed)' and exits 1, assert_failure, verify gate=fail and r=FAIL and tst.fl=2. (3) 'exits 0 with warn when bats not installed' -- temporarily hide bats from PATH, run SUT, assert_success, verify gate=warn and r=WARN. (4) 'exits 0 with warn when test-summary.sh missing' -- rename test-summary.sh, run SUT, assert_success, verify gate=warn. (5) 'produces valid JSON parseable by jq' -- run SUT with mock pass, pipe output to jq empty, assert_success. (6) 'includes plan and task fields in output' -- run with --plan 04-06 --task T1, verify jq '.plan' = 04-06 and jq '.task' = T1. (7) 'appends result to .qa-gate-results.jsonl' -- run SUT with mock pass, verify $PHASE_DIR/.qa-gate-results.jsonl exists and has 1 line parseable by jq. (8) 'handles timeout gracefully as warn' -- mock test-summary.sh that sleeps 60s, run SUT --timeout 1, assert_success, verify gate=warn. (9) 'works without --plan and --task flags' -- run with only --phase-dir, assert_success. Mock strategy: create mock scripts dir in TEST_WORKDIR, prepend to PATH. Use export PATH=\"$MOCK_DIR:$PATH\" pattern."}
{"id":"T2","tp":"auto","a":"Add --scope flag to qa-gate-post-task.sh that limits test-summary.sh to run only test suites relevant to modified files. Accept --files flag (comma-separated) or read from plan.jsonl task f field. When --scope is omitted, run full test suite. This enables fast feedback: only relevant tests after each task.","f":["scripts/qa-gate-post-task.sh"],"td":["T1"],"v":"--scope flag limits test execution, --files accepts comma-separated paths","done":"Scoped test execution committed","spec":"File: scripts/qa-gate-post-task.sh (modify, added in T1). Add --scope and --files flag handling to the existing arg parser case statement. When --scope is set (SCOPE_MODE=true): (1) Determine relevant files: if --files provided, split on comma into FILES_ARRAY. Else if PLAN_ID and TASK_ID set, read task f field: jq -r --arg id \"$TASK_ID\" 'select(.id==$id) | .f[]' < \"$PHASE_DIR/${PLAN_ID}.plan.jsonl\" (skip header via tail -n +2 | while read). (2) Map source files to test files: for each file in FILES_ARRAY, derive test file path. Pattern: scripts/foo.sh -> tests/unit/foo.bats, scripts/foo.sh -> tests/foo.bats. Use basename + find in tests/ dir: test_file=$(find \"$TESTS_DIR\" -name \"$(basename \"$src_file\" .sh).bats\" 2>/dev/null | head -1). Collect into SCOPED_TESTS array. (3) If SCOPED_TESTS is empty: output pass JSON with note 'no relevant tests found' and exit 0. (4) If SCOPED_TESTS has entries: run bats directly on those files instead of test-summary.sh: timeout \"$TIMEOUT\" bats --tap \"${SCOPED_TESTS[@]}\". Parse TAP output same as full suite (reuse existing parse logic). Key detail: TESTS_DIR resolve via SCRIPT_DIR/../tests (same as test-summary.sh line 11). When --scope is NOT set: behavior unchanged from T1 (run test-summary.sh). Architecture D4 compliance: --scope is the flag that 04-08 will specify as default in protocol integration.","ts":""}
{"id":"T3","tp":"auto","a":"Add team_mode awareness to qa-gate-post-task.sh: detect team_mode from config/defaults.json or YOLO_TEAM_MODE env var. In teammate mode, output includes task_id and plan_id fields for Lead aggregation. In task mode, output is unchanged. Both paths produce identical JSON schema (extra fields are additive). REQ-07 both team modes.","f":["scripts/qa-gate-post-task.sh"],"td":["T2"],"v":"Script reads team_mode, adds task_id/plan_id in teammate mode, JSON schema valid in both modes","done":"Team mode awareness committed","spec":"File: scripts/qa-gate-post-task.sh (modify). Add team_mode detection after arg parsing: (1) Check YOLO_TEAM_MODE env var first: TEAM_MODE=\"${YOLO_TEAM_MODE:-}\". (2) If empty, read from config: if [ -f \"$CONFIG_PATH\" ]; then TEAM_MODE=$(jq -r '.team_mode // \"task\"' \"$CONFIG_PATH\" 2>/dev/null) || TEAM_MODE=\"task\"; fi. CONFIG_PATH resolution: check .yolo-planning/config.json relative to PHASE_DIR (go up from phase-dir: CONFIG_PATH=\"$(dirname \"$(dirname \"$PHASE_DIR\")\")/config.json\"). Fallback to config/defaults.json via SCRIPT_DIR. (3) In the JSON output section, always include plan and task fields (already added in T1). Add team_mode field: include in jq -n: --arg tm \"$TEAM_MODE\". The JSON object gains 'tm' key (abbreviated per artifact-formats.md pattern). (4) Key constraint: both team modes produce identical JSON schema -- tm field is always present, just has different value. No conditional JSON structure. This is additive, not branching. Backward compat: if neither env var nor config exists, default to 'task' mode.","ts":""}
{"id":"T4","tp":"auto","a":"Write tests/unit/qa-gate-post-task.bats: test pass scenario (test-summary returns PASS), fail scenario (test-summary returns FAIL with details), no-test-infra scenario (bats missing = warn exit 0), JSON output validation (jq parses all fields), --scope filtering, team_mode field inclusion. Minimum 8 test cases.","f":["tests/unit/qa-gate-post-task.bats"],"td":["T3"],"v":"All tests pass, minimum 8 cases covering pass/fail/warn/scope/team_mode","done":"Post-task gate tests committed","spec":"File: tests/unit/qa-gate-post-task.bats (new, created by T1's ts, now extended by T3 additions). This task EXTENDS the test file from T1. Add additional test cases for T2 (--scope) and T3 (team_mode) features. New tests to add: (10) 'scoped test finds matching bats file for modified script' -- create tests/unit/foo.bats in TEST_WORKDIR, run SUT --phase-dir $PHASE_DIR --scope --files scripts/foo.sh, verify only foo.bats was executed (check output or result). (11) 'scoped test returns pass with note when no matching tests' -- run SUT --phase-dir $PHASE_DIR --scope --files scripts/nonexistent.sh, assert_success, verify output note about no relevant tests. (12) 'team_mode=teammate adds tm field to JSON' -- export YOLO_TEAM_MODE=teammate, run SUT, verify jq '.tm' = teammate. (13) 'team_mode defaults to task when env var unset' -- unset YOLO_TEAM_MODE, run SUT, verify jq '.tm' = task. (14) 'result appended to .qa-gate-results.jsonl on each run' -- run SUT twice with mock pass, verify $PHASE_DIR/.qa-gate-results.jsonl has 2 lines. Total: 14+ test cases (9 from T1 ts + 5 from T4). Fixture strategy: create MOCK_DIR in setup(), write mock test-summary.sh and mock bats scripts there, prepend to PATH.","ts":""}
