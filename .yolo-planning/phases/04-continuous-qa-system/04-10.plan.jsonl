{"p":"04","n":"10","t":"QA gate config, validate-gates update, and integration tests","w":2,"d":["04-03","04-06","04-07","04-08"],"mh":{"tr":["config/defaults.json includes qa_gates object with per-level enable/disable toggles","validate-gates.sh recognizes post_task_qa and post_plan_qa as valid gate check points","Integration test verifies full gate cascade: post-task -> post-plan -> post-phase","Config defaults: post-task enabled, post-plan enabled, post-phase enabled"],"ar":[{"p":"config/defaults.json","pv":"file exists","c":"Contains qa_gates object with post_task, post_plan, post_phase boolean toggles"},{"p":"scripts/validate-gates.sh","pv":"file exists","c":"Updated with post_task_qa and post_plan_qa step entries in the case statement"},{"p":"tests/integration/qa-gate-cascade.bats","pv":"file exists","c":"Integration test verifying gate cascade from post-task through post-phase"},{"p":"tests/unit/validate-gates.bats","pv":"file exists","c":"Updated with tests for new post_task_qa and post_plan_qa gate entries"}],"kl":[{"fr":"config/defaults.json qa_gates","to":"scripts/qa-gate-post-task.sh","vi":"Config toggles control whether post-task gate runs"},{"fr":"scripts/validate-gates.sh post_task_qa","to":"scripts/qa-gate-post-task.sh","vi":"Gate validation can verify post-task gate prerequisites"},{"fr":"tests/integration/qa-gate-cascade.bats","to":"scripts/qa-gate-post-task.sh + qa-gate-post-plan.sh + qa-gate-post-phase.sh","vi":"Integration test exercises all three gates in sequence"}]},"obj":"Wire config toggles into gate scripts, update validate-gates.sh for new gate types, and write integration tests verifying the full gate cascade","sk":["commit"],"fm":["scripts/validate-gates.sh","tests/unit/validate-gates.bats","tests/integration/qa-gate-cascade.bats"]}
{"id":"T1","tp":"auto","a":"Update qa-gate-post-task.sh, qa-gate-post-plan.sh, qa-gate-post-phase.sh to read their respective config toggle from resolve-qa-config.sh (skip with exit 0 and JSON {gate:skipped} when disabled). Per architecture D1: config/defaults.json qa_gates schema is owned by plan 04-03 -- do NOT modify config/defaults.json here. Only read config via resolve-qa-config.sh. Backward compatible: missing qa_gates key defaults to all enabled.","f":["scripts/qa-gate-post-task.sh","scripts/qa-gate-post-plan.sh","scripts/qa-gate-post-phase.sh"],"v":"Each gate script reads its config toggle via resolve-qa-config.sh, skip produces valid JSON","done":"Gate config toggle reading committed","spec":"File: scripts/qa-gate-post-task.sh, scripts/qa-gate-post-plan.sh, scripts/qa-gate-post-phase.sh (modify all three). For EACH script, add config toggle check AFTER arg parsing and BEFORE any gate logic. Implementation pattern (identical for all three, only the field name changes): (1) Resolve config: CONFIG_JSON=$(bash \"$SCRIPT_DIR/resolve-qa-config.sh\" 2>/dev/null) || CONFIG_JSON='{}'. This calls resolve-qa-config.sh (created by plan 04-03 T3). Fail-open: if resolve-qa-config.sh missing or fails, default to empty JSON (all gates enabled). (2) Read toggle: For qa-gate-post-task.sh: ENABLED=$(echo \"$CONFIG_JSON\" | jq -r '.post_task // true'). For qa-gate-post-plan.sh: ENABLED=$(echo \"$CONFIG_JSON\" | jq -r '.post_plan // true'). For qa-gate-post-phase.sh: ENABLED=$(echo \"$CONFIG_JSON\" | jq -r '.post_phase // true'). The // true ensures missing key defaults to enabled (backward compat per architecture). (3) Read timeout override: TIMEOUT=$(echo \"$CONFIG_JSON\" | jq -r \".timeout_seconds // $DEFAULT_TIMEOUT\"). This allows qa_gates.timeout_seconds to override the script's DEFAULT_TIMEOUT. (4) Skip check: if [ \"$ENABLED\" = \"false\" ]; then echo '{\"gate\":\"skipped\",\"level\":\"post-task\",\"r\":\"SKIPPED\",\"dt\":\"'$(date +%Y-%m-%d)'\"}' (adjust level string per script); exit 0; fi. The skip JSON is valid and parseable by downstream consumers. (5) IMPORTANT per D1: Do NOT read config/defaults.json directly. Do NOT write to config/defaults.json. Only consume via resolve-qa-config.sh which handles config.json -> defaults.json fallback chain. Pattern reference: resolve-qa-config.sh from plan 04-03 uses jq // operator for backward compat.","ts":"File: tests/unit/qa-gate-post-task.bats, tests/unit/qa-gate-post-plan.bats, tests/unit/qa-gate-post-phase.bats (modify all three, add config toggle tests). For EACH test file, add these test cases: (1) 'skips with gate:skipped JSON when config toggle is false' -- mock resolve-qa-config.sh to output {\"post_task\":false} (or post_plan/post_phase for the respective script), run SUT, assert_success, verify jq '.gate' = skipped. (2) 'runs normally when config toggle is true' -- mock resolve-qa-config.sh to output {\"post_task\":true}, mock test-summary.sh, run SUT, verify gate != skipped. (3) 'defaults to enabled when resolve-qa-config.sh missing' -- ensure no mock resolve-qa-config.sh in PATH (or rename away), run SUT, verify gate runs (not skipped). (4) 'uses timeout from config when present' -- mock resolve-qa-config.sh with timeout_seconds:5, verify script uses 5s timeout. Total: 4 new tests per file, 12 new tests across all three files."}
{"id":"T2","tp":"auto","a":"Update scripts/validate-gates.sh: add post_task_qa and post_plan_qa entries to the case statement. post_task_qa entry: verify post-task gate result JSON exists for the specified task. post_plan_qa entry: verify post-plan gate result JSON exists for the specified plan. Both follow existing pattern of check_artifact_exists with fallback to step skip status.","f":["scripts/validate-gates.sh"],"td":["T1"],"v":"validate-gates.sh accepts --step post_task_qa and post_plan_qa, produces correct JSON output","done":"Validate-gates updated with new gate types","spec":"File: scripts/validate-gates.sh (modify). Location: Add two new entries to the case statement (lines 92-251), BEFORE the catch-all *) entry (line 247-250). (1) post_task_qa entry: ```\\npost_task_qa)\\n  # Entry: .qa-gate-results.jsonl contains post-task result for specified task\\n  if check_artifact_exists \"$PHASE_DIR/.qa-gate-results.jsonl\"; then\\n    # Verify at least one post-task entry exists\\n    _has_post_task=$(jq -r 'select(.gl==\"post-task\")' \"$PHASE_DIR/.qa-gate-results.jsonl\" 2>/dev/null | head -1) || true\\n    if [ -z \"$_has_post_task\" ]; then\\n      MISSING+=(\"post-task gate results in .qa-gate-results.jsonl\")\\n      GATE_RESULT=\"fail\"\\n    fi\\n  elif ! check_step_skipped \"post_task_qa\"; then\\n    MISSING+=(\".qa-gate-results.jsonl\")\\n    GATE_RESULT=\"fail\"\\n  fi\\n  ;;\\n```. (2) post_plan_qa entry: ```\\npost_plan_qa)\\n  # Entry: .qa-gate-results.jsonl contains post-plan result\\n  if check_artifact_exists \"$PHASE_DIR/.qa-gate-results.jsonl\"; then\\n    _has_post_plan=$(jq -r 'select(.gl==\"post-plan\")' \"$PHASE_DIR/.qa-gate-results.jsonl\" 2>/dev/null | head -1) || true\\n    if [ -z \"$_has_post_plan\" ]; then\\n      MISSING+=(\"post-plan gate results in .qa-gate-results.jsonl\")\\n      GATE_RESULT=\"fail\"\\n    fi\\n  elif ! check_step_skipped \"post_plan_qa\"; then\\n    MISSING+=(\".qa-gate-results.jsonl\")\\n    GATE_RESULT=\"fail\"\\n  fi\\n  ;;\\n```. Both entries: (a) First check .qa-gate-results.jsonl exists (using existing check_artifact_exists helper). (b) If exists, verify it contains entries with the correct gl (gate_level) value by filtering with jq select(). (c) If file missing, check if step was skipped (using existing check_step_skipped helper). (d) Follow existing patterns exactly: MISSING array, GATE_RESULT assignment, check_artifact_exists + check_step_skipped helpers. Key: These entries read from .qa-gate-results.jsonl (per architecture D3) not from individual result files.","ts":"File: tests/unit/validate-gates.bats (modify). Add new test cases following existing patterns in the file. Tests to add: (1) 'post_task_qa gate passes when .qa-gate-results.jsonl has post-task entry' -- create .qa-gate-results.jsonl with {\"gl\":\"post-task\",\"r\":\"PASS\"} line, run SUT --step post_task_qa --phase-dir $PHASE_DIR, assert_success. (2) 'post_task_qa gate fails when .qa-gate-results.jsonl missing' -- no file, run SUT, assert_failure, verify missing array mentions .qa-gate-results.jsonl. (3) 'post_task_qa gate fails when file exists but no post-task entries' -- create file with only post-plan entries, assert_failure. (4) 'post_task_qa gate passes when step is skipped' -- mk_exec_state_with_skip post_task_qa, assert_success. (5) 'post_plan_qa gate passes when .qa-gate-results.jsonl has post-plan entry' -- create file with post-plan entry, assert_success. (6) 'post_plan_qa gate fails when .qa-gate-results.jsonl missing' -- assert_failure. (7) 'post_plan_qa gate passes when step is skipped' -- mk_exec_state_with_skip post_plan_qa, assert_success. Total: 7 new test cases appended to existing file."}
{"id":"T3","tp":"auto","a":"Update tests/unit/validate-gates.bats: add tests for post_task_qa step (passes when gate result exists, fails when missing), post_plan_qa step (passes when gate result exists, fails when missing). Follow existing test patterns in the file. Minimum 4 new test cases.","f":["tests/unit/validate-gates.bats"],"td":["T2"],"v":"New tests pass, minimum 4 cases for the two new gate types","done":"Validate-gates tests updated","spec":"File: tests/unit/validate-gates.bats (modify). This task writes the tests described in T2's ts field. Location: Append after the last existing test (line 87, the security gate test). Follow the exact pattern from existing tests: setup uses mk_test_workdir + SUT + PHASE_DIR. Assertions use assert_success/assert_failure and jq parsing of output. Implement the 7 test cases from T2's ts field. Helper needed: create_gate_results() that writes a .qa-gate-results.jsonl file with specified entries. Example: create_gate_results() { local level=\"$1\" result=\"$2\"; echo \"{\\\"gl\\\":\\\"$level\\\",\\\"r\\\":\\\"$result\\\",\\\"dt\\\":\\\"2026-02-17\\\"}\" > \"$PHASE_DIR/.qa-gate-results.jsonl\"; }. Use mk_exec_state_with_skip for skip tests (existing helper). Verify JSON output gate field matches expected value for each test.","ts":""}
{"id":"T4","tp":"auto","a":"Write tests/integration/qa-gate-cascade.bats: end-to-end test of gate cascade. Setup creates a mock phase dir with plan.jsonl, summary.jsonl, and test fixtures. Test 1: run post-task gate (should pass). Test 2: run post-plan gate (should pass using post-task results). Test 3: run post-phase gate (should pass using post-plan results). Test 4: introduce test failure, verify post-task gate blocks. Test 5: verify cascade stops (post-plan not reached when post-task fails). Minimum 5 test cases.","f":["tests/integration/qa-gate-cascade.bats"],"td":["T3"],"v":"All 5 integration tests pass, cascade behavior verified","done":"QA gate cascade integration tests committed","spec":"File: tests/integration/qa-gate-cascade.bats (new). Framework: bats with load '../test_helper/common' and '../test_helper/fixtures'. Setup: mk_test_workdir. Create full mock environment: (1) PHASE_DIR=\"$TEST_WORKDIR/phase-test\", mkdir -p. (2) Create valid plan.jsonl: header with p:04 n:10 w:2 d:[] mh with tr/ar/kl, plus 2 task lines with id/tp/a/f/v/done/spec fields. (3) Create valid summary.jsonl: {s:complete,p:04,n:10,tc:2,tt:2,...}. (4) MOCK_DIR for test-summary.sh and validate-gates.sh mocks. (5) Create MOCK_DIR/test-summary.sh that echoes 'PASS (10 tests)' and exits 0 by default. Can be overridden per-test by writing different content. (6) Create MOCK_DIR/validate-gates.sh that outputs {\"gate\":\"pass\",\"step\":\"$2\",\"missing\":[]} (reads --step arg). (7) Create MOCK_DIR/resolve-qa-config.sh that outputs {\"post_task\":true,\"post_plan\":true,\"post_phase\":true,\"timeout_seconds\":30}. (8) export PATH=\"$MOCK_DIR:$PATH\". Test cases: (1) 'post-task gate passes with passing tests' -- run qa-gate-post-task.sh --phase-dir $PHASE_DIR --plan 04-10 --task T1 --scope, assert_success, verify .qa-gate-results.jsonl has 1 line with gl=post-task. (2) 'post-plan gate passes after post-task results exist' -- run qa-gate-post-plan.sh --phase-dir $PHASE_DIR --plan 04-10, assert_success, verify .qa-gate-results.jsonl has 2 lines (post-task + post-plan). (3) 'post-phase gate passes when all plans complete and gates pass' -- run qa-gate-post-phase.sh --phase-dir $PHASE_DIR, assert_success, verify .qa-gate-results.jsonl has 3 lines. (4) 'post-task gate blocks on test failure' -- overwrite mock test-summary.sh to echo 'FAIL (1/10 failed)' and exit 1, run qa-gate-post-task.sh, assert_failure, verify gate=fail in output. (5) 'cascade shows post-task failure prevents clean post-plan' -- after test 4's failure, .qa-gate-results.jsonl contains a FAIL entry. Run post-plan gate, check it still runs (post-plan is independent -- it runs its own test suite). Verify post-plan's test failure also detected. (6) 'config toggle skips gate in cascade' -- overwrite mock resolve-qa-config.sh to output {\"post_task\":false}, run qa-gate-post-task.sh, assert_success, verify gate=skipped. Scripts referenced by absolute path: SUT_POST_TASK=\"$SCRIPTS_DIR/qa-gate-post-task.sh\", SUT_POST_PLAN=\"$SCRIPTS_DIR/qa-gate-post-plan.sh\", SUT_POST_PHASE=\"$SCRIPTS_DIR/qa-gate-post-phase.sh\".","ts":""}
