{"p":"04","n":"07","t":"Post-plan and post-phase QA gate scripts","w":2,"d":["04-06"],"mh":{"tr":["Post-plan gate runs after all tasks in a plan complete, verifies summary.jsonl exists and tests pass","Post-phase gate runs full system verification including cross-plan consistency checks","Both gates produce structured JSON output matching qa-gate-post-task.sh schema","Post-phase gate integrates with existing validate-gates.sh for artifact completeness","Gates block progression: post-plan blocks next plan, post-phase blocks sign-off"],"ar":[{"p":"scripts/qa-gate-post-plan.sh","pv":"file exists and is executable","c":"Post-plan gate: verifies summary.jsonl, runs full test suite, checks must_have coverage"},{"p":"scripts/qa-gate-post-phase.sh","pv":"file exists and is executable","c":"Post-phase gate: runs validate-gates.sh for all steps, full test suite, cross-plan consistency"},{"p":"tests/unit/qa-gate-post-plan.bats","pv":"file exists","c":"Tests for post-plan gate covering plan completion verification"},{"p":"tests/unit/qa-gate-post-phase.bats","pv":"file exists","c":"Tests for post-phase gate covering full system verification"}],"kl":[{"fr":"scripts/qa-gate-post-plan.sh","to":"scripts/qa-gate-post-task.sh","vi":"Post-plan gate reuses test execution logic from post-task gate"},{"fr":"scripts/qa-gate-post-phase.sh","to":"scripts/validate-gates.sh","vi":"Post-phase gate calls validate-gates.sh for artifact completeness verification"},{"fr":"scripts/qa-gate-post-plan.sh level output","to":"references/qa-output-patterns.md","vi":"Output templates follow UX-defined patterns from 04-01"}]},"obj":"Create post-plan and post-phase QA gate scripts that verify plan completion and full system integrity respectively","sk":["commit"],"fm":["scripts/qa-gate-post-plan.sh","scripts/qa-gate-post-phase.sh","tests/unit/qa-gate-post-plan.bats","tests/unit/qa-gate-post-phase.bats"]}
{"id":"T1","tp":"auto","a":"Create scripts/qa-gate-post-plan.sh: accepts --phase-dir and --plan flags. Verifies plan summary.jsonl exists with s:complete. Runs full test suite via test-summary.sh. Checks must_have coverage from plan header mh field: verifies tr (truths) hold, ar (artifacts) exist, kl (key_links) resolve. Produces JSON {gate:pass|fail,level:post-plan,r:PASS|FAIL|PARTIAL,tests:{ps:N,fl:N},mh:{tr:N,ar:N,kl:N},dt:date}. Exit 1 on fail = blocks next plan. REQ-07 post-plan gate.","f":["scripts/qa-gate-post-plan.sh"],"v":"Script exists, is executable, verifies summary and must_haves, produces valid JSON","done":"Post-plan QA gate script committed","spec":"File: scripts/qa-gate-post-plan.sh (new, chmod +x). Shebang: #!/usr/bin/env bash. Use set -u. Structure: (1) jq dependency check (copy from validate-gates.sh lines 16-19). SCRIPT_DIR resolve (copy test-summary.sh pattern). DEFAULT_TIMEOUT=300 (per architecture D4: full suite for post-plan). (2) ARG PARSING: while [ $# -gt 0 ]; case --phase-dir, --plan, --timeout. PHASE_DIR required, PLAN_ID required. (3) SUMMARY VERIFICATION: SUMMARY_FILE=\"$PHASE_DIR/${PLAN_ID}.summary.jsonl\". Check [ -f \"$SUMMARY_FILE\" ] -- if missing, set gate=fail, add to FAILURES array. If exists, read status: STATUS=$(jq -r '.s // \"\"' \"$SUMMARY_FILE\"). If STATUS != complete, add to FAILURES. (4) TEST EXECUTION: Run full test suite (no --scope, per D4): timeout \"$TIMEOUT\" bash \"$SCRIPT_DIR/test-summary.sh\". Capture output and exit code. Parse PASS/FAIL counts same as qa-gate-post-task.sh. If test-summary.sh missing: warn, do not fail (fail-open on infra). (5) MUST_HAVE VERIFICATION: Read plan header: PLAN_HEADER=$(head -1 \"$PHASE_DIR/${PLAN_ID}.plan.jsonl\"). For tr (truths): TR_COUNT=$(echo \"$PLAN_HEADER\" | jq '.mh.tr | length'). TR_VERIFIED=0. For each truth: use Grep/file-check heuristic to verify (note: truths are human-readable strings, so verify best-effort -- check if referenced files exist, if key strings grep-match). For ar (artifacts): AR_COUNT=$(echo \"$PLAN_HEADER\" | jq '.mh.ar | length'). For each artifact: check path exists (jq '.mh.ar[].p'), verify condition (jq '.mh.ar[].pv' -- check file existence for 'file exists' type conditions). For kl (key_links): KL_COUNT=$(echo \"$PLAN_HEADER\" | jq '.mh.kl | length'). For each link: verify 'from' file and 'to' file both exist. (6) RESULT COMPUTATION: gate=pass if no failures AND tests pass AND summary complete. gate=fail if any critical failure. r=PARTIAL if tests pass but some must_haves fail. (7) JSON OUTPUT via jq -n: {gate:str, level:\"post-plan\", r:str, plan:\"$PLAN_ID\", tst:{ps:N,fl:N}, mh:{tr:N,ar:N,kl:N}, dur:N, dt:date}. (8) RESULT PERSISTENCE: Append to $PHASE_DIR/.qa-gate-results.jsonl using flock pattern (copy from qa-gate-post-task.sh). (9) EXIT: 0 on pass/partial, 1 on fail. Key patterns: flock from git-commit-serialized.sh. Path resolution from test-summary.sh. Summary parsing uses jq abbreviated keys per artifact-formats.md.","ts":"File: tests/unit/qa-gate-post-plan.bats (new). Framework: bats with load '../test_helper/common' and '../test_helper/fixtures'. Setup: mk_test_workdir, SUT=\"$SCRIPTS_DIR/qa-gate-post-plan.sh\", PHASE_DIR=\"$TEST_WORKDIR/phase-test\", mkdir -p \"$PHASE_DIR\". Helper: create_plan_and_summary() that writes a valid plan.jsonl header + task lines and a valid summary.jsonl with s:complete. Test cases (minimum 6): (1) 'passes when summary exists with s:complete and tests pass' -- create valid plan+summary, mock test-summary.sh returning PASS, assert_success, verify gate=pass. (2) 'fails when summary.jsonl missing' -- create plan but no summary, assert_failure, verify output mentions missing summary. (3) 'fails when summary has s:partial' -- create summary with s:partial, assert_failure. (4) 'verifies must_have artifacts exist' -- create plan with mh.ar pointing to a file, create that file, assert_success. (5) 'reports must_have artifact missing' -- create plan with mh.ar pointing to nonexistent file, verify mh counts in output show failure. (6) 'handles test failure by reporting fail' -- mock test-summary.sh returning FAIL, assert_failure, verify tst.fl > 0 in JSON output. (7) 'appends result to .qa-gate-results.jsonl' -- run gate, verify file exists with 1 jq-parseable line. Mock strategy: same as qa-gate-post-task.bats -- mock scripts dir in TEST_WORKDIR prepended to PATH."}
{"id":"T2","tp":"auto","a":"Create scripts/qa-gate-post-phase.sh: accepts --phase-dir flag. Runs validate-gates.sh for all 11 steps (reports which gates would pass/fail). Runs full test suite via test-summary.sh. Checks all plans have summary.jsonl with s:complete. Produces JSON {gate:pass|fail,level:post-phase,r:PASS|FAIL,steps:{passed:N,failed:N},tests:{ps:N,fl:N},plans:{complete:N,total:N},dt:date}. Exit 1 on fail = blocks sign-off. REQ-07 post-phase gate formalization.","f":["scripts/qa-gate-post-phase.sh"],"td":["T1"],"v":"Script exists, calls validate-gates.sh, checks all plans complete, produces valid JSON","done":"Post-phase QA gate script committed","spec":"File: scripts/qa-gate-post-phase.sh (new, chmod +x). Shebang: #!/usr/bin/env bash. Use set -u. Structure: (1) jq dependency check. SCRIPT_DIR resolve. DEFAULT_TIMEOUT=300 (per D4). (2) ARG PARSING: --phase-dir (required), --timeout (optional). (3) PLAN COMPLETENESS CHECK: Glob all plan files: PLAN_FILES=$(ls \"$PHASE_DIR\"/*.plan.jsonl 2>/dev/null). TOTAL_PLANS=0, COMPLETE_PLANS=0. For each plan file: extract plan_id from header (p + n fields via jq). Check summary exists: [ -f \"$PHASE_DIR/${PLAN_ID}.summary.jsonl\" ]. If exists, check s field: STATUS=$(jq -r '.s // \"\"' \"$PHASE_DIR/${PLAN_ID}.summary.jsonl\"). Increment counters. (4) GATE VALIDATION: Run validate-gates.sh for each step in the 11-step workflow. STEPS=(critique architecture planning design_review test_authoring implementation code_review qa security signoff). STEPS_PASSED=0, STEPS_FAILED=0. For each step: result=$(bash \"$SCRIPT_DIR/validate-gates.sh\" --step \"$step\" --phase-dir \"$PHASE_DIR\" 2>/dev/null) || true. Parse gate field from result JSON. Count pass/fail. Note: research step may not be in validate-gates.sh yet (only 10 entries) -- handle unknown step gracefully. (5) TEST EXECUTION: Run full suite: timeout \"$TIMEOUT\" bash \"$SCRIPT_DIR/test-summary.sh\". Parse output same as other gates. Fail-open on missing infra. (6) RESULT COMPUTATION: gate=pass if ALL plans complete AND ALL gate steps pass AND tests pass. gate=fail otherwise. (7) JSON OUTPUT via jq -n: {gate:str, level:\"post-phase\", r:str, ph:\"$(basename \"$PHASE_DIR\" | cut -d- -f1)\", steps:{ps:N,fl:N}, tst:{ps:N,fl:N}, plans:{complete:N,total:N}, dur:N, dt:date}. (8) RESULT PERSISTENCE: Append to .qa-gate-results.jsonl with flock. (9) EXIT: 0 on pass, 1 on fail. Key patterns: validate-gates.sh invocation pattern, flock from git-commit-serialized.sh. This is the fast automated pre-check (script-only, no LLM) before Step 9 QA agent spawn per architecture C11 disposition.","ts":"File: tests/unit/qa-gate-post-phase.bats (new). Framework: bats with common + fixtures helpers. Setup: mk_test_workdir, SUT=\"$SCRIPTS_DIR/qa-gate-post-phase.sh\", PHASE_DIR=\"$TEST_WORKDIR/phase-test\", mkdir -p \"$PHASE_DIR\". Test cases (minimum 6): (1) 'passes when all plans complete and gates pass' -- create 2 plans with summaries (s:complete), mock validate-gates.sh returning pass for all steps, mock test-summary.sh returning PASS, assert_success, verify gate=pass. (2) 'fails when some plans incomplete' -- create 2 plans but only 1 summary, assert_failure, verify plans.complete < plans.total. (3) 'fails when validate-gates reports failures' -- mock validate-gates.sh returning fail for qa step, verify steps.fl > 0 in output. (4) 'fails when test suite fails' -- mock test-summary.sh returning FAIL, assert_failure. (5) 'reports correct plan counts in JSON' -- create 3 plans with 2 summaries, verify plans.total=3 and plans.complete=2. (6) 'handles no plan files gracefully' -- empty phase dir, run gate, verify graceful behavior (fail with plans.total=0). (7) 'appends to .qa-gate-results.jsonl' -- run gate, verify persistence file. Mock strategy: for validate-gates.sh, create mock in MOCK_DIR that returns pass JSON for all steps. For test-summary.sh, same mock pattern as other gate tests."}
{"id":"T3","tp":"auto","a":"Write tests/unit/qa-gate-post-plan.bats: test plan-complete scenario, plan-incomplete scenario (missing summary), must_have verification (truth holds, artifact exists, key_link resolves), test failure scenario. Minimum 6 test cases.","f":["tests/unit/qa-gate-post-plan.bats"],"td":["T1"],"v":"All tests pass, minimum 6 cases","done":"Post-plan gate tests committed","spec":"File: tests/unit/qa-gate-post-plan.bats (new, created by T1's ts). This task implements the test file described in T1's ts field. Follow the exact test cases specified in T1 ts: 7 tests covering pass/fail/summary-missing/summary-partial/must-have-artifact/must-have-missing/persistence. Setup helper create_plan_and_summary(): write plan header with mh field containing tr, ar, kl arrays, write 1-2 task lines, write summary.jsonl with s:complete. Mock test-summary.sh: create in MOCK_DIR, echo 'PASS (50 tests)', exit 0. All assertions use jq to parse JSON output. Each test verifies both exit code and JSON structure.","ts":""}
{"id":"T4","tp":"auto","a":"Write tests/unit/qa-gate-post-phase.bats: test all-plans-complete scenario, partial-plans scenario, gate validation pass/fail, full-test-suite pass/fail. Minimum 6 test cases.","f":["tests/unit/qa-gate-post-phase.bats"],"td":["T2"],"v":"All tests pass, minimum 6 cases","done":"Post-phase gate tests committed","spec":"File: tests/unit/qa-gate-post-phase.bats (new, created by T2's ts). This task implements the test file described in T2's ts field. Follow the exact test cases specified in T2 ts: 7 tests covering all-complete/partial/gate-failures/test-failures/plan-counts/no-plans/persistence. Mock strategy: create MOCK_DIR with mock validate-gates.sh (configurable pass/fail per step) and mock test-summary.sh. Helper mk_plan_with_summary(): creates plan.jsonl header + summary.jsonl with s:complete for a given plan_id. All JSON assertions via jq -r.","ts":""}
