---
phase: 4
plan: 2
title: "Tier 1 mtime caching in compile-context"
wave: 1
depends_on: []
must_haves:
  - compile-context skips tier 1+2 recompilation when source files unchanged
  - Cache stored at /tmp/yolo-tier-cache-{uid}/
  - SHA256 hash validation on cache hit
  - Measurable speedup on repeated invocations
---

# Plan 04-02: Tier 1 mtime caching in compile-context

## Goal
Add mtime-based caching to `tier_context.rs` so that Tier 1 (SHARED BASE) and Tier 2 (ROLE FAMILY) content is not recomputed when the underlying source files have not changed. Since Tier 1 and Tier 2 are deterministic functions of their input files, caching by file mtime avoids redundant reads and SHA256 computations during multi-agent parallel execution.

## Context
`yolo-mcp-server/src/commands/tier_context.rs` currently reads Tier 1 files (CONVENTIONS.md, STACK.md) and Tier 2 files (ARCHITECTURE.md, ROADMAP.md, REQUIREMENTS.md) on every `compile-context` invocation. During a typical phase execution with 3-5 parallel Dev agents, Tier 1 is computed identically 3-5 times. Tier 2 is computed identically for all agents in the same role family.

The cache uses `/tmp/yolo-tier-cache-{uid}/` with files `tier1.cache` and `tier2-{family}.cache`. Each cache file stores the cached content plus a JSON header with source file mtimes. On cache hit, the stored content is returned without reading source files.

## Files Modified
- `yolo-mcp-server/src/commands/tier_context.rs` — add mtime caching to build_tier1 and build_tier2
- `yolo-mcp-server/src/cli/router.rs` — no changes needed (calls build_tiered_context which benefits automatically)

## Tasks

### Task 1: Implement mtime cache for Tier 1
In `tier_context.rs`, modify `build_tier1` to:
1. Compute the max mtime across all Tier 1 source files (CONVENTIONS.md, STACK.md in `planning_dir/codebase/`)
2. Check cache file at `/tmp/yolo-tier-cache-{uid}/tier1.cache` where uid = `libc::getuid()`
3. Cache file format: first line is JSON `{"mtime_secs": N, "hash": "sha256hex"}`, rest is cached content
4. If cache exists AND stored mtime_secs >= max source mtime AND hash matches SHA256 of stored content: return cached content (cache hit)
5. Otherwise: build content normally (existing logic), write to cache file, return content
6. If any cache operation fails (permissions, corrupt file): fall through to normal build (fail-open)

### Task 2: Implement mtime cache for Tier 2
Same pattern for `build_tier2`:
1. Compute max mtime across Tier 2 source files for the given family
2. Cache file: `/tmp/yolo-tier-cache-{uid}/tier2-{family}.cache`
3. Same format and validation as Tier 1
4. Cache key includes family name to prevent cross-family cache hits

### Task 3: Add cache invalidation helper
Add a public function `invalidate_tier_cache()` that:
1. Removes all files in `/tmp/yolo-tier-cache-{uid}/`
2. Returns Result<(), String> (fail-open)
3. Wire it to the CLI router as `yolo invalidate-tier-cache` (simple one-line dispatch)

### Task 4: Write Rust unit tests
Add tests to the existing `mod tests` in `tier_context.rs`:
1. `test_tier1_cache_hit` — build twice with same files, second call should produce identical output
2. `test_tier1_cache_invalidation` — modify source file mtime, verify cache is not used
3. `test_tier2_cache_per_family` — verify planning and execution families have separate caches
4. `test_cache_corruption_fallback` — write corrupt cache file, verify normal build still works
5. `test_invalidate_tier_cache` — verify cache files are removed
