{"p":"01-02","n":"Department TOON Template System","t":4,"w":1,"mh":["REQ-01","REQ-07"],"obj":"Create TOON templates for all 3 departments with per-project-type variable sections, and build generate-department-toons.sh to render them from detect-stack.sh output.","sk":["commit"],"fm":["config/department-templates/backend.toon.tmpl","config/department-templates/frontend.toon.tmpl","config/department-templates/uiux.toon.tmpl","scripts/generate-department-toons.sh"]}
{"id":"01-02-01","n":"Create department TOON templates","f":["config/department-templates/backend.toon.tmpl","config/department-templates/frontend.toon.tmpl","config/department-templates/uiux.toon.tmpl"],"d":[],"ac":["Three template files exist in config/department-templates/","Each template preserves the static structure from references/departments/*.toon (roster, structure, workflow, cross_dept, dir_isolation)","Templates use placeholder markers (e.g. {{LANGUAGE}}, {{TESTING_FRAMEWORK}}, {{CONVENTIONS}}, {{UX_FOCUS}}) for project-type-variable sections","Backend template: language, testing framework, tooling conventions are parameterized","Frontend template: framework, component lib, CSS approach are parameterized","UX template: ux_focus section fully parameterized per project interface type (web/CLI/API/library/mobile/monorepo)","Templates are valid TOON when rendered (no raw placeholders in output)"],"spec":"Create directory config/department-templates/ (mkdir -p). Create 3 template files. These are NOT copies of references/departments/*.toon -- they contain ONLY the conventions/focus sections that will be generated per project type. The structural sections (roster, structure, workflow, cross_dept, dir_isolation) stay in references/departments/ and are NOT duplicated in templates (per architecture D1: two-layer model). Template format is TOON with placeholder markers. (1) config/department-templates/backend.toon.tmpl -- Content: 'backend_conventions:\\n  desc: Project-specific backend conventions (generated)\\n\\n  language: {{BACKEND_LANGUAGE}}\\n  testing: {{BACKEND_TESTING}}\\n  tooling: {{BACKEND_TOOLING}}\\n  scripts: kebab-case .sh files, set -euo pipefail for critical scripts\\n  commits: {type}({scope}): {desc}, one commit per task\\n  artifacts: JSONL with abbreviated keys'. The last 3 lines (scripts, commits, artifacts) are STATIC -- they never change per project type. Only language, testing, tooling are placeholders. (2) config/department-templates/frontend.toon.tmpl -- Content: 'frontend_conventions:\\n  desc: Project-specific frontend conventions (generated)\\n\\n  framework: {{FRONTEND_FRAMEWORK}}\\n  component_lib: {{FRONTEND_COMPONENT_LIB}}\\n  css: {{FRONTEND_CSS}}\\n  testing: {{FRONTEND_TESTING}}\\n  a11y: WCAG 2.1 AA minimum, aria attributes, keyboard navigation\\n  perf: Bundle size monitoring, code splitting, lazy loading\\n  commits: {type}({scope}): {desc}, one commit per task\\n  artifacts: JSONL with abbreviated keys'. Static lines: a11y, perf, commits, artifacts. Placeholders: framework, component_lib, css, testing. (3) config/department-templates/uiux.toon.tmpl -- Content: 'uiux_conventions:\\n  desc: Project-specific UX conventions (generated)\\n\\n  focus_areas:\\n{{UX_FOCUS_AREAS}}\\n  testing_approach: {{UX_TESTING_APPROACH}}\\n  artifact_types:\\n{{UX_ARTIFACT_TYPES}}\\n  vocabulary:\\n{{UX_VOCABULARY}}\\n  a11y: WCAG 2.1 AA minimum, screen reader testing, color contrast\\n  commits: {type}({scope}): {desc}, one commit per task\\n  artifacts: JSONL with abbreviated keys'. UX template is special: focus_areas, artifact_types, and vocabulary are multi-line blocks (per D5: full replacement blocks, not single variables). {{UX_FOCUS_AREAS}} expands to indented list items like '    - UI design\\n    - component specs'. {{UX_VOCABULARY}} expands to indented key-value pairs. Static lines: a11y, commits, artifacts. Placeholder naming convention: {{DEPT_FIELD}} where DEPT is BACKEND/FRONTEND/UX and FIELD maps to the field name. All placeholders use double curly braces. Template files should have a comment line at top: '# Template for {dept} department conventions. Generated by generate-department-toons.sh'. Edge cases: templates must NOT contain roster, hierarchy, workflow, or dir_isolation sections -- those are structural and remain in references/departments/*.toon ONLY.","ts":"Validation is structural (templates exist with correct placeholders). Covered by generate-department-toons.bats in task 01-02-04. For this task: verify each template file exists, contains expected placeholder markers (grep for '{{' returns matches), and does NOT contain roster/workflow sections (grep -c 'roster:' returns 0)."}
{"id":"01-02-02","n":"Create generate-department-toons.sh script","f":["scripts/generate-department-toons.sh"],"d":["01-02-01"],"ac":["Script accepts project-dir argument (default: current dir)","Calls detect-stack.sh to get project_type and detected_stack","Reads project-types.json for department mappings and ux_focus","Reads templates from config/department-templates/","Renders templates by replacing placeholders with project-specific values","Writes generated TOONs to .yolo-planning/departments/{backend,frontend,uiux}.toon","Uses set -euo pipefail, jq for JSON parsing, no external dependencies","Script is idempotent: re-running overwrites with fresh output"],"spec":"Create scripts/generate-department-toons.sh. Header: #!/bin/bash with comment block describing purpose, usage (bash generate-department-toons.sh [project-dir] [--force]), output (.yolo-planning/departments/*.toon). Use set -euo pipefail. Structure: (1) jq dependency check (same pattern as detect-stack.sh lines 12-15). (2) Parse args: PROJECT_DIR=\"${1:-.}\", check for --force flag in any position. (3) Resolve paths: SCRIPT_DIR=$(cd \"$(dirname \"$0\")\" && pwd), PROJECT_TYPES=\"$SCRIPT_DIR/../config/project-types.json\", TEMPLATES_DIR=\"$SCRIPT_DIR/../config/department-templates\", OUTPUT_DIR=\"$PROJECT_DIR/.yolo-planning/departments\". (4) Validate inputs: check PROJECT_TYPES exists (exit 1 with JSON error if not), check TEMPLATES_DIR exists. (5) Call detect-stack.sh: DETECT_OUTPUT=$(bash \"$SCRIPT_DIR/detect-stack.sh\" \"$PROJECT_DIR\"). Extract PROJECT_TYPE=$(echo \"$DETECT_OUTPUT\" | jq -r '.project_type'). If empty or null, default to 'generic'. (6) Hash check (placeholder -- full implementation in 01-04-01): CURRENT_HASH=$(echo \"$DETECT_OUTPUT\" | shasum -a 256 | cut -d' ' -f1). If [ -f \"$OUTPUT_DIR/.stack-hash\" ] && [ \"$(cat \"$OUTPUT_DIR/.stack-hash\")\" = \"$CURRENT_HASH\" ] && [ \"$FORCE\" != true ]; then echo 'TOONs up to date' and exit 0. (7) Create output dir: mkdir -p \"$OUTPUT_DIR\". (8) Lookup conventions from project-types.json: use jq to extract the matching type object: TYPE_DATA=$(jq --arg t \"$PROJECT_TYPE\" '.types[] | select(.id == $t)' \"$PROJECT_TYPES\"). If empty (type not found), fallback: TYPE_DATA=$(jq '.types[] | select(.id == \"generic\")' \"$PROJECT_TYPES\"). (9) Extract values using jq: BACKEND_LANGUAGE=$(echo \"$TYPE_DATA\" | jq -r '.department_conventions.backend.language'), BACKEND_TESTING, BACKEND_TOOLING, FRONTEND_FRAMEWORK, FRONTEND_COMPONENT_LIB, FRONTEND_CSS, FRONTEND_TESTING. For UX multi-line blocks, use jq to format: UX_FOCUS_AREAS=$(echo \"$TYPE_DATA\" | jq -r '.ux_focus.focus_areas[] | \"    - \" + .'), UX_TESTING_APPROACH, UX_ARTIFACT_TYPES=$(echo \"$TYPE_DATA\" | jq -r '.ux_focus.artifact_types[] | \"    - \" + .'), UX_VOCABULARY=$(echo \"$TYPE_DATA\" | jq -r '.ux_focus.vocabulary | to_entries[] | \"    \" + .key + \": \" + .value'). (10) Render templates. Do NOT use sed s/// for substitution (risk R1: special chars break sed). Instead use a render_template() function that reads template line by line and uses bash parameter substitution or a heredoc approach. Safest method: for each template, read the file, then use sed with different delimiters or (better) use awk: awk -v var=\"value\" '{gsub(/{{PLACEHOLDER}}/, var)}1'. For multi-line replacements (UX_FOCUS_AREAS, UX_ARTIFACT_TYPES, UX_VOCABULARY), write the expanded content to temp files and use awk to insert. Render backend: read backend.toon.tmpl, replace {{BACKEND_LANGUAGE}}, {{BACKEND_TESTING}}, {{BACKEND_TOOLING}}, write to $OUTPUT_DIR/backend.toon. Render frontend: same pattern. Render uiux: replace single-line placeholders first, then multi-line blocks. (11) Write hash: echo \"$CURRENT_HASH\" > \"$OUTPUT_DIR/.stack-hash\". (12) Output summary to stdout: echo \"Generated department TOONs for project_type=$PROJECT_TYPE in $OUTPUT_DIR\". Exit 0. Error handling: if any jq extraction returns null/empty, use sensible defaults (e.g. 'per project' for language). The script must be idempotent -- running twice produces identical output. All file writes go to .yolo-planning/departments/ only (ephemeral, not committed, per D6). Script must work on macOS (shasum not sha256sum -- use shasum -a 256 which works on both macOS and Linux).","ts":"Tests in task 01-02-04 cover this. Key verification: (a) script runs without error on a web-app fixture. (b) output files exist in .yolo-planning/departments/. (c) backend.toon contains project-specific language (not placeholder). (d) no raw {{...}} markers in output. (e) .stack-hash file created."}
{"id":"01-02-03","n":"Map UX department to project interface type","f":["config/project-types.json","config/department-templates/uiux.toon.tmpl"],"d":["01-02-01","01-02-02"],"ac":["UX TOON generated for web-app focuses on: UI design, component specs, design tokens, responsive breakpoints","UX TOON generated for cli-tool focuses on: help text quality, error output formatting, progress indicators, user prompts","UX TOON generated for api-service focuses on: API documentation, OpenAPI specs, developer experience, error response design","UX TOON generated for library focuses on: API surface design, code examples, README quality, type documentation","UX TOON generated for mobile-app focuses on: UI design, gesture interactions, platform conventions, adaptive layouts","UX TOON generated for monorepo focuses on: per-package type detection, shared design system, cross-package consistency","Each ux_focus mapping is sourced from config/project-types.json, not hardcoded in the script"],"spec":"This task verifies and refines the ux_focus mappings already defined in config/project-types.json (task 01-01-01) and ensures the uiux.toon.tmpl (task 01-02-01) renders them correctly via generate-department-toons.sh (task 01-02-02). Modifications to config/project-types.json: review each type's ux_focus block and ensure the focus_areas arrays match the AC exactly. (1) web-app.ux_focus.focus_areas must include: 'UI design', 'component specs', 'design tokens', 'responsive breakpoints', 'interaction patterns'. (2) cli-tool.ux_focus.focus_areas must include: 'help text quality', 'error output formatting', 'progress indicators', 'user prompts'. Also add 'man page conventions' per architecture D5. (3) api-service.ux_focus.focus_areas must include: 'API documentation', 'OpenAPI specs', 'developer experience', 'error response design'. Add 'rate limiting UX' per architecture. (4) library.ux_focus.focus_areas must include: 'API surface design', 'code examples', 'README quality', 'type documentation'. Add 'changelog maintenance'. (5) mobile-app.ux_focus.focus_areas must include: 'UI design', 'gesture interactions', 'platform conventions', 'adaptive layouts'. Add 'accessibility'. (6) monorepo.ux_focus.focus_areas must include: 'per-package type detection', 'shared design system', 'cross-package consistency'. Add 'workspace navigation'. Modifications to config/department-templates/uiux.toon.tmpl: ensure the multi-line placeholder blocks {{UX_FOCUS_AREAS}}, {{UX_ARTIFACT_TYPES}}, {{UX_VOCABULARY}} are positioned correctly and generate-department-toons.sh produces clean indented output for each. The rendered uiux.toon for cli-tool should look like: 'uiux_conventions:\\n  desc: Project-specific UX conventions (generated)\\n\\n  focus_areas:\\n    - help text quality\\n    - error output formatting\\n    - progress indicators\\n    - user prompts\\n    - man page conventions\\n  testing_approach: CLI output validation + error message review\\n  artifact_types:\\n    - help-text-spec.md\\n    - error-messages.jsonl\\n  vocabulary:\\n    interface: CLI\\n    user: CLI user\\n    layout: command structure\\n  a11y: ...'. Validation: run generate-department-toons.sh on a fixture for each of the 6 named types and inspect the generated uiux.toon. Each must contain the correct focus_areas list. No hardcoded type checks in the script -- all data flows from project-types.json.","ts":"Covered by tests/unit/generate-department-toons.bats in task 01-02-04. Specifically the tests verifying UX TOON content per type: (a) web-app uiux.toon contains 'design tokens'. (b) cli-tool uiux.toon contains 'help text quality'. (c) api-service uiux.toon contains 'OpenAPI specs'. (d) library uiux.toon contains 'API surface design'. Minimum 4 type-specific UX assertions."}
{"id":"01-02-04","n":"Add TOON generation tests","f":["tests/unit/generate-department-toons.bats"],"d":["01-02-02","01-02-03"],"ac":["BATS test validates TOON generation for at least 3 project types (web-app, cli-tool, library)","Tests verify generated backend.toon contains correct language/testing conventions per type","Tests verify generated uiux.toon contains correct ux_focus section per type","Tests verify no raw placeholder markers remain in generated output","Tests verify output directory .yolo-planning/departments/ is created","Tests verify idempotency: second run produces identical output"],"spec":"Create tests/unit/generate-department-toons.bats. Follow exact pattern from tests/unit/detect-stack.bats for setup and helpers. Header: #!/usr/bin/env bats with comment block. setup() function: load '../test_helper/common', '../test_helper/fixtures', '../test_helper/mock_stdin', mk_test_workdir, SUT=\"$SCRIPTS_DIR/generate-department-toons.sh\", export CLAUDE_CONFIG_DIR=\"$TEST_WORKDIR/mock-claude\", mkdir -p \"$CLAUDE_CONFIG_DIR/skills\". Also create .yolo-planning dir: mkdir -p \"$TEST_WORKDIR/.yolo-planning\". Helper: run_generate() { run bash -c \"cd '$TEST_WORKDIR' && CLAUDE_CONFIG_DIR='$CLAUDE_CONFIG_DIR' bash '$SUT' '$TEST_WORKDIR'\"; }. Helper: mk_webapp_fixture() { cat > \"$TEST_WORKDIR/package.json\" <<'EOF'\\n{\"dependencies\":{\"react\":\"^18\",\"react-dom\":\"^18\"}}\\nEOF\\n}. Helper: mk_cli_fixture() { mkdir -p \"$TEST_WORKDIR/bin\" \"$TEST_WORKDIR/scripts\"; touch \"$TEST_WORKDIR/scripts/run.sh\"; }. Helper: mk_library_fixture() { mkdir -p \"$TEST_WORKDIR/src\"; touch \"$TEST_WORKDIR/Cargo.toml\" \"$TEST_WORKDIR/src/lib.rs\"; }. Tests (minimum 12): (1) '@test \"creates output directory\"' -- mk_webapp_fixture, run_generate, assert_success, assert_file_exists \"$TEST_WORKDIR/.yolo-planning/departments/backend.toon\". (2) '@test \"generates all three department TOONs\"' -- mk_webapp_fixture, run_generate, assert_success, assert_file_exists for backend.toon, frontend.toon, uiux.toon. (3) '@test \"web-app backend.toon contains TypeScript\"' -- mk_webapp_fixture, run_generate, assert_success, assert_file_contains \"$TEST_WORKDIR/.yolo-planning/departments/backend.toon\" 'TypeScript'. (4) '@test \"web-app uiux.toon contains design tokens\"' -- mk_webapp_fixture, run_generate, assert_file_contains ...uiux.toon 'design tokens'. (5) '@test \"cli-tool backend.toon contains Bash\"' -- mk_cli_fixture, run_generate, assert_file_contains ...backend.toon 'Bash'. (6) '@test \"cli-tool uiux.toon contains help text quality\"' -- mk_cli_fixture, run_generate, assert_file_contains ...uiux.toon 'help text quality'. (7) '@test \"library backend.toon contains correct language\"' -- mk_library_fixture, run_generate, assert_file_contains for language reference (Rust since Cargo.toml). (8) '@test \"no raw placeholders in backend.toon\"' -- mk_webapp_fixture, run_generate, assert_file_not_contains ...backend.toon '{{'. (9) '@test \"no raw placeholders in frontend.toon\"' -- same, for frontend.toon. (10) '@test \"no raw placeholders in uiux.toon\"' -- same, for uiux.toon. (11) '@test \"idempotent: second run produces identical output\"' -- mk_webapp_fixture, run_generate, cp backend.toon to /tmp/first, run_generate again, diff first vs current (use assert_equal_files or cmp). (12) '@test \"creates .stack-hash file\"' -- mk_webapp_fixture, run_generate, assert_file_exists .../.stack-hash. (13) '@test \"generic type generated for empty project\"' -- empty TEST_WORKDIR (no fixtures), run_generate, assert_success, assert_file_exists ...backend.toon. Use bats-file assertions (assert_file_exists, assert_file_contains, assert_file_not_contains) which are available via the test helper.","ts":"This IS the test task. The test file itself is the deliverable. Verify by running: bats tests/unit/generate-department-toons.bats -- all tests should pass. Minimum 12 tests covering 3 project types, placeholder absence, idempotency, and output directory creation."}
