{"p":"03","n":"01","t":"Task coordination patterns and schemas","w":1,"d":[],"xd":[{"p":"02","n":"02","a":"references/teammate-api-patterns.md","r":"Existing patterns file to extend with TaskCreate/TaskList/TaskUpdate sections"},{"p":"02","n":"03","a":"references/handoff-schemas.md","r":"Existing schemas file to extend with task coordination message types"}],"mh":{"tr":["TaskCreate maps plan.jsonl tasks to shared task list items with dependency chains from d field","TaskList returns available unblocked tasks filtered by status and assignee","TaskUpdate supports claim (assign to self) and complete (mark done with commit hash) operations","All new schemas have type discriminator matching existing handoff-schemas.md pattern","task_claim and task_complete schemas reference plan_id and task_id fields","td (task_depends) field is optional string[] in Plan Task schema for intra-plan ordering","git-commit-serialized.sh uses flock on .git/yolo-commit.lock with 5-retry exponential backoff","compute-dev-count.sh outputs min(available, 5) with input validation","resolve-task-deps.sh reads plan.jsonl and outputs task execution order JSON, detects circular deps"],"ar":[{"p":"references/teammate-api-patterns.md","pv":"## Task Coordination","c":"new section documenting TaskCreate, TaskList, TaskUpdate patterns for shared task list"},{"p":"references/teammate-api-patterns.md","pv":"## Dynamic Dev Scaling","c":"new section documenting min(available_unblocked_tasks, 5) formula"},{"p":"references/handoff-schemas.md","pv":"task_claim","c":"new schema for Dev claiming a task from shared list"},{"p":"references/handoff-schemas.md","pv":"task_complete","c":"new schema for Dev reporting task completion to Lead"},{"p":"references/handoff-schemas.md","pv":"summary_aggregation","c":"new schema for Lead aggregating Dev results into summary.jsonl"},{"p":"references/artifact-formats.md","pv":"td","c":"Plan Task schema gains optional td (task_depends) field"},{"p":"scripts/git-commit-serialized.sh","pv":"flock","c":"flock-based serialized git commit wrapper with exponential backoff"},{"p":"scripts/compute-dev-count.sh","pv":"min(available, 5)","c":"testable Dev scaling formula script"},{"p":"scripts/resolve-task-deps.sh","pv":"resolve-task-deps","c":"testable task dependency resolution script"}],"kl":[{"fr":"references/teammate-api-patterns.md ## Task Coordination","to":"references/handoff-schemas.md ## task_claim","vi":"patterns reference schemas by type name"},{"fr":"references/teammate-api-patterns.md ## Dynamic Dev Scaling","to":"references/execute-protocol.md Step 6","vi":"scaling formula referenced by implementation step"},{"fr":"references/teammate-api-patterns.md ## Task Coordination","to":"references/artifact-formats.md td field","vi":"task coordination references td field semantics"},{"fr":"scripts/compute-dev-count.sh","to":"references/teammate-api-patterns.md ## Dynamic Dev Scaling","vi":"script is canonical implementation of scaling formula"},{"fr":"scripts/resolve-task-deps.sh","to":"references/artifact-formats.md td field","vi":"script resolves td and d field dependencies"}]},"obj":"Define TaskCreate/TaskList/TaskUpdate patterns for shared task coordination, add task_claim/task_complete/summary_aggregation schemas to handoff-schemas.md, add td field to artifact-formats.md Plan Task schema, create git-commit-serialized.sh and testable helper scripts (REQ-03)","sk":["commit"],"fm":["references/teammate-api-patterns.md","references/handoff-schemas.md","references/artifact-formats.md","scripts/git-commit-serialized.sh","scripts/compute-dev-count.sh","scripts/resolve-task-deps.sh"],"auto":true}
{"id":"T1","tp":"auto","a":"Add ## Task Coordination section to teammate-api-patterns.md documenting TaskCreate for mapping plan.jsonl tasks to shared task list items with dependency chains from plan d field, TaskList for querying available tasks, and TaskUpdate for claiming/completing tasks. Include plan-to-task mapping algorithm. Document file-overlap check algorithm: Lead maintains claimed_files set, tasks whose f field intersects claimed_files are filtered from TaskList results.","f":["references/teammate-api-patterns.md"],"v":"File contains ## Task Coordination section with TaskCreate, TaskList, TaskUpdate subsections and file-overlap algorithm","done":"Task coordination patterns documented with plan-to-task mapping and file-overlap algorithm","spec":"Modify file: references/teammate-api-patterns.md. Insert a new ## Task Coordination (when team_mode=teammate) section AFTER the existing ## Task-Only Agents section (after line 163) and BEFORE the ## Task Mode Fallback section (currently at line 168). The new section must contain exactly 3 subsections: ### TaskCreate (Plan-to-Task Mapping), ### TaskList (Available Task Query), ### TaskUpdate (Claim and Complete). Content requirements per subsection: (1) TaskCreate: Lead reads plan.jsonl tasks (lines 2+), for each task creates a shared task list item with fields: task_id (from id field), plan_id (from header p-n), action (from a field), files (from f field), status='available', assignee=null, blocked_by (from td field if present, else empty). Map plan-level d field: if plan B depends on plan A, ALL tasks in plan B have blocked_by=[all tasks in plan A]. Include a JSON code block example showing TaskCreate call with these fields. (2) TaskList: Dev queries for tasks where status='available' AND assignee=null AND blocked_by is empty (all dependencies resolved). Lead filters results to EXCLUDE tasks whose f field intersects the claimed_files set (file-overlap check). Document the claimed_files algorithm: Lead maintains a Set<string> called claimed_files. On task_claim event: add all entries from task.f to claimed_files. On task_complete event: remove all entries from task.f from claimed_files. Before returning TaskList results: for each candidate task, check if any entry in task.f exists in claimed_files; if yes, exclude that task from results. Include a pseudocode block for the filtering algorithm. (3) TaskUpdate: Dev calls with task_id and one of: {status:'claimed', assignee:self} for claiming, or {status:'complete', commit:hash} for completion. Include JSON code block examples for both. Add a team_mode=teammate guard note at the top of the section: 'This section is active ONLY when team_mode=teammate.' Cross-reference: 'See references/handoff-schemas.md for task_claim and task_complete message schemas.' and 'See references/artifact-formats.md for td (task_depends) field definition.'","ts":""}
{"id":"T2","tp":"auto","a":"Add ## Dynamic Dev Scaling section to teammate-api-patterns.md documenting the formula: dev_count = min(available_unblocked_tasks, 5). Include Lead algorithm for computing available tasks, spawning Devs, and monitoring task list for newly unblocked tasks as dependencies complete. Reference scripts/compute-dev-count.sh as canonical implementation.","f":["references/teammate-api-patterns.md"],"v":"File contains ## Dynamic Dev Scaling with min(N,5) formula, Lead monitoring loop, and compute-dev-count.sh reference","done":"Dynamic Dev scaling algorithm documented with max 5 cap and script reference","spec":"Modify file: references/teammate-api-patterns.md. Insert a new ## Dynamic Dev Scaling (when team_mode=teammate) section AFTER the ## Task Coordination section added by T1 and BEFORE ## Task Mode Fallback. Content must include: (1) The formula: dev_count = min(available_unblocked_tasks, 5). The cap of 5 prevents resource exhaustion. (2) Lead algorithm as a numbered list: Step 1: Lead counts available_unblocked_tasks from TaskList (status=available, no blocked_by, no file-overlap). Step 2: Lead calls scripts/compute-dev-count.sh --available N to get dev_count. Step 3: Lead registers dev_count Dev agents as teammates (if not already registered). Step 4: Lead dispatches initial task assignments. Step 5: Lead enters monitoring loop -- when a task_complete event is received, Lead removes files from claimed_files, re-evaluates blocked tasks (some may now be unblocked), recomputes dev_count, and if newly unblocked tasks exist and idle Devs are available, assigns them. (3) Reference to canonical script: 'The formula is implemented in scripts/compute-dev-count.sh (canonical -- prompts reference this script).' Include inline code block: bash scripts/compute-dev-count.sh --available 7 outputs 5. (4) A note: 'When available_unblocked_tasks is 0, Lead waits for task_complete events before spawning any Devs.' Add team_mode=teammate guard at top.","ts":""}
{"id":"T3","tp":"auto","a":"Add ## Task-Level Blocking section to teammate-api-patterns.md documenting how cross-plan task dependencies (from xd field) map to TaskCreate blockedBy parameters at task granularity, not plan granularity. Include td (task_depends) field mapping for intra-plan ordering. Include example: task T2 in plan 03-02 depends on T3 in plan 03-01 completing.","f":["references/teammate-api-patterns.md"],"v":"File contains ## Task-Level Blocking with cross-plan dependency mapping, td field mapping, and example","done":"Task-level blocking documented with cross-plan and intra-plan dependency examples","spec":"Modify file: references/teammate-api-patterns.md. Insert a new ## Task-Level Blocking (when team_mode=teammate) section AFTER ## Dynamic Dev Scaling (from T2) and BEFORE ## Task Mode Fallback. Content must include: (1) Intra-plan blocking via td field: When a task has td:[\"T1\",\"T3\"], it means this task is blocked until tasks T1 AND T3 in the SAME plan are complete. Lead maps td entries to TaskCreate blocked_by parameter using format '{plan_id}/T{N}' (e.g., '03-01/T1'). When td is absent or empty, the task has no intra-plan dependencies (can run immediately if plan-level deps are satisfied). (2) Cross-plan blocking via d field: When plan B has d:[\"03-01\"], ALL tasks in plan B are blocked by ALL tasks in plan 03-01. Lead maps this by adding blocked_by entries for every task in plan 03-01 to every task in plan B. This is coarse-grained by design -- plan-level dependency means nothing in B can start until everything in A is done. (3) Cross-phase blocking via xd field: When plan has xd entries, Lead verifies the referenced artifact exists (summary.jsonl with s:complete) before creating any tasks from that plan. xd blocking is resolved at plan load time, not at task level. (4) Concrete example: Plan 03-02 has d:[\"03-01\"]. Plan 03-01 has tasks T1-T7. This means all tasks in 03-02 have blocked_by=['03-01/T1','03-01/T2',...,'03-01/T7']. Within 03-01, if T3 has td:['T1'], then T3 has blocked_by=['03-01/T1']. (5) Reference: 'See references/artifact-formats.md ## Plan Task for td field definition. See scripts/resolve-task-deps.sh for canonical dependency resolution.' Add team_mode=teammate guard at top.","ts":""}
{"id":"T4","tp":"auto","a":"Add task_claim, task_complete, and summary_aggregation schemas to references/handoff-schemas.md following existing pattern (type discriminator, JSON code block, usage notes). task_claim: Dev claims task from shared list. task_complete: Dev reports task done with commit hash. summary_aggregation: Lead collects all task_complete messages for a plan and writes summary.jsonl.","f":["references/handoff-schemas.md"],"v":"File contains task_claim, task_complete, and summary_aggregation schema sections","done":"Three new schemas added matching existing handoff-schemas.md pattern","spec":"Modify file: references/handoff-schemas.md. Insert 3 new schema sections AFTER the existing ## `escalation` section (after line 242, before the --- separator on line 244) and BEFORE the ## Cross-Department Schemas section. Each schema follows the existing pattern: ## heading with backtick-quoted type, sender -> receiver note, description paragraph, JSON code block, usage notes. (1) ## `task_claim` (Dev -> Lead, when team_mode=teammate): Schema fields: {\"type\":\"task_claim\",\"task_id\":\"T3\",\"plan_id\":\"03-01\",\"files\":[\"references/teammate-api-patterns.md\"],\"claimed_at\":\"ISO8601\"}. Usage note: 'Dev sends to Lead after calling TaskUpdate to claim a task. Lead adds task files to claimed_files set for file-overlap detection. In task mode, this message is not used (Dev works sequentially).' (2) ## `task_complete` (Dev -> Lead, when team_mode=teammate): Schema fields: {\"type\":\"task_complete\",\"task_id\":\"T3\",\"plan_id\":\"03-01\",\"commit\":\"abc1234\",\"files_modified\":[\"references/teammate-api-patterns.md\"],\"status\":\"complete\",\"deviations\":[]}. Usage note: 'Dev sends to Lead after committing task. Lead removes files from claimed_files, checks if all tasks in plan are complete, and aggregates into summary.jsonl. Distinct from dev_progress (sent to Senior for visibility) -- task_complete is for Lead accounting only.' (3) ## `summary_aggregation` (Lead internal, when team_mode=teammate): Schema fields: {\"type\":\"summary_aggregation\",\"plan_id\":\"03-01\",\"tasks_completed\":7,\"tasks_total\":7,\"commit_hashes\":[\"abc1234\",\"def5678\"],\"files_modified\":[\"a.md\",\"b.md\"],\"deviations\":[],\"status\":\"complete\"}. Usage note: 'Lead constructs this internally from collected task_complete messages. Used to write summary.jsonl. In task mode, Dev writes summary.jsonl directly and this schema is not used.'","ts":""}
{"id":"T5","tp":"auto","a":"Add td (task_depends) field to references/artifact-formats.md Plan Task schema table. Type: optional string[] referencing task IDs within the same plan (e.g., [\"T1\", \"T3\"]). Document semantics: intra-plan task ordering only, maps to TaskCreate blockedBy parameter. When absent, all tasks in a plan are independent (current behavior preserved). Cross-plan dependencies use the existing plan-level d field. (D4, C4)","f":["references/artifact-formats.md"],"v":"Plan Task schema table contains td row with type string[], description of intra-plan ordering","done":"td field added to Plan Task schema in artifact-formats.md","spec":"Modify file: references/artifact-formats.md. In the Plan Task table (lines 34-46), add a new row AFTER the `ts` row (after line 45, before the blank line at 46). The new row: | `td` | task_depends | string[] | [\"T1\", \"T3\"] |. After the table (after the existing line 48 about ts field), add a new paragraph: 'The `td` field is optional. When present, it lists task IDs within the same plan that must complete before this task can begin (intra-plan ordering). Maps to TaskCreate blockedBy parameter in teammate mode. When absent, the task has no intra-plan dependencies. Cross-plan dependencies use the plan header `d` field. See `references/teammate-api-patterns.md` ## Task-Level Blocking.'","ts":""}
{"id":"T6","tp":"auto","a":"Create scripts/git-commit-serialized.sh: flock-based serialized git commit wrapper. Uses flock(1) on .git/yolo-commit.lock for exclusive locking. Accepts same arguments as git commit (staged files must be pre-staged by caller). 5 retries with exponential backoff starting at 200ms (200, 400, 800, 1600, 3200ms). Returns commit hash on stdout on success, exits non-zero after all retries exhausted. Detect flock availability at start; fall back to mkdir-based advisory lock if flock missing. Include inline usage documentation and set -euo pipefail. (D5, C5)","f":["scripts/git-commit-serialized.sh"],"v":"Script exists, is executable, uses flock or mkdir fallback, has 5-retry backoff logic, outputs commit hash","done":"git-commit-serialized.sh created with flock serialization and exponential backoff","spec":"Create new file: scripts/git-commit-serialized.sh. Make executable (chmod +x). Structure: (1) Shebang: #!/usr/bin/env bash. (2) set -euo pipefail. (3) Inline usage comment block: '# git-commit-serialized.sh -- Serialized git commit wrapper for parallel Dev agents. # Uses flock(1) for exclusive locking on .git/yolo-commit.lock. # Falls back to mkdir-based advisory lock if flock is unavailable. # Usage: git-commit-serialized.sh [git commit args] # Example: git-commit-serialized.sh -m \"feat(01-01): add auth\" # Caller must stage files BEFORE calling this script. # Outputs commit hash on stdout. Exit 0 on success, 1 on failure.' (4) Constants: LOCK_FILE=\".git/yolo-commit.lock\", MAX_RETRIES=5, BASE_DELAY_MS=200. (5) Function has_flock() that checks: command -v flock &>/dev/null. (6) Function acquire_lock_flock() that uses: exec 200>\"$LOCK_FILE\" && flock -n 200. Returns 0 on success, 1 on failure. (7) Function acquire_lock_mkdir() fallback that uses: mkdir \"${LOCK_FILE}.d\" 2>/dev/null. Returns 0 on success, 1 on failure. Add trap to clean up: trap 'rmdir \"${LOCK_FILE}.d\" 2>/dev/null || true' EXIT. (8) Function release_lock_mkdir() that does: rmdir \"${LOCK_FILE}.d\" 2>/dev/null || true. (9) Function sleep_ms() that converts ms to seconds for sleep: sleep $(echo \"scale=3; $1/1000\" | bc). If bc not available, use python3 -c or awk fallback. (10) Main logic: Detect lock strategy (flock or mkdir). Retry loop for i in 0..4: attempt acquire_lock, if success: run 'git commit \"$@\"', capture exit code, capture commit hash via 'git rev-parse --short HEAD', release lock (if mkdir mode), echo commit hash to stdout, exit with git commit exit code. If lock acquire fails: compute delay = BASE_DELAY_MS * 2^i, call sleep_ms $delay, continue loop. After all retries exhausted: echo error to stderr 'ERROR: Could not acquire commit lock after 5 retries (total wait ~6.2s). Escalate to Senior as a blocker.' and exit 1. (11) Ensure the script does NOT create the .git directory or the lock file permanently -- flock mode creates the file but it is harmless (empty), mkdir mode creates/removes a directory.","ts":"Test file: tests/behavioral/file-overlap-serialized-commit.bats (created in 03-05 T7). Tests: lock file creation during commit, retry on contention, exit 1 after 5 retries. Script should also be tested manually: stage a file, run git-commit-serialized.sh -m 'test', verify commit hash output."}
{"id":"T7","tp":"auto","a":"Create scripts/compute-dev-count.sh: accepts --available N argument, outputs min(N, 5) as integer. Validate input (non-negative integer, error on negative or non-numeric). Exit 0 on success. Create scripts/resolve-task-deps.sh: accepts --plan path/to/plan.jsonl and optional --all-plans dir/, reads plan.jsonl tasks, resolves td (intra-plan) and d (cross-plan) dependencies, outputs JSON task execution order on stdout. Detects circular dependencies and exits 1 with error message. Both scripts use set -euo pipefail. (D9, C9)","f":["scripts/compute-dev-count.sh","scripts/resolve-task-deps.sh"],"v":"Both scripts exist, are executable. compute-dev-count.sh: --available 3 outputs 3, --available 10 outputs 5. resolve-task-deps.sh: reads plan.jsonl and outputs ordered JSON","done":"compute-dev-count.sh and resolve-task-deps.sh created as testable helper scripts","spec":"Create TWO new files, both executable (chmod +x). FILE 1: scripts/compute-dev-count.sh. Structure: (1) Shebang: #!/usr/bin/env bash. (2) set -euo pipefail. (3) Usage comment: '# compute-dev-count.sh -- Compute optimal Dev agent count # Formula: min(available_unblocked_tasks, 5) # Usage: compute-dev-count.sh --available N # Output: integer on stdout # Exit: 0 on success, 1 on invalid input'. (4) Parse args: if [ $# -lt 2 ] or first arg != '--available', print usage to stderr and exit 1. Extract N from $2. (5) Validate N: check it matches regex ^[0-9]+$ (non-negative integer). If not, echo 'ERROR: --available requires a non-negative integer, got: $2' to stderr and exit 1. Specifically reject negative numbers (leading dash) and non-numeric strings. (6) Compute: if N > 5 then output 5, else output N. Use arithmetic: result=$((N < 5 ? N : 5)). (7) Echo $result to stdout. Exit 0. FILE 2: scripts/resolve-task-deps.sh. Structure: (1) Shebang: #!/usr/bin/env bash. (2) set -euo pipefail. (3) jq dependency check (same pattern as validate-plan.sh line 14-17). (4) Usage comment: '# resolve-task-deps.sh -- Resolve task execution order from plan.jsonl # Reads td (intra-plan) and d (cross-plan) dependencies # Outputs JSON array of task execution groups # Usage: resolve-task-deps.sh --plan path/to/plan.jsonl [--all-plans dir/] # Output: JSON on stdout # Exit: 0 on success, 1 on circular dependency'. (5) Parse args: --plan is required (path to plan.jsonl), --all-plans is optional (directory containing multiple plan.jsonl files for cross-plan resolution). (6) Read plan.jsonl: extract tasks (lines 2+) and their td fields using jq. Also read header d field for cross-plan deps. (7) Build dependency graph: for each task, record its td dependencies. If --all-plans provided, also resolve d field by reading referenced plan.jsonl files and adding blocked_by entries. (8) Topological sort using Kahn's algorithm in bash/jq: compute in-degree for each task. Initialize queue with tasks having in-degree 0. Process queue: remove task from queue, add to result, decrement in-degree of dependents. If result length != task count, circular dependency detected: echo 'ERROR: Circular dependency detected among tasks: [remaining tasks]' to stderr and exit 1. (9) Output: JSON array of objects [{\"group\":1,\"tasks\":[\"T1\",\"T4\"]},{\"group\":2,\"tasks\":[\"T2\"]},{\"group\":3,\"tasks\":[\"T3\"]}] where group number indicates execution order (tasks in same group can run in parallel). Use jq to construct the JSON output. (10) Exit 0 on success.","ts":"Test files: tests/behavioral/compute-dev-count.bats and tests/behavioral/resolve-task-deps.bats (created in 03-05 T5 and T6). compute-dev-count tests: 0->0, 1->1, 5->5, 10->5, negative->error, non-numeric->error, missing flag->error. resolve-task-deps tests: linear chain, parallel tasks, mixed deps, circular detection, empty plan."}
