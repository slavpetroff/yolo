---
phase: 11
plan: 3
title: Command Execution Timeouts
wave: 1
depends_on: []
must_haves:
  - All Command::new() spawns in MCP tool handlers wrapped with configurable timeout
  - Default 30s timeout, configurable via command_timeout_ms config key
  - Timed-out processes killed cleanly (SIGTERM then SIGKILL)
  - Telemetry tracks timeout kills
  - All existing tools.rs tests pass
---

# Plan 11-03: Command Execution Timeouts

## Context

The MCP `run_test_suite` tool and `compile_context` tool spawn external commands (`cargo test`, `bats`, `git diff`) via `tokio::process::Command` with no timeout. A hung process blocks the tool call indefinitely. This plan wraps all `Command::new()` spawns in `tools.rs` with a timeout that kills the process after a configurable duration.

This plan only modifies `tools.rs` in `src/mcp/`. Plans 1 and 3 are disjoint: Plan 1 wraps at the `server.rs` dispatch level, Plan 3 wraps at the `Command::new()` level inside `tools.rs`.

## Files to Modify

| File | Action | What Changes |
|------|--------|-------------|
| `yolo-mcp-server/src/mcp/tools.rs` | EDIT | Add timeout wrapper for all Command spawns, add config key reading |
| `config/defaults.json` | EDIT | Add `command_timeout_ms` key (default 30000) |

## Tasks

### Task 1: Add timeout helper function to tools.rs

In `tools.rs`, add a private async helper:
- `async fn run_command_with_timeout(cmd: &mut Command, timeout_ms: u64) -> Result<Output, String>`: spawns the command, wraps with `tokio::time::timeout`, on timeout kills the child process and returns descriptive error
- Use `child.kill()` on timeout, then `child.wait()` to reap
- Default timeout: 30000ms (30 seconds)
- Unit test: spawn a `sleep 60` command, verify it's killed within timeout

**Commit:** `feat(mcp): add command execution timeout helper`

### Task 2: Read command_timeout_ms from config

In `tools.rs`:
- Add a helper `fn read_timeout_config() -> u64` that reads `.yolo-planning/config.json`, extracts `command_timeout_ms` key, returns value or default 30000
- In `config/defaults.json`, add `"command_timeout_ms": 30000` key
- Unit test: verify default value when config missing, verify custom value when set

**Commit:** `feat(mcp): add command_timeout_ms config key with 30s default`

### Task 3: Wrap run_test_suite Command spawns with timeout

In the `"run_test_suite"` handler in `tools.rs`:
- Replace `cmd.output().await` (line 197) with `run_command_with_timeout(&mut cmd, timeout_ms).await`
- On timeout error, return a clear error message: `"Command timed out after {timeout_ms}ms"`
- Read timeout from config at start of handler
- Verify existing run_test_suite tests pass

**Commit:** `feat(mcp): add timeout to run_test_suite command execution`

### Task 4: Wrap compile_context git diff Command with timeout

In the `"compile_context"` handler in `tools.rs`:
- Replace `Command::new("git").arg("diff").arg("HEAD").output().await` (line 44) with `run_command_with_timeout()` using half the configured timeout (git diff should be fast)
- On timeout, append "Git diff timed out" to tier3 instead of diff content
- Verify existing compile_context tests pass

**Commit:** `feat(mcp): add timeout to compile_context git diff`

### Task 5: Add tests for timeout behavior

Add tests in `tools.rs` tests module:
- Test that `run_command_with_timeout` kills a long-running command within the specified timeout
- Test that successful commands complete normally when under timeout
- Test that timeout error message includes the timeout duration
- Test config reading: default 30000, custom value from config

**Commit:** `test(mcp): add tests for command execution timeout behavior`
