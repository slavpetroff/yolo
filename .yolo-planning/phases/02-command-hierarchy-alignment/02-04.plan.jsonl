{"p":"02","n":"04","t":"qa.md hierarchy rewrite","w":1,"d":[],"xd":[],"mh":{"tr":["qa.md spawns Lead agent (yolo-lead) as dispatch coordinator, not QA directly","Lead dispatches QA Lead for plan verification and QA Code for code verification","Lead synthesizes QA Lead + QA Code results into unified report","Escalation: QA->Lead->go.md documented","QA remediation chain: QA FAIL->Lead->Senior->Dev->re-verify preserved","Owner-first: go.md acts as Owner proxy, qa.md Lead handles downstream"],"ar":[{"p":"commands/qa.md","pv":"yolo-lead","c":"grep"},{"p":"commands/qa.md","pv":"Lead.*dispatch","c":"grep"},{"p":"commands/qa.md","pv":"yolo-qa-code","c":"grep"}],"kl":[{"fr":"commands/qa.md","to":"agents/yolo-lead.md","vi":"Lead dispatches QA agents"},{"fr":"commands/qa.md","to":"agents/yolo-qa.md","vi":"QA Lead verifies plans"},{"fr":"commands/qa.md","to":"agents/yolo-qa-code.md","vi":"QA Code verifies code"}]},"obj":"Rewrite qa.md to route through Lead->QA Lead+QA Code hierarchy instead of spawning QA directly (REQ-02, REQ-03)","sk":[],"fm":["commands/qa.md"],"auto":true}
{"id":"T1","tp":"auto","a":"Rewrite qa.md Steps section: (1) Step 3 spawns yolo-lead as QA dispatch coordinator instead of yolo-qa directly. Lead receives phase number + tier from Steps 1-2. (2) Lead dispatches yolo-qa (QA Lead) for plan-level verification: must_haves, criteria, requirement traceability. (3) Lead dispatches yolo-qa-code for code-level verification: tests, lint, coverage, regression, patterns. (4) QA Lead reports via qa_result schema, QA Code reports via qa_code_result schema. (5) Lead synthesizes: combines plan-level + code-level results, produces unified PASS/FAIL/PARTIAL. (6) Lead writes VERIFICATION.md with combined results. (7) Lead handles remediation routing if FAIL: assigns Senior to re-spec, Dev to fix, re-verifies (max 2 cycles, then escalates to Architect). Keep model resolution for lead, qa, qa-code. Keep YAML frontmatter unchanged. Keep Guard + auto-detect section unchanged. Keep tier resolution logic. (REQ-02, REQ-03)","f":["commands/qa.md"],"v":"grep -q 'yolo-lead' commands/qa.md && grep -q 'yolo-qa-code' commands/qa.md && ! grep -qE 'Spawn.+yolo-qa.+subagent' commands/qa.md","done":"qa.md routes through Lead who dispatches QA Lead + QA Code, synthesizes results","spec":"Open commands/qa.md. PRESERVE lines 1-7 exactly (YAML frontmatter: name: qa, description, argument-hint with --tier and --effort, allowed-tools, disable-model-invocation: true). PRESERVE lines 9-10 (# YOLO QA title). PRESERVE lines 12-31 (## Context section with working dir, state, config, phase dirs, phase state). PRESERVE lines 33-38 (## Guard section with init check, auto-detect phase logic, phase-not-built check, continuous verification note). REPLACE the entire ## Steps section (lines 40-78) with the following new content. Step 1 (Resolve tier): Keep identical to current -- priority chain: --tier > --effort > config > Standard. Effort mapping: turbo=skip, fast=quick, balanced=standard, thorough=deep. Read effort profile. Context overrides for deep tier. Step 2 (Resolve milestone): Keep identical -- check .yolo-planning/ACTIVE for milestone-scoped paths. Step 3 (Spawn Lead): NEW. Replace direct QA spawn. (a) Resolve 3 models: LEAD_MODEL=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/resolve-agent-model.sh lead .yolo-planning/config.json ${CLAUDE_PLUGIN_ROOT}/config/model-profiles.json) with error check. QA_MODEL=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/resolve-agent-model.sh qa .yolo-planning/config.json ${CLAUDE_PLUGIN_ROOT}/config/model-profiles.json) with error check. QA_CODE_MODEL=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/resolve-agent-model.sh qa-code .yolo-planning/config.json ${CLAUDE_PLUGIN_ROOT}/config/model-profiles.json) with error check. (b) Display: diamond Spawning Lead (${LEAD_MODEL}) for QA dispatch... (c) Spawn yolo-lead as subagent via Task tool with model: '${LEAD_MODEL}'. Prompt: 'QA dispatch coordinator. Phase: {N}. Tier: {tier}. QA model: ${QA_MODEL}. QA-Code model: ${QA_CODE_MODEL}. Plans: {paths to plan.jsonl files}. Summaries: {paths to summary.jsonl files}. Phase success criteria: {from ROADMAP.md}. Convention baseline: .yolo-planning/codebase/CONVENTIONS.md (if exists). Verification protocol: ${CLAUDE_PLUGIN_ROOT}/references/verification-protocol.md. Instructions: (1) Dispatch QA Lead (yolo-qa, model: QA_MODEL): plan-level verification -- must_haves, done criteria, requirement traceability. Provide plan.jsonl + summary.jsonl + .ctx-qa.toon context. QA Lead returns qa_result schema. (2) Dispatch QA Code (yolo-qa-code, model: QA_CODE_MODEL): code-level verification -- tests, lint, coverage, regression, patterns. Provide summary.jsonl (file list) + test-plan.jsonl + .ctx-qa-code.toon context. QA Code returns qa_code_result schema. (3) Synthesize: combine qa_result + qa_code_result into unified verdict: PASS (both pass), PARTIAL (one partial), FAIL (any fail). (4) Write {phase-dir}/{phase}-VERIFICATION.md with frontmatter: phase, tier, result, passed, failed, total, date. Body: combined QA output. (5) Remediation (if FAIL or PARTIAL with critical findings): spawn yolo-senior (resolve model first) to re-spec failing items, Senior spawns yolo-dev to fix, then re-dispatch QA for verification. Max 2 remediation cycles. After 2nd fail: escalate to Architect via escalation schema. (6) Return: unified result, path to VERIFICATION.md.' Step 4 (Present): Keep the brand-essentials box format. Show: Phase {N}: {name} -- Verified. Tier, Result (checkmark PASS / x FAIL / diamond PARTIAL), Checks: passed/total, Failed list, Report path. Run bash ${CLAUDE_PLUGIN_ROOT}/scripts/suggest-next.sh qa {result} and display. ENSURE total file is under 110 lines. Target: 7 YAML + 22 Context + 6 Guard + ~60 Steps + ~15 Present = ~110.","ts":""}
{"id":"T2","tp":"auto","a":"Add escalation and remediation documentation to qa.md: Document dispatch chain Lead->QA Lead+QA Code->Lead(synthesis). Document remediation chain: FAIL->Lead->Senior re-specs->Dev fixes->QA re-verifies (max 2 cycles)->Architect if 3rd fail. Document that QA agents NEVER contact Architect directly, findings route through Lead. (REQ-02)","f":["commands/qa.md"],"v":"grep -q 'Escalation' commands/qa.md && grep -qi 'remediation' commands/qa.md","done":"Escalation and remediation chains documented in qa.md","spec":"Open commands/qa.md (after T1 rewrite). AFTER the Present section (after the suggest-next.sh line), add a new ## Escalation and Remediation section with exactly these rules as a compact bullet list: (1) QA Lead -> Lead: QA Lead reports plan-level findings via qa_result schema. QA Lead NEVER contacts Architect or user. (2) QA Code -> Lead: QA Code reports code-level findings via qa_code_result schema. QA Code NEVER modifies source code. (3) Lead synthesis: Lead combines both QA reports into unified PASS/FAIL/PARTIAL verdict. (4) Remediation chain (FAIL/PARTIAL with critical): Lead assigns Senior to re-spec failing items -> Senior spawns Dev to fix -> Lead re-dispatches QA to verify fix. Max 2 cycles. (5) Escalation on 3rd failure: Lead escalates to Architect via escalation schema for design re-evaluation. (6) No QA agent contacts Architect directly. All findings route through Lead. Keep to 8-10 lines max. Single-dash bullets, no nesting.","ts":""}
{"id":"T3","tp":"auto","a":"Verify qa.md coherence: Ensure total line count stays under 110 lines (qa.md is the most complex of the four). Ensure brand essentials Present section preserved. Ensure suggest-next.sh reference preserved. Ensure VERIFICATION.md persist logic intact (Lead writes it now). Commit: feat(02-04): rewrite qa.md to use Lead->QA+QA-Code hierarchy","f":["commands/qa.md"],"v":"wc -l commands/qa.md shows <= 110 lines; YAML frontmatter parseable; hierarchy chain clear; VERIFICATION.md output preserved","done":"qa.md committed, coherent, under 110 lines, hierarchy-routed","spec":"Open commands/qa.md (after T1 and T2). Run verification checks: (1) Line count: count total lines, must be <=110. If over, trim: collapse Lead prompt into fewer lines (join short instructions with semicolons), remove double-blank-lines, tighten the Escalation section. (2) YAML frontmatter: verify name: qa unchanged. Update description from 'Run deep verification on completed phase work using the QA agent.' to 'Run deep verification on completed phase work via Lead-dispatched QA hierarchy.' Keep argument-hint, allowed-tools, disable-model-invocation unchanged. (3) Guard section: verify auto-detect logic is fully intact (phase-detect.sh, SUMMARY.md / VERIFICATION.md scanning, announce/stop messages). (4) Model resolution: verify LEAD_MODEL, QA_MODEL, QA_CODE_MODEL all use resolve-agent-model.sh with correct 3 args. Verify Lead spawn passes model: '${LEAD_MODEL}'. Verify QA and QA_CODE models passed to Lead in prompt. (5) VERIFICATION.md: verify Lead prompt includes instruction to write {phase-dir}/{phase}-VERIFICATION.md with frontmatter (phase, tier, result, passed, failed, total, date). (6) Brand essentials: verify Present section references @${CLAUDE_PLUGIN_ROOT}/references/yolo-brand-essentials.toon. Verify box format matches current structure. (7) suggest-next.sh: verify call 'suggest-next.sh qa {result}' exists. (8) No direct QA spawn: grep for 'Spawn yolo-qa as subagent' or 'Spawn yolo-qa-code as subagent' at command level (not inside Lead prompt). Must NOT exist. All QA agent spawns happen inside Lead's instructions. (9) Stage and commit: git add commands/qa.md && git commit 'feat(02-04): rewrite qa.md to use Lead->QA+QA-Code hierarchy'.","ts":""}
