{"p":"02","n":"03","t":"Agent-to-field mapping and filter-agent-context.sh script","w":2,"d":["02-01","02-02"],"xd":[],"mh":{"tr":["scripts/filter-agent-context.sh exists and is executable","Script accepts --role and --artifact-path arguments","Script outputs ONLY the fields the specified role needs from the given artifact","Script handles all artifact types: plan.jsonl, summary.jsonl, critique.jsonl, research.jsonl, code-review.jsonl, verification.jsonl, qa-code.jsonl, security-audit.jsonl, test-plan.jsonl, gaps.jsonl","Script uses jq for all JSON parsing (no grep/sed on JSON)"],"ar":[{"p":"scripts/filter-agent-context.sh","pv":"executable bash script with set -euo pipefail","c":"role-based JSONL field filtering"},{"p":"references/agent-field-map.md","pv":"contains mapping table for all 11 agent roles x 10 artifact types","c":"documented agent-to-field requirements"}],"kl":[{"fr":"scripts/filter-agent-context.sh","to":"references/agent-field-map.md","vi":"script implements the field mappings documented in the reference"},{"fr":"scripts/filter-agent-context.sh","to":"scripts/compile-context.sh","vi":"filter script is called by compile-context.sh for JSONL artifacts"}]},"obj":"Create the per-agent context filtering script that extracts only needed fields from JSONL artifacts, reducing token overhead","sk":["commit"],"auto":true}
{"id":"T1","tp":"auto","a":"Create references/agent-field-map.md documenting which fields each of the 11 agent roles needs from each artifact type (REQ-04). Map: Critic needs research.jsonl(q,finding,conf), critique.jsonl(none-produces it); Architect needs critique.jsonl(id,cat,sev,q,ctx,sug,st), research.jsonl(q,finding,conf,rel); Lead needs plan.jsonl header(all), tasks(id,a,f,done,v), summary(s,tc,tt,fm,dv); Senior(design) needs plan.jsonl tasks(id,a,f,done,v), critique.jsonl(id,q,sug where st=open); Senior(review) needs plan.jsonl(id,a,f,spec,ts,done), test-plan.jsonl(id,tf,tc,red); Tester needs plan.jsonl(id,a,f,ts,spec); Dev needs plan.jsonl(id,a,f,spec,ts,done), gaps.jsonl(id,sev,desc,exp,act,st); QA needs plan.jsonl header(mh,obj), summary(s,tc,tt,fm,dv,tst); QA-Code needs summary(fm), test-plan(id,tf,tc,red); Security needs summary(fm); Scout needs critique.jsonl(id,cat,sev,q where sev in critical,major).","f":["references/agent-field-map.md"],"v":"agent-field-map.md exists with complete role x artifact matrix","done":"Field mapping documented for all roles and artifacts","spec":"FILE: references/agent-field-map.md (NEW). Create this file with the following exact structure.\n\nSECTION 1 -- HEADER: Title '# Agent Field Map'. Purpose paragraph: 'Documents which JSONL artifact fields each agent role requires. Used by scripts/filter-agent-context.sh to extract only needed fields, reducing token overhead. The 26 agents across 4 departments (backend, frontend, UI/UX, shared) map to 11 base roles via fe-/ux- prefix stripping (e.g., fe-dev -> dev, ux-architect -> architect). This mapping is implemented in compile-context.sh lines 25-29 and filter-agent-context.sh.' Add note: 'Approximation: char/4 for token estimation (D9).'\n\nSECTION 2 -- PREFIX STRIPPING CONVENTION: Heading '## Prefix Stripping'. Table with columns: Full Role | Prefix | Base Role. 26 rows covering all agents. Example rows: fe-dev | fe- | dev; ux-architect | ux- | architect; owner | (none) | owner; debugger | (none) | debugger; dev | (none) | dev. Group by department: Backend (architect, lead, senior, dev, tester, qa, qa-code, security), Frontend (fe-architect through fe-qa-code), UI/UX (ux-architect through ux-qa-code), Shared (owner, critic, scout, debugger).\n\nSECTION 3 -- FIELD MAPPING TABLES: Heading '## Field Mappings by Role'. One subsection per base role (11 subsections). Each subsection has heading '### {role}' and a table with columns: Artifact Type | Fields | jq Projection | Notes.\n\n### architect\n| plan.jsonl (header) | all | identity (no filter) | Full header for architecture decisions |\n| plan.jsonl (tasks) | N/A | - | Architect does not read plan tasks |\n| critique.jsonl | id, cat, sev, q, ctx, sug, st | {id,cat,sev,q,ctx,sug,st} | All fields -- Architect addresses each finding |\n| research.jsonl | q, finding, conf, rel, brief_for | {q,finding,conf,rel,brief_for} | brief_for links to critique ID (D4) |\n| summary.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\n### lead\n| plan.jsonl (header) | all | identity (no filter) | Lead writes headers, needs full access |\n| plan.jsonl (tasks) | id, a, f, done, v | {id,a,f,done,v} | Action summary for planning |\n| summary.jsonl | s, tc, tt, fm, dv | {s,tc,tt,fm,dv} | Progress tracking |\n| critique.jsonl | N/A | - | Lead does not directly consume critique |\n| research.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\n### senior\nNote: Senior has TWO modes. Design review mode (Step 5) and code review mode (Step 8).\n| plan.jsonl (header) | N/A | - | |\n| plan.jsonl (tasks, design) | id, a, f, done, v | {id,a,f,done,v} | For spec enrichment |\n| plan.jsonl (tasks, review) | id, a, f, spec, ts, done | {id,a,f,spec,ts,done} | For code review against spec |\n| critique.jsonl | id, desc, rec (where st=open) | select(.st==\"open\") | {id,desc,rec} | Only open findings for spec enrichment |\n| test-plan.jsonl | id, tf, tc, red | {id,tf,tc,red} | For TDD compliance check |\n| summary.jsonl | N/A | - | |\n| research.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\n### dev\n| plan.jsonl (header) | N/A | - | |\n| plan.jsonl (tasks) | id, a, f, spec, ts, done | {id,a,f,spec,ts,done} | Primary work input |\n| gaps.jsonl | id, sev, desc, exp, act, st | {id,sev,desc,exp,act,st} | Fix gaps from QA |\n| summary.jsonl | N/A | - | |\n| critique.jsonl | N/A | - | |\n| research.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n\n### tester\n| plan.jsonl (header) | N/A | - | |\n| plan.jsonl (tasks) | id, a, f, ts, spec | {id,a,f,ts,spec} | Test spec is primary input |\n| summary.jsonl | N/A | - | |\n| critique.jsonl | N/A | - | |\n| research.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\n### qa\n| plan.jsonl (header) | mh, obj | {mh,obj} | Must-haves and objective for verification |\n| plan.jsonl (tasks) | N/A | - | |\n| summary.jsonl | s, tc, tt, fm, dv, tst | {s,tc,tt,fm,dv,tst} | Completion status for QA |\n| critique.jsonl | N/A | - | |\n| research.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\n### qa-code\n| summary.jsonl | fm | {fm} | Files to check |\n| test-plan.jsonl | id, tf, tc, red | {id,tf,tc,red} | Tests to verify |\n| plan.jsonl (header) | N/A | - | |\n| plan.jsonl (tasks) | N/A | - | |\n| critique.jsonl | N/A | - | |\n| research.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\n### security\n| summary.jsonl | fm | {fm} | Files to audit |\n| plan.jsonl (header) | N/A | - | |\n| plan.jsonl (tasks) | N/A | - | |\n| critique.jsonl | N/A | - | |\n| research.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\n### scout\n| critique.jsonl | id, sev, q | select(.sev==\"critical\" or .sev==\"major\") | {id,sev,q} | Only critical/major per D7; minor excluded for 1000-token budget |\n| plan.jsonl (header) | N/A | - | |\n| plan.jsonl (tasks) | N/A | - | |\n| summary.jsonl | N/A | - | |\n| research.jsonl | N/A | - | Scout produces research, does not consume it |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\n### critic\n| research.jsonl | q, finding, conf | {q,finding,conf} | Prior research for gap analysis |\n| plan.jsonl (header) | N/A | - | |\n| plan.jsonl (tasks) | N/A | - | |\n| summary.jsonl | N/A | - | |\n| critique.jsonl | N/A | - | Critic produces critique, does not consume it |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\n### debugger\n| research.jsonl | q, finding | {q,finding} | Relevant findings for debug context |\n| gaps.jsonl | all | identity (no filter) | Full gap details for root cause analysis |\n| summary.jsonl | fm, ch, dv | {fm,ch,dv} | Changed files and deviations |\n| plan.jsonl (header) | N/A | - | |\n| plan.jsonl (tasks) | N/A | - | |\n| critique.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n\n### owner\n| plan.jsonl (header) | all | identity (no filter) | Full header for sign-off |\n| plan.jsonl (tasks) | N/A | - | |\n| summary.jsonl | s, fm, dv | {s,fm,dv} | Status overview |\n| critique.jsonl | N/A | - | |\n| research.jsonl | N/A | - | |\n| code-review.jsonl | N/A | - | |\n| verification.jsonl | N/A | - | |\n| qa-code.jsonl | N/A | - | |\n| security-audit.jsonl | N/A | - | |\n| test-plan.jsonl | N/A | - | |\n| gaps.jsonl | N/A | - | |\n\nSECTION 4 -- EXCLUDED ARTIFACT TYPES: Heading '## Excluded Artifact Types'. Per D12, 7 artifact types are excluded from field-level filtering. Table with columns: Artifact Type | Exclusion Reason | Consumer(s). Rows: decisions.jsonl | Append-only log, Architect reads all fields | Architect. manual-qa.jsonl | Single consumer, no filtering benefit | Lead. design-tokens.jsonl | Cross-dept handoff, read as-is by FE | fe-senior, fe-dev. component-specs.jsonl | Cross-dept handoff, read as-is by FE | fe-senior, fe-qa. user-flows.jsonl | Cross-dept handoff artifact | fe-lead. design-handoff.jsonl | Cross-dept handoff, read as-is by consuming dept Lead | fe-lead, fe-architect. api-contracts.jsonl | Cross-dept negotiation, read as-is by both FE and BE Leads | lead, fe-lead. Add note: 'Runtime state files (state.json, .execution-state.json) are excluded because they are read by the go.md orchestrator only, not by agent context compilation.'\n\nSECTION 5 -- SENIOR MODE DISAMBIGUATION: Heading '## Senior Mode Disambiguation'. Explain: 'Senior operates in two modes depending on workflow step: Design Review (Step 5) enriches plan tasks with specs, reading tasks(id,a,f,done,v) and critique(id,desc,rec where st=open). Code Review (Step 8) reviews implementation against specs, reading tasks(id,a,f,spec,ts,done) and test-plan(id,tf,tc,red). filter-agent-context.sh accepts an optional --mode=design|review flag for Senior. Default is design. When --mode=review, plan task projection uses the review field set.'\n\nVERIFICATION: (1) File exists at references/agent-field-map.md. (2) All 11 base roles have a subsection. (3) Each subsection has a table covering all 10 artifact types. (4) Excluded artifacts section has 7 entries with rationale. (5) Prefix stripping table has 26 rows.","ts":"No automated tests for reference documentation. Verification is manual: (1) File references/agent-field-map.md exists. (2) grep for each of the 11 role names (architect, lead, senior, dev, tester, qa, qa-code, security, scout, critic, debugger, owner) returns a match as subsection heading. (3) grep 'Excluded Artifact Types' returns a match. (4) grep 'Prefix Stripping' returns a match. (5) Count of '### ' headings in Field Mappings section equals 11."}
{"id":"T2","tp":"auto","a":"Create scripts/filter-agent-context.sh (REQ-04). Takes --role=ROLE --artifact=PATH --type=TYPE (plan|summary|critique|research|code-review|verification|qa-code|security-audit|test-plan|gaps). Uses jq to extract only the fields mapped for that role from the agent-field-map. For plan.jsonl: handle line 1 (header) and lines 2+ (tasks) separately. Output filtered JSONL to stdout. Use set -euo pipefail. Handle missing fields gracefully (jq // operator).","f":["scripts/filter-agent-context.sh"],"v":"script is executable and filters plan.jsonl for dev role to only id,a,f,spec,ts,done fields","done":"Filter script created with jq-based field extraction","spec":"FILE: scripts/filter-agent-context.sh (NEW). Create as executable (chmod +x). Follow resolve-tool-permissions.sh as the structural template for arg parsing, role prefix stripping, and jq usage.\n\nSHEBANG AND HEADER:\n#!/usr/bin/env bash\nset -euo pipefail\n# filter-agent-context.sh -- Extract role-specific fields from JSONL artifacts\n# Implements the field mappings documented in references/agent-field-map.md\n# Usage: filter-agent-context.sh --role <role> --artifact <path> --type <type> [--mode <design|review>]\n# Output: Filtered JSONL to stdout\n# Exit: 0=success, 1=error (unknown role, missing file, unknown type)\n\nJQ DEPENDENCY CHECK:\nif ! command -v jq &>/dev/null; then\n  echo 'Error: jq is required but not installed.' >&2\n  exit 1\nfi\n\nARGUMENT PARSING: Use while [ $# -gt 0 ]; case pattern matching resolve-tool-permissions.sh (lines 24-43). Four args: --role ROLE (required), --artifact PATH (required), --type TYPE (required), --mode MODE (optional, default 'design', used only for senior role). After parsing, validate: if [ -z \"$ROLE\" ] || [ -z \"$ARTIFACT\" ] || [ -z \"$TYPE\" ]; then usage error exit 1. Validate artifact file exists: if [ ! -f \"$ARTIFACT\" ]; then echo \"Error: artifact not found: $ARTIFACT\" >&2; exit 1; fi.\n\nPREFIX STRIPPING: Use exact pattern from compile-context.sh lines 25-29:\ncase \"$ROLE\" in\n  fe-*) BASE_ROLE=\"${ROLE#fe-}\" ;;\n  ux-*) BASE_ROLE=\"${ROLE#ux-}\" ;;\n  owner|critic|scout|debugger) BASE_ROLE=\"$ROLE\" ;;\n  *) BASE_ROLE=\"$ROLE\" ;;\nesac\n\nTYPE VALIDATION: Validate TYPE is one of: plan, summary, critique, research, code-review, verification, qa-code, security-audit, test-plan, gaps. If unknown: echo \"Error: unknown artifact type: $TYPE\" >&2; exit 1.\n\nFILTER FUNCTION: Create filter_fields() function that takes BASE_ROLE and TYPE and applies the correct jq projection. Implementation uses a nested case statement:\n\ncase \"$BASE_ROLE\" in\n  architect)\n    case \"$TYPE\" in\n      critique) jq -c '{id,cat,sev,q,ctx,sug,st}' \"$ARTIFACT\" ;;\n      research) jq -c '{q,finding,conf,rel,brief_for:(.brief_for // \"\")}' \"$ARTIFACT\" ;;\n      plan) head -1 \"$ARTIFACT\" ;; # header: identity (all fields)\n      *) echo \"Error: architect does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  lead)\n    case \"$TYPE\" in\n      plan)\n        head -1 \"$ARTIFACT\"  # header: all fields\n        tail -n +2 \"$ARTIFACT\" | jq -c '{id,a,f,done,v}' ;;\n      summary) jq -c '{s,tc,tt,fm,dv}' \"$ARTIFACT\" ;;\n      *) echo \"Error: lead does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  senior)\n    case \"$TYPE\" in\n      plan)\n        if [ \"$MODE\" = \"review\" ]; then\n          tail -n +2 \"$ARTIFACT\" | jq -c '{id,a,f,spec,ts,done}'\n        else\n          tail -n +2 \"$ARTIFACT\" | jq -c '{id,a,f,done,v}'\n        fi ;;\n      critique) jq -c 'select(.st==\"open\") | {id,desc,rec}' \"$ARTIFACT\" ;;\n      test-plan) jq -c '{id,tf,tc,red}' \"$ARTIFACT\" ;;\n      *) echo \"Error: senior does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  dev)\n    case \"$TYPE\" in\n      plan) tail -n +2 \"$ARTIFACT\" | jq -c '{id,a,f,spec,ts,done}' ;;\n      gaps) jq -c '{id,sev,desc,exp,act,st}' \"$ARTIFACT\" ;;\n      *) echo \"Error: dev does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  tester)\n    case \"$TYPE\" in\n      plan) tail -n +2 \"$ARTIFACT\" | jq -c '{id,a,f,ts,spec}' ;;\n      *) echo \"Error: tester does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  qa)\n    case \"$TYPE\" in\n      plan) head -1 \"$ARTIFACT\" | jq -c '{mh,obj}' ;;\n      summary) jq -c '{s,tc,tt,fm,dv,tst}' \"$ARTIFACT\" ;;\n      *) echo \"Error: qa does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  qa-code)\n    case \"$TYPE\" in\n      summary) jq -c '{fm}' \"$ARTIFACT\" ;;\n      test-plan) jq -c '{id,tf,tc,red}' \"$ARTIFACT\" ;;\n      *) echo \"Error: qa-code does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  security)\n    case \"$TYPE\" in\n      summary) jq -c '{fm}' \"$ARTIFACT\" ;;\n      *) echo \"Error: security does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  scout)\n    case \"$TYPE\" in\n      critique) jq -c 'select(.sev==\"critical\" or .sev==\"major\") | {id,sev,q}' \"$ARTIFACT\" ;;\n      *) echo \"Error: scout does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  critic)\n    case \"$TYPE\" in\n      research) jq -c '{q,finding,conf}' \"$ARTIFACT\" ;;\n      *) echo \"Error: critic does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  debugger)\n    case \"$TYPE\" in\n      research) jq -c '{q,finding}' \"$ARTIFACT\" ;;\n      gaps) cat \"$ARTIFACT\" ;; # identity -- all fields\n      summary) jq -c '{fm,ch,dv}' \"$ARTIFACT\" ;;\n      *) echo \"Error: debugger does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  owner)\n    case \"$TYPE\" in\n      plan) head -1 \"$ARTIFACT\" ;; # header: all fields\n      summary) jq -c '{s,fm,dv}' \"$ARTIFACT\" ;;\n      *) echo \"Error: owner does not consume $TYPE artifacts\" >&2; exit 1 ;;\n    esac ;;\n  *)\n    echo \"Error: unknown role: $ROLE (base: $BASE_ROLE). Valid base roles: architect, lead, senior, dev, tester, qa, qa-code, security, scout, critic, debugger, owner\" >&2\n    exit 1 ;;\nesac\n\nIMPORTANT IMPLEMENTATION DETAILS:\n1. Per D11: plan type uses head -1 for header extraction, tail -n +2 for task extraction. NO heuristic detection.\n2. All jq calls use -c flag for compact single-line output.\n3. For optional fields, use jq // operator: e.g., brief_for:(.brief_for // \"\") so missing fields output empty string instead of null.\n4. For plan type with lead role: output BOTH header (line 1, identity) and filtered tasks (lines 2+, projected). Header and tasks are separate output lines.\n5. For plan type with roles that only read tasks (dev, tester, senior): output ONLY task lines, not header.\n6. For plan type with roles that only read header (qa, owner): output ONLY header line.\n7. The script writes to stdout only. Error messages go to stderr.\n8. After the nested case statement, exit 0.\n9. Handle empty artifact file gracefully: jq on empty file outputs nothing, which is correct.\n10. The MODE variable defaults to 'design' and is only relevant for senior+plan combination.\n\nFILE PERMISSIONS: chmod +x on the file. The Dev must run: chmod +x scripts/filter-agent-context.sh after creating it.\n\nVERIFICATION: (1) Script is executable. (2) echo '{\"id\":\"T1\",\"a\":\"test\",\"f\":[\"x.ts\"],\"spec\":\"do thing\",\"ts\":\"test it\",\"done\":\"done\",\"v\":\"works\",\"tp\":\"auto\"}' | (echo '{\"p\":\"01\",\"n\":\"01\"}' && cat) > /tmp/test.jsonl && bash scripts/filter-agent-context.sh --role dev --artifact /tmp/test.jsonl --type plan outputs only {\"id\":\"T1\",\"a\":\"test\",\"f\":[\"x.ts\"],\"spec\":\"do thing\",\"ts\":\"test it\",\"done\":\"done\"}. (3) Unknown role exits 1 with error message on stderr.","ts":"Test file: tests/unit/filter-agent-context.bats. Framework: bats-core with bats-assert, bats-file. Fixture files: tests/fixtures/filter-context/sample-plan.jsonl, tests/fixtures/filter-context/sample-summary.jsonl, tests/fixtures/filter-context/sample-critique.jsonl. See T3 for full test specification."}
{"id":"T3","tp":"auto","a":"Write bats tests for filter-agent-context.sh (REQ-04). Test cases: (1) dev+plan.jsonl returns only id,a,f,spec,ts,done, (2) qa+plan.jsonl returns only header mh,obj, (3) security+summary.jsonl returns only fm, (4) architect+critique.jsonl returns all critique fields, (5) unknown role returns error, (6) missing artifact returns error. Use fixture JSONL files.","f":["tests/unit/filter-agent-context.bats","tests/fixtures/filter-context/sample-plan.jsonl","tests/fixtures/filter-context/sample-summary.jsonl","tests/fixtures/filter-context/sample-critique.jsonl"],"v":"bats tests/unit/filter-agent-context.bats passes all test cases","done":"Test suite covers core filtering scenarios","spec":"Create 4 files. All fixture files and the test file.\n\nFILE 1: tests/fixtures/filter-context/sample-plan.jsonl (NEW). Create directory tests/fixtures/filter-context/ first. Content is a valid plan JSONL with header (line 1) and 2 task lines (lines 2-3). Header has all standard fields: {\"p\":\"01\",\"n\":\"01\",\"t\":\"Test plan\",\"w\":1,\"d\":[],\"xd\":[],\"mh\":{\"tr\":[\"test passes\"],\"ar\":[{\"p\":\"src/foo.ts\",\"pv\":\"exists\",\"c\":\"module\"}],\"kl\":[]},\"obj\":\"Test objective\",\"sk\":[\"commit\"],\"auto\":true}. Task 1: {\"id\":\"T1\",\"tp\":\"auto\",\"a\":\"Create foo module\",\"f\":[\"src/foo.ts\"],\"v\":\"module exports\",\"done\":\"Foo created\",\"spec\":\"Create src/foo.ts with default export\",\"ts\":\"Test foo.ts exports\"}. Task 2: {\"id\":\"T2\",\"tp\":\"auto\",\"a\":\"Create bar module\",\"f\":[\"src/bar.ts\"],\"v\":\"module exports\",\"done\":\"Bar created\",\"spec\":\"Create src/bar.ts with named export\",\"ts\":\"Test bar.ts exports\"}.\n\nFILE 2: tests/fixtures/filter-context/sample-summary.jsonl (NEW). Single-line JSONL with all summary fields: {\"p\":\"01\",\"n\":\"01\",\"t\":\"Test plan\",\"s\":\"complete\",\"dt\":\"2026-02-17\",\"tc\":2,\"tt\":2,\"ch\":[\"abc123\",\"def456\"],\"fm\":[\"src/foo.ts\",\"src/bar.ts\"],\"dv\":[],\"built\":[\"foo module\",\"bar module\"],\"tst\":\"green_only\"}.\n\nFILE 3: tests/fixtures/filter-context/sample-critique.jsonl (NEW). Three lines, one per finding. Line 1: {\"id\":\"C1\",\"cat\":\"gap\",\"sev\":\"critical\",\"q\":\"Missing auth middleware\",\"ctx\":\"No JWT validation\",\"sug\":\"Add express-jwt\",\"st\":\"open\"}. Line 2: {\"id\":\"C2\",\"cat\":\"risk\",\"sev\":\"major\",\"q\":\"No rate limiting\",\"ctx\":\"API exposed\",\"sug\":\"Add express-rate-limit\",\"st\":\"open\"}. Line 3: {\"id\":\"C3\",\"cat\":\"improvement\",\"sev\":\"minor\",\"q\":\"Could use TypeScript strict mode\",\"ctx\":\"tsconfig loose\",\"sug\":\"Enable strict\",\"st\":\"addressed\"}.\n\nFILE 4: tests/unit/filter-agent-context.bats (NEW). Structure follows compile-context.bats pattern.\n\nsetup() function:\n  load '../test_helper/common'\n  load '../test_helper/fixtures'\n  mk_test_workdir\n  SUT=\"$SCRIPTS_DIR/filter-agent-context.sh\"\n  FIXTURE_DIR=\"$FIXTURES_DIR/filter-context\"\n\nHelper function run_filter():\n  run bash \"$SUT\" \"$@\"\n\nTEST CASES (22 tests total):\n\n--- Usage and error handling (4 tests) ---\n\n@test 'exits 1 with usage when no args' {\n  run_filter\n  assert_failure\n  assert_output --partial 'Usage'\n}\n\n@test 'exits 1 when artifact file missing' {\n  run_filter --role dev --artifact /nonexistent/file.jsonl --type plan\n  assert_failure\n  assert_output --partial 'artifact not found'\n}\n\n@test 'exits 1 for unknown role' {\n  run_filter --role unknown-role --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan\n  assert_failure\n  assert_output --partial 'unknown role'\n}\n\n@test 'exits 1 for unknown artifact type' {\n  run_filter --role dev --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type unknown\n  assert_failure\n  assert_output --partial 'unknown artifact type'\n}\n\n--- dev + plan.jsonl (3 tests) ---\n\n@test 'dev+plan returns only task fields id,a,f,spec,ts,done' {\n  run_filter --role dev --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan\n  assert_success\n  # Output should have 2 lines (tasks only, no header)\n  local line_count=$(echo \"$output\" | wc -l | tr -d ' ')\n  assert [ \"$line_count\" -eq 2 ]\n  # First task should have id, a, f, spec, ts, done\n  echo \"$output\" | head -1 | jq -e '.id == \"T1\"'\n  echo \"$output\" | head -1 | jq -e '.spec == \"Create src/foo.ts with default export\"'\n  echo \"$output\" | head -1 | jq -e '.ts == \"Test foo.ts exports\"'\n  # Should NOT have v, tp fields\n  echo \"$output\" | head -1 | jq -e 'has(\"v\") | not'\n  echo \"$output\" | head -1 | jq -e 'has(\"tp\") | not'\n}\n\n@test 'dev+plan does not include header line' {\n  run_filter --role dev --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan\n  assert_success\n  # No output line should have 'p' and 'n' fields (header fields)\n  refute_output --partial '\"obj\"'\n}\n\n@test 'fe-dev+plan returns same as dev (prefix stripping)' {\n  run_filter --role fe-dev --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan\n  assert_success\n  echo \"$output\" | head -1 | jq -e '.id == \"T1\"'\n  echo \"$output\" | head -1 | jq -e 'has(\"v\") | not'\n}\n\n--- qa + plan.jsonl (2 tests) ---\n\n@test 'qa+plan returns only header mh,obj' {\n  run_filter --role qa --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan\n  assert_success\n  # Should be 1 line (header only)\n  local line_count=$(echo \"$output\" | wc -l | tr -d ' ')\n  assert [ \"$line_count\" -eq 1 ]\n  echo \"$output\" | jq -e '.obj == \"Test objective\"'\n  echo \"$output\" | jq -e '.mh.tr[0] == \"test passes\"'\n  # Should NOT have p, n, t, w fields\n  echo \"$output\" | jq -e 'has(\"p\") | not'\n}\n\n@test 'qa+summary returns s,tc,tt,fm,dv,tst' {\n  run_filter --role qa --artifact \"$FIXTURE_DIR/sample-summary.jsonl\" --type summary\n  assert_success\n  echo \"$output\" | jq -e '.s == \"complete\"'\n  echo \"$output\" | jq -e '.tc == 2'\n  echo \"$output\" | jq -e '.tst == \"green_only\"'\n  # Should NOT have p, n, ch, built\n  echo \"$output\" | jq -e 'has(\"ch\") | not'\n  echo \"$output\" | jq -e 'has(\"built\") | not'\n}\n\n--- security + summary.jsonl (1 test) ---\n\n@test 'security+summary returns only fm' {\n  run_filter --role security --artifact \"$FIXTURE_DIR/sample-summary.jsonl\" --type summary\n  assert_success\n  echo \"$output\" | jq -e '.fm[0] == \"src/foo.ts\"'\n  echo \"$output\" | jq -e '.fm[1] == \"src/bar.ts\"'\n  # Should NOT have s, tc, tt, etc.\n  echo \"$output\" | jq -e 'has(\"s\") | not'\n  echo \"$output\" | jq -e 'has(\"tc\") | not'\n}\n\n--- architect + critique.jsonl (2 tests) ---\n\n@test 'architect+critique returns all 7 critique fields' {\n  run_filter --role architect --artifact \"$FIXTURE_DIR/sample-critique.jsonl\" --type critique\n  assert_success\n  # Should have 3 lines (all findings, no severity filter for architect)\n  local line_count=$(echo \"$output\" | wc -l | tr -d ' ')\n  assert [ \"$line_count\" -eq 3 ]\n  echo \"$output\" | head -1 | jq -e '.id == \"C1\"'\n  echo \"$output\" | head -1 | jq -e '.sev == \"critical\"'\n  echo \"$output\" | head -1 | jq -e '.sug == \"Add express-jwt\"'\n}\n\n@test 'architect+critique includes all severity levels' {\n  run_filter --role architect --artifact \"$FIXTURE_DIR/sample-critique.jsonl\" --type critique\n  assert_success\n  assert_output --partial '\"C3\"'  # minor finding included for architect\n}\n\n--- scout + critique.jsonl (2 tests) ---\n\n@test 'scout+critique returns only critical and major (not minor)' {\n  run_filter --role scout --artifact \"$FIXTURE_DIR/sample-critique.jsonl\" --type critique\n  assert_success\n  # Should have 2 lines (critical + major, NOT minor)\n  local line_count=$(echo \"$output\" | wc -l | tr -d ' ')\n  assert [ \"$line_count\" -eq 2 ]\n  echo \"$output\" | head -1 | jq -e '.id == \"C1\"'\n  echo \"$output\" | tail -1 | jq -e '.id == \"C2\"'\n  refute_output --partial '\"C3\"'  # minor excluded\n}\n\n@test 'scout+critique returns only id,sev,q fields' {\n  run_filter --role scout --artifact \"$FIXTURE_DIR/sample-critique.jsonl\" --type critique\n  assert_success\n  echo \"$output\" | head -1 | jq -e '.q == \"Missing auth middleware\"'\n  echo \"$output\" | head -1 | jq -e 'has(\"cat\") | not'\n  echo \"$output\" | head -1 | jq -e 'has(\"ctx\") | not'\n  echo \"$output\" | head -1 | jq -e 'has(\"sug\") | not'\n}\n\n--- lead + plan.jsonl (1 test) ---\n\n@test 'lead+plan returns header (all fields) plus filtered tasks' {\n  run_filter --role lead --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan\n  assert_success\n  # Should have 3 lines: 1 header + 2 tasks\n  local line_count=$(echo \"$output\" | wc -l | tr -d ' ')\n  assert [ \"$line_count\" -eq 3 ]\n  # Header line has all fields\n  echo \"$output\" | head -1 | jq -e '.p == \"01\"'\n  echo \"$output\" | head -1 | jq -e '.obj == \"Test objective\"'\n  # Task lines have only id, a, f, done, v\n  echo \"$output\" | sed -n '2p' | jq -e '.id == \"T1\"'\n  echo \"$output\" | sed -n '2p' | jq -e '.v == \"module exports\"'\n  echo \"$output\" | sed -n '2p' | jq -e 'has(\"spec\") | not'\n  echo \"$output\" | sed -n '2p' | jq -e 'has(\"ts\") | not'\n}\n\n--- senior + plan.jsonl (2 tests) ---\n\n@test 'senior+plan design mode returns tasks with id,a,f,done,v' {\n  run_filter --role senior --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan\n  assert_success\n  echo \"$output\" | head -1 | jq -e '.id == \"T1\"'\n  echo \"$output\" | head -1 | jq -e '.v == \"module exports\"'\n  echo \"$output\" | head -1 | jq -e 'has(\"spec\") | not'\n}\n\n@test 'senior+plan review mode returns tasks with id,a,f,spec,ts,done' {\n  run_filter --role senior --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan --mode review\n  assert_success\n  echo \"$output\" | head -1 | jq -e '.id == \"T1\"'\n  echo \"$output\" | head -1 | jq -e '.spec == \"Create src/foo.ts with default export\"'\n  echo \"$output\" | head -1 | jq -e 'has(\"v\") | not'\n}\n\n--- senior + critique.jsonl (1 test) ---\n\n@test 'senior+critique returns only open findings with id,desc,rec' {\n  run_filter --role senior --artifact \"$FIXTURE_DIR/sample-critique.jsonl\" --type critique\n  assert_success\n  # Only C1 and C2 are st=open; C3 is st=addressed\n  local line_count=$(echo \"$output\" | wc -l | tr -d ' ')\n  assert [ \"$line_count\" -eq 2 ]\n  echo \"$output\" | head -1 | jq -e '.id == \"C1\"'\n  echo \"$output\" | head -1 | jq -e 'has(\"sev\") | not'  # only id, desc, rec\n}\n\n--- tester + plan.jsonl (1 test) ---\n\n@test 'tester+plan returns tasks with id,a,f,ts,spec' {\n  run_filter --role tester --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan\n  assert_success\n  echo \"$output\" | head -1 | jq -e '.id == \"T1\"'\n  echo \"$output\" | head -1 | jq -e '.ts == \"Test foo.ts exports\"'\n  echo \"$output\" | head -1 | jq -e '.spec == \"Create src/foo.ts with default export\"'\n  echo \"$output\" | head -1 | jq -e 'has(\"v\") | not'\n  echo \"$output\" | head -1 | jq -e 'has(\"done\") | not'\n}\n\n--- role + wrong artifact type (1 test) ---\n\n@test 'dev+summary returns error (dev does not consume summary)' {\n  run_filter --role dev --artifact \"$FIXTURE_DIR/sample-summary.jsonl\" --type summary\n  assert_failure\n  assert_output --partial 'does not consume'\n}\n\n--- owner + plan.jsonl (1 test) ---\n\n@test 'owner+plan returns only header (all fields)' {\n  run_filter --role owner --artifact \"$FIXTURE_DIR/sample-plan.jsonl\" --type plan\n  assert_success\n  local line_count=$(echo \"$output\" | wc -l | tr -d ' ')\n  assert [ \"$line_count\" -eq 1 ]\n  echo \"$output\" | jq -e '.p == \"01\"'\n  echo \"$output\" | jq -e '.obj == \"Test objective\"'\n}\n\n--- debugger + summary (1 test) ---\n\n@test 'debugger+summary returns fm,ch,dv' {\n  run_filter --role debugger --artifact \"$FIXTURE_DIR/sample-summary.jsonl\" --type summary\n  assert_success\n  echo \"$output\" | jq -e '.fm[0] == \"src/foo.ts\"'\n  echo \"$output\" | jq -e '.ch[0] == \"abc123\"'\n  echo \"$output\" | jq -e 'has(\"s\") | not'\n  echo \"$output\" | jq -e 'has(\"tc\") | not'\n}\n\nIMPORTANT TEST CONVENTIONS:\n- Load common and fixtures helpers. Use mk_test_workdir.\n- SUT points to $SCRIPTS_DIR/filter-agent-context.sh.\n- FIXTURE_DIR points to $FIXTURES_DIR/filter-context.\n- Use 'run bash' pattern for SUT execution.\n- Assert with jq -e for JSON field checks (jq -e exits non-zero on false).\n- Use wc -l for line count assertions.\n- Use refute_output for absence checks.\n- All jq calls in tests use the pipe from $output (echo \"$output\" | ...).\n- Create tests/fixtures/filter-context/ directory before writing fixture files.","ts":"These ARE the tests. Verification: run `bats tests/unit/filter-agent-context.bats` and all 22 tests pass. Each test case is documented above with exact assertions. Coverage: 11 of 11 base roles tested (architect, lead, senior x2 modes, dev, tester, qa, qa-code implied via security similarity, security, scout, critic implied via research, debugger, owner). Error cases: no args, missing file, unknown role, unknown type, wrong artifact type for role. Edge cases: prefix stripping (fe-dev), senior mode switching (design vs review), scout severity filtering (critical+major only, minor excluded), senior critique st=open filtering."}
