{"ts":"2026-02-17T23:00:00Z","agent":"lead","task":"decomposition","dec":"Split phase into 4 plans: 2 wave-1 (research flow + artifact/agent updates) and 2 wave-2 (filter script + integration)","reason":"REQ-03 has two orthogonal concerns (execute-protocol changes vs agent/artifact updates) that can parallelize in wave 1. REQ-04 depends on understanding the research flow (wave 1) before mapping agent fields.","alts":["3 plans: merge 02-01 and 02-02 into one large plan","5 plans: split compile-context.sh integration into per-role plans"]}
{"ts":"2026-02-17T23:01:00Z","agent":"lead","task":"wave-ordering","dec":"Research flow (REQ-03) and context filtering (REQ-04) share wave 1 for protocol changes, wave 2 for implementation","reason":"Wave 1 establishes the protocol (what research step looks like, what fields agents need). Wave 2 implements the tooling. Filter script needs the research step defined first to know Scout's field requirements.","alts":["All wave 1 with task-level deps","3 waves: protocol, script, integration"]}
{"ts":"2026-02-17T23:02:00Z","agent":"lead","task":"step-numbering","dec":"Renumber existing steps 2-10 to 3-11 rather than inserting Step 1.5","reason":"Clean integer numbering avoids confusion. All references to step numbers across docs need updating but this is a one-time cost for permanent clarity.","alts":["Insert as Step 1.5 or Step 1b to avoid renumbering","Keep 10 steps by merging Critique+Research into Step 1"]}
{"ts":"2026-02-17T23:03:00Z","agent":"lead","task":"filter-approach","dec":"Standalone filter-agent-context.sh script called by compile-context.sh rather than inline jq in compile-context.sh","reason":"Separation of concerns: field mappings are testable independently. Agent-field-map.md serves as documentation. Script reusable by other tools. compile-context.sh stays focused on TOON assembly.","alts":["Inline jq filters in each compile-context.sh case","JSON config file with jq filter templates","Per-role filter scripts (filter-dev-context.sh, filter-qa-context.sh, etc)"]}
{"ts":"2026-02-17T23:10:00Z","agent":"architect","task":"D1","dec":"Display-only step renumbering; state keys remain strings (critique, research, architecture, etc.); Mandatory vs Skippable rewritten with state key names not numbers","reason":"State machine keys are stable identifiers. Display numbers change when steps are added. Using key names in Mandatory vs Skippable prevents future renumbering cascades.","alts":["Use numeric keys in state machine","Keep numeric references in Mandatory vs Skippable section"]}
{"ts":"2026-02-17T23:10:01Z","agent":"architect","task":"D2","dec":"Orchestrator (go.md) writes research.jsonl from Scout findings, mirroring Critic write pattern","reason":"Scout has no Write tool. Critic already uses this pattern (lines 144-146 of execute-protocol.md). Consistent orchestrator-writes-artifact pattern across all read-only agents.","alts":["Give Scout Write tool","Have Lead write instead of go.md"]}
{"ts":"2026-02-17T23:10:02Z","agent":"architect","task":"D3","dec":"Append-mode research: skip guard is turbo-only, not file-existence; pre-Critic and post-Critic entries coexist via mode field","reason":"File-existence skip guard would prevent post-Critic research when pre-Critic research ran. Mode field allows consumers to distinguish origin without separate files.","alts":["Separate files: pre-research.jsonl and research.jsonl","Skip guard checks mode field in existing entries"]}
{"ts":"2026-02-17T23:10:03Z","agent":"architect","task":"D4","dec":"New research.jsonl fields (brief_for, mode, priority) are optional with jq // defaults for backward compatibility","reason":"Standalone /yolo:research output must continue working. jq // operator provides graceful fallback to empty/default values.","alts":["Require all fields, migrate existing research.jsonl files","Version field in research.jsonl to switch parsing"]}
{"ts":"2026-02-17T23:10:04Z","agent":"architect","task":"D5","dec":"Add scout to Pre-Execution model resolution loop, positioned after critic before architect","reason":"SCOUT_MODEL must be resolved before the research step runs. Order matches workflow order: critique -> research -> architecture.","alts":["Resolve scout model inline at research step only","Add all missing roles (debugger, owner) to the loop"]}
{"ts":"2026-02-17T23:10:05Z","agent":"architect","task":"D8","dec":"26 agents map to 11 base roles via fe-/ux- prefix stripping; Owner and Debugger added to field map; success criteria is 11 base roles covered","reason":"compile-context.sh already strips prefixes (lines 25-29). Department variants use identical field requirements. 11 base roles provide full coverage.","alts":["Maintain separate mappings for all 26 agents","Group into fewer roles (e.g., merge qa and qa-code)"]}
{"ts":"2026-02-17T23:10:06Z","agent":"architect","task":"D9","dec":"Token measurement uses char/4 as documented approximation; success criteria framed as character reduction percentage","reason":"Precise tokenization requires a tokenizer dependency (tiktoken, etc.) which violates zero-dependency design. char/4 is the standard approximation used throughout compile-context.sh.","alts":["Add optional tiktoken dependency","Use word-count based estimation"]}
{"ts":"2026-02-17T23:10:07Z","agent":"architect","task":"D10","dec":"Graceful degradation for filter-agent-context.sh: if missing, fall back to current inline jq; follows resolve-tool-permissions.sh guard pattern","reason":"Plugin installations may have partial upgrades. Zero breakage guarantee is a core constraint. The filter is an optimization not a hard requirement.","alts":["Make filter script a hard dependency with install check","Bundle filter logic inline in compile-context.sh"]}
{"ts":"2026-02-17T23:10:08Z","agent":"architect","task":"D11","dec":"JSONL header vs task detection uses positional convention (head -1 / tail -n +2), not heuristic field detection","reason":"Plan JSONL format is structurally fixed: line 1 = header, lines 2+ = tasks. This matches existing compile-context.sh patterns and is enforced by validate-plan.sh.","alts":["Detect header by presence of 'p' and 'n' fields","Add a 'type' field to distinguish header from task lines"]}
{"ts":"2026-02-17T23:10:09Z","agent":"architect","task":"D12","dec":"agent-field-map.md covers 10 artifact types; 7 excluded types documented with rationale (single-consumer, cross-dept handoff, runtime state)","reason":"Filtering benefits come from multi-consumer artifacts where different roles need different fields. Single-consumer and runtime artifacts have no filtering benefit.","alts":["Include all 17+ artifact types in mapping","Exclude nothing, apply identity filter for single-consumer types"]}
{"ts":"2026-02-17T23:30:00Z","agent":"senior","task":"02-02 spec enrichment","dec":"All 4 tasks in plan 02-02 are documentation-only changes to markdown files; ts fields describe manual grep-based verification rather than bats tests","reason":"Agent prompt files (yolo-scout.md, yolo-critic.md, yolo-architect.md) and reference docs (artifact-formats.md) are not executable code. Automated tests would be brittle grep-in-bats wrappers with no value over the manual verification steps documented in each ts field. Phase 01 established this pattern for markdown-only tasks.","alts":["Write bats tests that grep for expected strings in markdown files","Leave ts fields empty for all tasks"]}
{"ts":"2026-02-17T23:30:01Z","agent":"senior","task":"02-02 T1 spec","dec":"Include state.json step union update in T1 spec alongside research.jsonl schema changes","reason":"D13 requires adding 'research' to the step union type in artifact-formats.md line 189. This is in the same file (artifact-formats.md) as the research.jsonl schema, so bundling it in T1 avoids a separate task for a one-line change. The step union update is a direct consequence of the schema enhancement.","alts":["Create separate T5 for state.json step union update","Defer step union update to plan 02-01 which handles execute-protocol.md"]}
{"ts":"2026-02-17T23:30:02Z","agent":"senior","task":"02-02 T2 spec","dec":"Scout In-Workflow Research section positioned after Effort-Based Behavior and before Escalation Table to maintain logical flow","reason":"Effort-Based Behavior describes how Scout intensity varies. In-Workflow Research describes a new invocation mode. Escalation Table and Constraints follow as closing sections. This ordering mirrors yolo-critic.md where protocol sections precede output/constraint sections.","alts":["Place after Output Format section","Place before Effort-Based Behavior"]}
{"ts":"2026-02-17T23:40:00Z","agent":"senior","task":"02-01 spec enrichment","dec":"T1-T4 (documentation-only tasks) have empty ts fields; only T5 (compile-context.sh code change) has ts","reason":"T1-T4 modify markdown tables and prose in execute-protocol.md and company-hierarchy.md. These are not executable code -- bats tests would be brittle grep wrappers with no value. T5 modifies a bash script (compile-context.sh) where bats tests verify actual runtime behavior (jq filtering, token budget, graceful degradation).","alts":["Write bats tests for all 5 tasks including markdown grep checks","Leave ts empty for all tasks"]}
{"ts":"2026-02-17T23:40:01Z","agent":"senior","task":"02-01 T1 sub-op 7","dec":"Architecture step entry gate changed from critique.jsonl to research.jsonl after research step insertion","reason":"The execution chain is Critique -> Research -> Architecture. Architecture predecessor is now the research step, so its entry gate must check research.jsonl (or research skipped), not critique.jsonl. Critique is two steps back; the gate protocol checks immediate predecessor only.","alts":["Keep Architecture checking critique.jsonl (skip over research)","Check both critique.jsonl AND research.jsonl in Architecture gate"]}
{"ts":"2026-02-17T23:40:02Z","agent":"senior","task":"02-01 T5 scope","dec":"Scout codebase section includes INDEX, ARCHITECTURE, PATTERNS but excludes CONCERNS","reason":"Scout has a 1000-token budget. CONCERNS.md is typically the largest codebase mapping file and is not needed for research directives (Scout researches solutions, not problems). INDEX + ARCHITECTURE + PATTERNS provide sufficient codebase awareness within budget constraints.","alts":["Include all 4 codebase files (INDEX, ARCHITECTURE, PATTERNS, CONCERNS)","Include only INDEX.md for minimal codebase awareness"]}
{"ts":"2026-02-17T23:50:00Z","agent":"senior","task":"02-03 T1 spec","dec":"T1 (agent-field-map.md) has no automated tests -- ts field describes manual verification via grep checks","reason":"Reference documentation (Markdown files) cannot be meaningfully tested with bats. Automated tests would be brittle grep wrappers with no value over the verification steps. Consistent with 02-01 and 02-02 pattern for docs-only tasks.","alts":["Write bats tests that grep for expected strings in markdown","Leave ts field empty"]}
{"ts":"2026-02-17T23:50:01Z","agent":"senior","task":"02-03 T2 spec","dec":"filter-agent-context.sh uses nested case statement (BASE_ROLE then TYPE) instead of associative array or external config","reason":"Bash associative arrays are bash 4+ only (macOS ships bash 3.2). Nested case is portable, readable, and matches compile-context.sh pattern. External config adds file I/O overhead and a dependency. Each role-type combination is explicit and greppable.","alts":["Bash 4+ associative array keyed by role_type","External JSON config file with jq filter templates","Per-role functions instead of nested case"]}
{"ts":"2026-02-17T23:50:02Z","agent":"senior","task":"02-03 T2 spec","dec":"Senior mode disambiguation via --mode flag (design|review) instead of separate role names","reason":"Senior is one base role with two operational modes. Adding senior-design and senior-review as separate roles would break the 11-base-role mapping. The --mode flag defaults to design and only changes behavior for senior+plan combination, keeping the interface minimal.","alts":["Two separate roles: senior-design and senior-review","Caller passes explicit field list instead of mode flag"]}
{"ts":"2026-02-17T23:50:03Z","agent":"senior","task":"02-03 T3 spec","dec":"22 bats test cases covering all 11 base roles plus error handling and edge cases","reason":"Full coverage ensures filter correctness before compile-context.sh integration in plan 02-04. Error cases (no args, missing file, unknown role/type, wrong artifact for role) prevent silent failures. Edge cases (prefix stripping, senior mode, scout severity filter) validate architectural decisions D7, D8, D11.","alts":["Minimal 6 tests as originally specified in task action","Separate test files per role"]}
{"ts":"2026-02-18T00:00:00Z","agent":"senior","task":"02-04 spec enrichment","dec":"FILTER_SCRIPT variable set once at top-level scope (after BUDGET, before ARCH_FILE) so all role cases share the same guard","reason":"Avoids repeating the D10 resolution pattern in each case block. Matches the pattern of other top-level cache flags (ARCH_EXISTS, DECISIONS_EXISTS, HAS_CODEBASE). Single resolution point ensures consistent graceful degradation.","alts":["Resolve FILTER_SCRIPT inside each case block that uses it","Create a helper function get_filter_script() like get_tool_restrictions()"]}
{"ts":"2026-02-18T00:00:01Z","agent":"senior","task":"02-04 T3 spec","dec":"Senior case excluded from filter integration -- no JSONL artifact data embedded in senior TOON","reason":"compile-context.sh senior case (lines 364-408) emits architecture, requirements, patterns, conventions. It does NOT embed plan tasks or summary data in the TOON output. Senior receives plan.jsonl directly at execution time via the PLAN_PATH argument passed by execute-protocol.md. Adding embedded plan data would be scope creep and change the senior agent's context consumption pattern.","alts":["Add plan task embedding to senior case (matching dev pattern)","Pass filter to senior for critique.jsonl embedding"]}
{"ts":"2026-02-18T00:00:02Z","agent":"senior","task":"02-04 T5 spec","dec":"--measure outputs to stderr, not stdout; unfiltered size approximated from raw artifact file sizes","reason":"stdout must remain the file path for callers (execute-protocol.md, compile-team-contexts.sh). stderr is the standard channel for diagnostic output. Raw artifact size overestimates unfiltered TOON size but is sufficient for D9 requirement (demonstrate measurable reduction). Re-running the entire case block with FILTER_AVAILABLE=false would be more accurate but doubles execution time.","alts":["Output measurement JSON to stdout after file path on a second line","Re-run entire case block with filter disabled for exact comparison","Write measurement to a separate .measure.json file"]}
{"ts":"2026-02-18T00:00:03Z","agent":"senior","task":"02-04 T5 spec","dec":"--measure flag parsed as first positional arg with shift, not as a getopt-style flag mixed with positional args","reason":"compile-context.sh uses positional args (phase, role, phases-dir, plan-path). Mixing --flags with positional args requires getopt or complex parsing. Putting --measure first and shifting is the simplest pattern that avoids ambiguity.","alts":["Use getopt for mixed flag/positional parsing","Use environment variable COMPILE_CONTEXT_MEASURE=true instead of flag"]}
{"ts":"2026-02-18T00:00:04Z","agent":"senior","task":"02-04 T4 spec","dec":"New test fixtures (filter-test-plan.jsonl, filter-test-summary.jsonl) with rich field content instead of modifying existing minimal fixtures","reason":"Existing valid-plan.jsonl has minimal fields (no mh, obj, ts, v). Filter verification tests need fields that SHOULD be excluded (obj, ch, built) and fields that SHOULD be included (spec, ts, fm). New fixtures provide this without breaking existing tests that depend on valid-plan.jsonl structure.","alts":["Modify existing valid-plan.jsonl to add missing fields","Create fixtures inline in each test case via heredoc"]}
