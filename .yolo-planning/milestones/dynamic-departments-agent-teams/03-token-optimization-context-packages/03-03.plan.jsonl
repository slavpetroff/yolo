{"p":"03","n":"03","t":"Agent Tool Permission Adaptation","w":2,"d":["03-02"],"xd":[],"mh":{"tr":["Tool permissions adapt based on detected project type from detect-stack.sh","Shell-only projects disable npm/Docker-related tool patterns","Library projects restrict non-essential tools (WebSearch, WebFetch) — NEVER Bash (D3)","Default permissions preserved when project type is generic","Existing agent YAML files are not permanently modified (permissions resolved at runtime via soft enforcement D4)"],"ar":[{"p":"config/tool-permissions.json","pv":"file exists and valid JSON","c":"maps project_type -> role -> {add_tools, remove_tools} overrides"},{"p":"scripts/resolve-tool-permissions.sh","pv":"file exists and is executable","c":"resolves agent tool permissions by merging base YAML permissions with project-type overrides"}],"kl":[{"fr":"config/tool-permissions.json","to":"config/project-types.json","vi":"uses same project type IDs (web-app, api-service, cli-tool, library, mobile-app, monorepo, generic)"},{"fr":"scripts/resolve-tool-permissions.sh","to":"scripts/detect-stack.sh","vi":"reads project_type from detect-stack.sh output to determine overrides"},{"fr":"scripts/resolve-tool-permissions.sh","to":"agents/yolo-dev.md","vi":"reads agent YAML frontmatter for base tools list at resolution time"}]},"obj":"Create project-type-aware tool permission resolution so agents get appropriate tools for the detected project type. REQ-06.","sk":["commit"],"fm":["config/tool-permissions.json","scripts/resolve-tool-permissions.sh","tests/unit/resolve-tool-permissions.bats"],"auto":true}
{"id":"T1","tp":"auto","a":"Create config/tool-permissions.json","f":["config/tool-permissions.json"],"v":"jq empty config/tool-permissions.json succeeds; all 7 project types have entries; no entry contains Bash, Read, Glob, Grep, Write, or Edit in any remove_tools array","done":"Tool permission config covers all 7 project types with role-level overrides, core tools never restricted","spec":"Create config/tool-permissions.json with the following exact structure:\n\nTop-level keys:\n  _description: string explaining the file purpose\n  _protected_tools: [\"Bash\",\"Read\",\"Glob\",\"Grep\",\"Write\",\"Edit\"] — documentation only, enforced by resolve-tool-permissions.sh\n  types: object keyed by project type ID (must match config/project-types.json .types[].id exactly)\n\nFor each project type ID, the value is an object keyed by base role name (architect, lead, senior, dev, tester, qa, qa-code, security, scout, debugger, critic, owner). Each role object has:\n  add_tools: string[] — tools to add beyond the agent YAML base set\n  remove_tools: string[] — tools to remove from the agent YAML base set\n\nCRITICAL CONSTRAINT (Architecture D3): NEVER include Bash, Read, Glob, Grep, Write, or Edit in any remove_tools array. Only WebSearch, WebFetch, and NotebookEdit are valid remove_tools candidates.\n\nPer-type overrides:\n  generic: empty object {} — no role overrides (all agents keep base tools)\n  web-app: empty object {} — full toolset appropriate for web projects\n  api-service: empty object {} — full toolset appropriate for API projects\n  mobile-app: empty object {} — full toolset appropriate for mobile projects\n  monorepo: empty object {} — full toolset, sub-type detection handled elsewhere\n  cli-tool:\n    architect: { add_tools: [], remove_tools: [] } — keep WebSearch/WebFetch for research\n    scout: { add_tools: [], remove_tools: [] } — keep WebSearch/WebFetch for research\n    critic: { add_tools: [], remove_tools: [] } — keep WebSearch/WebFetch for gap analysis\n    lead: { add_tools: [], remove_tools: [\"WebFetch\"] } — CLI projects rarely need web fetching during planning\n  library:\n    architect: { add_tools: [], remove_tools: [] } — keep WebSearch/WebFetch for API research\n    lead: { add_tools: [], remove_tools: [\"WebFetch\"] } — library projects rarely need web fetching during planning\n    scout: { add_tools: [], remove_tools: [] } — keep research tools\n    critic: { add_tools: [], remove_tools: [] } — keep research tools\n\nFile must be valid JSON. Use jq -e '.' to validate. All 7 type IDs from project-types.json must be present as keys under .types. No role entry may have a remove_tools item that is in _protected_tools.\n\nFollow config/model-profiles.json formatting style: 2-space indentation, trailing newline.","ts":"Test file: tests/unit/resolve-tool-permissions.bats (T3 covers this). Validation tests for T1 config specifically:\n  1. 'tool-permissions.json exists and is valid JSON' — run jq -e '.' config/tool-permissions.json, assert_success\n  2. 'tool-permissions.json has all 7 project type entries' — jq '.types | keys | length' == 7, verify keys match project-types.json IDs exactly\n  3. 'tool-permissions.json: no protected tool in any remove_tools' — jq query across all types/roles: select(.remove_tools[] | IN(\"Bash\",\"Read\",\"Glob\",\"Grep\",\"Write\",\"Edit\")) should return empty\n  4. 'tool-permissions.json: generic type has no role overrides' — jq '.types.generic | length' == 0\n  5. 'tool-permissions.json: cli-tool has lead override with WebFetch removed' — jq '.types[\"cli-tool\"].lead.remove_tools | index(\"WebFetch\")' is not null"}
{"id":"T2","tp":"auto","a":"Create scripts/resolve-tool-permissions.sh","f":["scripts/resolve-tool-permissions.sh"],"v":"Script exits 0 for valid inputs; outputs valid JSON with role, project_type, base_tools, tools, disallowed_tools keys; generic type returns base tools unchanged","done":"Script resolves tool permissions by merging YAML base with project-type overrides, outputs JSON","spec":"Create scripts/resolve-tool-permissions.sh with:\n\nShebang + header:\n  #!/usr/bin/env bash\n  # resolve-tool-permissions.sh — Resolve agent tool permissions per project type\n  # Merges base tools from agent YAML frontmatter with project-type overrides.\n  # Output consumed by compile-context.sh for soft enforcement (D4).\n  #\n  # Usage: resolve-tool-permissions.sh --role <role> --project-dir <path> [--config <tool-permissions.json>]\n  # Output: JSON {role, project_type, base_tools, tools, disallowed_tools}\n  # Exit: 0=success, 1=error\n  set -euo pipefail\n\njq dependency check: same pattern as detect-stack.sh lines 12-15.\n\nArgument parsing: use while-shift loop (not getopts):\n  --role: required, agent role name (e.g. dev, fe-dev, architect)\n  --project-dir: required, path to project root\n  --config: optional, defaults to $SCRIPT_DIR/../config/tool-permissions.json\n  Validate: if --role or --project-dir missing, print usage to stderr, exit 1.\n\nDepartment/base-role extraction: same case pattern as compile-context.sh lines 25-30:\n  fe-* -> DEPT=fe, BASE_ROLE=${ROLE#fe-}\n  ux-* -> DEPT=ux, BASE_ROLE=${ROLE#ux-}\n  owner -> DEPT=shared, BASE_ROLE=owner\n  * -> DEPT=backend, BASE_ROLE=$ROLE\n\nStep 1 — Detect project type:\n  SCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\n  DETECT_SCRIPT=\"$SCRIPT_DIR/detect-stack.sh\"\n  Validate detect-stack.sh exists, else stderr + exit 1.\n  PROJECT_TYPE=$(bash \"$DETECT_SCRIPT\" \"$PROJECT_DIR\" | jq -r '.project_type // \"generic\"')\n  If PROJECT_TYPE is empty or null, default to \"generic\".\n\nStep 2 — Read base tools from agent YAML frontmatter:\n  AGENTS_DIR=\"$SCRIPT_DIR/../agents\"\n  AGENT_FILE=\"$AGENTS_DIR/yolo-${ROLE}.md\"\n  If AGENT_FILE does not exist, stderr 'Agent file not found: yolo-{ROLE}.md', exit 1.\n  Extract tools line: grep '^tools:' \"$AGENT_FILE\" | sed 's/^tools: *//' | tr -d ' '\n  Split by comma into BASE_TOOLS_CSV (e.g. \"Read,Glob,Grep,Write,Edit,Bash\")\n  Also extract disallowedTools: grep '^disallowedTools:' | sed 's/^disallowedTools: *//' | tr -d ' '\n  Split into BASE_DISALLOWED_CSV\n\nStep 3 — Read overrides from tool-permissions.json:\n  CONFIG_FILE defaults to \"$SCRIPT_DIR/../config/tool-permissions.json\"\n  Validate CONFIG_FILE exists, else stderr + exit 1.\n  Use jq to extract overrides for PROJECT_TYPE and BASE_ROLE:\n    ADD_TOOLS=$(jq -r --arg pt \"$PROJECT_TYPE\" --arg role \"$BASE_ROLE\" '.types[$pt][$role].add_tools // [] | join(\",\")' \"$CONFIG_FILE\")\n    REMOVE_TOOLS=$(jq -r --arg pt \"$PROJECT_TYPE\" --arg role \"$BASE_ROLE\" '.types[$pt][$role].remove_tools // [] | join(\",\")' \"$CONFIG_FILE\")\n  If project type not found in config (unknown type), fall back to generic: re-read with --arg pt \"generic\"\n\nStep 4 — Protected tools guard:\n  PROTECTED=\"Bash,Read,Glob,Grep,Write,Edit\"\n  Before applying remove_tools, filter out any protected tool:\n  Use jq or bash loop to ensure no protected tool appears in final remove list.\n  If a protected tool was in remove_tools, silently drop it (do not error).\n\nStep 5 — Merge and output JSON:\n  Single jq call that:\n    a) Takes base_tools CSV, add_tools CSV, remove_tools CSV as --arg\n    b) Splits base_tools by comma into array\n    c) Adds add_tools items not already present\n    d) Removes remove_tools items\n    e) Takes base_disallowed CSV\n    f) Adds remove_tools to disallowed (these become soft-disallowed)\n    g) Always includes EnterPlanMode and ExitPlanMode in disallowed_tools\n    h) Outputs: {\"role\":\"$ROLE\",\"project_type\":\"$PROJECT_TYPE\",\"base_tools\":[...],\"tools\":[...],\"disallowed_tools\":[...]}\n  Output JSON to stdout. Exit 0.\n\nError handling:\n  - Missing jq: stderr + exit 1\n  - Missing --role or --project-dir: usage + exit 1\n  - Missing agent file: stderr + exit 1\n  - Missing config file: stderr + exit 1\n  - Missing detect-stack.sh: stderr + exit 1\n  - detect-stack.sh failure: fall back to PROJECT_TYPE=\"generic\"\n  - Unknown project type in config: fall back to generic overrides\n\nMake executable: chmod +x after creating.","ts":"Test file: tests/unit/resolve-tool-permissions.bats (T3). Key integration tests for T2 script:\n  1. 'resolves dev tools for generic project (no changes)' — create empty project dir, run with --role dev, verify tools array matches yolo-dev.md base tools exactly\n  2. 'resolves architect tools for cli-tool project' — create project dir with bin/ + scripts/, run with --role architect, verify WebSearch and WebFetch still present (cli-tool architect has no overrides)\n  3. 'resolves lead tools for library project' — create project dir with src/lib.rs + Cargo.toml, run with --role lead, verify WebFetch removed from tools, WebFetch in disallowed_tools\n  4. 'falls back to generic for unknown project type' — mock detect-stack.sh to return unknown type, verify base tools unchanged\n  5. 'always includes EnterPlanMode and ExitPlanMode in disallowed_tools' — any role+type combo, verify both always present\n  6. 'never removes protected tools even if config has them' — create temp config with Bash in remove_tools, verify Bash still in output tools\n  7. 'exits 1 on missing --role' — run without --role, assert_failure\n  8. 'exits 1 on missing agent file' — run with --role nonexistent, assert_failure\n  9. 'outputs valid JSON' — run any valid combo, pipe output to jq -e '.', assert_success"}
{"id":"T3","tp":"auto","a":"Create tests/unit/resolve-tool-permissions.bats","f":["tests/unit/resolve-tool-permissions.bats"],"v":"bats tests/unit/resolve-tool-permissions.bats passes all tests","done":"11+ BATS tests covering config validation, permission resolution, fallbacks, error handling, and protected tools guard","spec":"Create tests/unit/resolve-tool-permissions.bats following existing test patterns (see tests/unit/resolve-agent-model.bats, tests/unit/detect-stack-classify.bats).\n\nSetup block:\n  #!/usr/bin/env bats\n  # resolve-tool-permissions.bats — Unit tests for tool permission resolution\n  setup() {\n    load '../test_helper/common'\n    load '../test_helper/fixtures'\n    load '../test_helper/mock_stdin'\n    mk_test_workdir\n    SUT=\"$SCRIPTS_DIR/resolve-tool-permissions.sh\"\n    TOOL_PERMS_CONFIG=\"$CONFIG_DIR/tool-permissions.json\"\n    # Override CLAUDE_CONFIG_DIR to avoid real skills\n    export CLAUDE_CONFIG_DIR=\"$TEST_WORKDIR/mock-claude\"\n    mkdir -p \"$CLAUDE_CONFIG_DIR/skills\"\n  }\n\nHelper function:\n  run_resolve() {\n    run bash \"$SUT\" --role \"$1\" --project-dir \"$TEST_WORKDIR\" --config \"$TOOL_PERMS_CONFIG\"\n  }\n\nConfig validation tests (5 tests):\n  1. @test 'tool-permissions.json exists and is valid JSON' — run jq -e '.' \"$TOOL_PERMS_CONFIG\", assert_success\n  2. @test 'tool-permissions.json has all 7 project type entries' — jq '.types | keys | length' == 7. Also verify exact keys: generic, web-app, api-service, cli-tool, library, mobile-app, monorepo\n  3. @test 'tool-permissions.json: no protected tool in any remove_tools' — jq '[.types[][].remove_tools // [] | .[] | select(. == \"Bash\" or . == \"Read\" or . == \"Glob\" or . == \"Grep\" or . == \"Write\" or . == \"Edit\")] | length' == 0\n  4. @test 'tool-permissions.json: generic type has empty overrides' — jq '.types.generic | length' == 0\n  5. @test 'tool-permissions.json: cli-tool lead removes WebFetch' — jq '.types[\"cli-tool\"].lead.remove_tools | index(\"WebFetch\")' is not null\n\nResolution tests (6+ tests):\n  6. @test 'generic project: dev tools unchanged' — No project files in TEST_WORKDIR (empty project = generic). run_resolve dev. Parse output JSON. Verify .tools contains [\"Read\",\"Glob\",\"Grep\",\"Write\",\"Edit\",\"Bash\"]. Verify .project_type == \"generic\"\n  7. @test 'cli-tool project: lead loses WebFetch' — Create bin/ + scripts/ dirs in TEST_WORKDIR (triggers cli-tool detection per project-types.json). run_resolve lead. Verify .tools does NOT contain \"WebFetch\". Verify .disallowed_tools contains \"WebFetch\"\n  8. @test 'library project: lead loses WebFetch' — Create src/lib.rs + touch Cargo.toml in TEST_WORKDIR. run_resolve lead. Verify .tools does NOT contain \"WebFetch\"\n  9. @test 'web-app project: architect keeps all tools' — Create package.json with react dep. run_resolve architect. Verify .tools contains \"WebSearch\" and \"WebFetch\"\n  10. @test 'unknown project type falls back to generic' — Override detect-stack.sh with mock that outputs {\"project_type\":\"unknown-type\"}. Run resolve. Verify base tools unchanged (same as generic). Technique: create mock detect-stack.sh in TEST_WORKDIR, prepend its dir to PATH, or use --config with custom config.\n  11. @test 'role not in overrides gets base tools unchanged' — Run for cli-tool project with --role dev (dev has no overrides in cli-tool). Verify dev tools unchanged.\n\nProtected tools tests (1 test):\n  12. @test 'protected tools never removed even if in config' — Create temp config in TEST_WORKDIR with Bash in remove_tools for generic.dev. Run with --config pointing to temp config. Verify .tools still contains \"Bash\".\n\nAlways-disallowed tests (1 test):\n  13. @test 'EnterPlanMode and ExitPlanMode always in disallowed_tools' — Run any valid role+project combo. Verify .disallowed_tools contains both \"EnterPlanMode\" and \"ExitPlanMode\".\n\nError handling tests (3 tests):\n  14. @test 'exits 1 with no arguments' — run bash \"$SUT\", assert_failure, assert_output --partial 'Usage'\n  15. @test 'exits 1 for nonexistent agent role' — run bash \"$SUT\" --role nonexistent-role --project-dir \"$TEST_WORKDIR\", assert_failure, assert_output --partial 'Agent file not found'\n  16. @test 'exits 1 for missing config file' — run bash \"$SUT\" --role dev --project-dir \"$TEST_WORKDIR\" --config /nonexistent/config.json, assert_failure\n\nOutput format test (1 test):\n  17. @test 'output is valid JSON with expected keys' — run_resolve dev. Pipe output to jq -e '.role and .project_type and .base_tools and .tools and .disallowed_tools'. assert_success.\n\nTotal: 17 tests. Each test uses assert_success/assert_failure from bats-assert. JSON parsing uses jq. Project type detection uses real detect-stack.sh against fixture project dirs (no mocking needed for most tests — just create the right files in TEST_WORKDIR).","ts":""}

