{"id":"C1","cat":"risk","sev":"critical","q":"build-reference-packages.sh uses awk to extract sections by step header from execute-protocol.md but Markdown has nested headers, code blocks with # characters. Fragile awk parsing of Markdown with embedded code blocks is a known failure mode.","ctx":"Plan 03-02 T1 says 'Uses awk to extract sections by step header' against execute-protocol.md (490 lines, 30KB)","sug":"Either add structured delimiters to execute-protocol.md, or hand-author packages (C10 alternative), or use robust parser. Test with actual file content.","st":"addressed","res":"Architecture D1: Hand-author packages as static TOON files. build-reference-packages.sh becomes a sync-checker, not a generator. No awk extraction of Markdown."}
{"id":"C2","cat":"gap","sev":"major","q":"03-02 creates per-role packages for 9 base roles only. 17 department-prefixed roles (fe-dev, ux-architect, etc.) unaddressed.","ctx":"compile-context.sh already maps fe-dev -> BASE_ROLE=dev. Plan is silent on whether fe-dev loads packages/dev.toon or packages/fe-dev.toon.","sug":"Explicitly state department-prefixed roles reuse base-role package. Add BATS test verifying fe-dev context includes packages/dev.toon.","st":"addressed","res":"Architecture D2: Department-prefixed roles reuse base-role packages via compile-context.sh BASE_ROLE mapping (line 27). fe-dev loads packages/dev.toon. BATS test required."}
{"id":"C3","cat":"risk","sev":"major","q":"Plan 03-03 T1 proposes removing Bash tool from library project Dev agents. Dev agents rely on Bash for TDD protocol (run tests, verify FAIL/PASS).","ctx":"Agent yolo-dev.md has tools: Read,Glob,Grep,Write,Edit,Bash. execute-protocol.md Step 6 requires running tests.","sug":"Never remove Bash from Dev. Restrict non-essential tools instead (WebSearch, NotebookEdit for library projects).","st":"addressed","res":"Architecture D3: Never remove Bash from Dev. Only restrict non-essential tools (WebSearch, WebFetch, NotebookEdit) per project type. Bash/Read/Glob/Grep/Write/Edit always available."}
{"id":"C4","cat":"gap","sev":"major","q":"No mechanism specified for HOW resolved tool permissions reach agent spawning. Task tool reads agent YAML frontmatter directly.","ctx":"resolve-tool-permissions.sh outputs JSON but nothing specifies how that JSON gets consumed by Task tool or compile-context.sh.","sug":"Clarify integration path: pass resolved disallowedTools to Task tool prompt, or modify agent YAML at init time, or include in compiled context (soft enforcement).","st":"addressed","res":"Architecture D4: Soft enforcement via compiled context. resolve-tool-permissions.sh output included in .ctx-{role}.toon as tool_restrictions section. Agent prompt includes 'Do NOT use: {tools}' directive. Hard enforcement stays in YAML disallowedTools for EnterPlanMode/ExitPlanMode only."}
{"id":"C5","cat":"gap","sev":"major","q":"No measurable token reduction baseline or target defined. How will acceptance criterion 'measurably reduced' be verified?","ctx":"Smaller compiled context does not equal smaller token usage. No measurement mechanism for actual LLM token consumption.","sug":"Measure compiled context file sizes (chars/4 = approx tokens) before/after for each role. Define minimum reduction target (e.g., 30%). Add BATS test comparing old vs new size.","st":"addressed","res":"Architecture D5: Measure compiled context file size (chars/4). Minimum 25% reduction target for roles with reference content. BATS test compares before/after. Note: metric applies to total context including package content vs previous full @-reference paths."}
{"id":"C6","cat":"risk","sev":"major","q":"Extracted reference packages may lose critical cross-references between steps. Dev package with only Step 6 loses entry gate template, escalation chain, TDD protocol spanning Steps 5-7.","ctx":"Step 6 references Step 5 test-plan.jsonl, Step 7 Senior escalation, Verification Gate Protocol section.","sug":"Include in each package: primary step(s), Verification Gate Protocol template, escalation chain, cross-step references. Add shared preamble.","st":"addressed","res":"Architecture D1 + C4 component spec: Each hand-authored package includes primary step(s) protocol, verification gate template, escalation chain, cross-step references, artifact schemas, shared preamble (commit format, escalation protocol). Hand-authoring ensures no cross-references lost."}
{"id":"C7","cat":"question","sev":"major","q":"03-04 says 'backward compatible if packages/ missing' but also 'no full execute-protocol.md reference'. These conflict -- if packages missing AND full files not referenced, agents get no protocol context.","ctx":"Must-have truth says no full file. Fallback says backward compatible.","sug":"Fallback should reference full files when packages/ absent. 'No full file' must-have applies only when packages exist. Add BATS test for fallback.","st":"addressed","res":"Architecture D6: When packages/ exists, use per-role package (no full file). When packages/ absent, fall back to full @-reference files (backward compatible). 'No full file' applies only when packages exist. BATS test verifies both paths."}
{"id":"C8","cat":"risk","sev":"minor","q":"validate-gates.sh must handle complex OR-conditions (artifact exists OR step skipped) for all 10 steps with different artifact types.","ctx":"Each step has conditional entry with .execution-state.json lookups + file existence checks.","sug":"Design as lookup table (step -> artifact path + validation command) rather than hardcoded per-step logic.","st":"addressed","res":"Architecture D7: Lookup table design using case statement (bash 3.2 compatible). Maps step_name to entry_artifact, validation_cmd, skip_check_field. Data-driven, not 10 separate if/then blocks."}
{"id":"C9","cat":"improvement","sev":"minor","q":"compile-context.sh currently does NOT reference protocol files. Adding packages may INCREASE token usage if packages are larger than zero (current compiled context has zero protocol content).","ctx":"compile-context.sh generates .ctx-{role}.toon with phase/goal/reqs/conventions/patterns. Protocol files loaded via agent YAML body or Task prompt.","sug":"Verify WHERE agents currently receive protocol context before modifying compile-context.sh. Map current loading path.","st":"addressed","res":"Architecture D5 + integration_notes: Verified that agents receive protocol context via (1) agent YAML body (inline instructions) and (2) execute-protocol.md @-references in Task prompts. Packages replace the Task prompt @-references, not the YAML body. Net token change: packages (1-3KB) replace full @-reference (30KB execute-protocol.md). compile-context.sh package inclusion is additive but far smaller than the full file it replaces in Task prompts."}
{"id":"C10","cat":"alternative","sev":"minor","q":"Instead of awk extraction (03-02 T1), hand-author reference packages as TOON files maintained alongside execute-protocol.md.","ctx":"references/departments/ already uses hand-authored TOON pattern. Script extraction introduces fragile generated-from-source pattern.","sug":"Hand-authored packages avoid fragile extraction. Add BATS test validating package content against execute-protocol.md keywords for sync.","st":"addressed","res":"Architecture D1: Adopted hand-authored approach. build-reference-packages.sh repurposed as sync-checker that validates packages contain expected keywords from source files. BATS test ensures no drift."}
{"id":"C11","cat":"gap","sev":"minor","q":"03-01 T4 specifies 22+ BATS tests but does not mention test fixtures for valid/invalid plans, mock phase dirs.","ctx":"Existing tests use tests/test_helper/ with common.bash and fixtures.bash creating TEST_WORKDIR.","sug":"Add fixture creation to T4: valid-plan.jsonl, invalid-plan.jsonl, mock-phase-dir with various artifact combinations.","st":"addressed","res":"Architecture R4: T4 in 03-01 plan explicitly creates fixture files: valid-plan.jsonl, invalid-plan.jsonl, mock-phase-dir with artifact combinations. Fixture creation is part of test task, not deferred. Uses existing tests/test_helper/ pattern."}
{"id":"C12","cat":"risk","sev":"minor","q":"Wave ordering assumes 03-01 and 03-02 both read execute-protocol.md without modifying it. Only 03-04 modifies it.","ctx":"validate-gates.sh reads enforcement contract table. build-reference-packages.sh extracts step content. Neither modifies in wave 1.","sug":"Document assumption: enforcement contract table stays in execute-protocol.md, not moved to packages.","st":"addressed","res":"Architecture D8: Documented assumption. Wave 1 plans (03-01, 03-02) read-only on execute-protocol.md. Only wave 2 plan 03-04 modifies it. Enforcement contract table stays in execute-protocol.md, not moved to packages."}
