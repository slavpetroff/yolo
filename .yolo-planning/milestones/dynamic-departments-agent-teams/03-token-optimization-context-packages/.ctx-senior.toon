phase: 03
goal: Offload more LLM work to scripts, reorganize references into department packages, adapt agent tool permissions per project type

architecture:
  phase: 03
  goal: Offload more LLM work to scripts, reorganize references into department packages, adapt agent tool permissions per project type
  
  tech_decisions[8]{decision,rationale,alternatives,critique_refs}:
    D1: Hand-author reference packages as static TOON files, not script-generated awk extraction
      rationale: execute-protocol.md has nested headers, code blocks with # chars, and embedded JSON — awk extraction is fragile (C1). references/departments/ already uses hand-authored TOON pattern (C10). Hand-authored packages ensure correctness, include cross-step references and shared preamble (C6), and are maintainable. A BATS sync test validates packages contain expected keywords from execute-protocol.md to prevent drift.
      alternatives: awk extraction with structured delimiters, robust Markdown parser (not bash/jq compatible)
      critique_refs: C1, C6, C10
  
    D2: Department-prefixed roles reuse base-role packages via compile-context.sh BASE_ROLE mapping
      rationale: compile-context.sh already maps fe-dev to BASE_ROLE=dev (line 27). fe-dev loads packages/dev.toon, ux-architect loads packages/architect.toon. No separate packages for 17 department-prefixed roles. Department-specific conventions come from dept convention system (already in compile-context.sh). BATS test verifies fe-dev compiled context includes packages/dev.toon reference.
      alternatives: separate fe-dev.toon packages (9x17=153 files, unmaintainable), dept-prefix lookup table
      critique_refs: C2
  
    D3: Never remove Bash from Dev agents — restrict non-essential tools only
      rationale: Dev agents rely on Bash for TDD RED/GREEN checks (execute-protocol.md Step 6). Removing Bash breaks the core TDD workflow (C3). Instead, restrict non-essential tools per project type: WebSearch/WebFetch for library projects, NotebookEdit for CLI projects. Bash, Read, Glob, Grep, Write, Edit are always available to Dev.
      alternatives: remove Bash from library Dev (breaks TDD), add Bash back at runtime (complex, no mechanism)
      critique_refs: C3
  
    D4: Tool permissions injected via soft enforcement in compiled context, not hard YAML modification
      rationale: Task tool reads agent YAML frontmatter directly — no mechanism to inject runtime tool restrictions into YAML (C4). Instead: resolve-tool-permissions.sh outputs JSON, compile-context.sh includes resolved disallowed_tools in .ctx-{role}.toon, agent prompt includes "Do NOT use: {tools}" directive. execute-protocol.md agent spawn instructions reference resolved permissions. This is soft enforcement (agent instruction) not hard enforcement (YAML block). Hard enforcement reserved for EnterPlanMode/ExitPlanMode which stay in YAML disallowedTools.
      alternatives: modify agent YAML at init time (breaks plugin model), pass to Task tool prompt directly (fragile, no centralized config)
      critique_refs: C4
  
    D5: Token reduction measured by compiled context file size (chars/4), minimum 25% target
      rationale: No mechanism for actual LLM token consumption measurement (C5). Proxy metric: compiled context file size in chars divided by 4 approximates tokens. Measure before (current compile-context.sh output) and after (with packages). Minimum target: 25% reduction for roles that currently load full reference files. BATS test compares old vs new compiled context size per role. Note: if current compile-context.sh output includes zero protocol content (C9), the reduction applies to the NEW total (package content replaces what agents previously loaded via @-references to full files).
      alternatives: token counting API (not available), manual measurement (not repeatable)
      critique_refs: C5, C9
  
    D6: Fallback behavior: packages absent means full @-reference files used (backward compatible)
      rationale: C7 identified contradiction between "backward compatible if packages/ missing" and "no full execute-protocol.md reference." Resolution: when packages/ directory exists, compile-context.sh includes per-role package instead of full files. When packages/ directory does not exist (pre-Phase-3 state), compile-context.sh includes full @-reference files as before. The "no full file" rule applies ONLY when packages exist. BATS test verifies both paths.
      alternatives: always require packages (breaks backward compatibility), always include full files (no token savings)
      critique_refs: C7
  
    D7: validate-gates.sh uses lookup table design, not hardcoded per-step logic
      rationale: All 10 steps have different artifact types and conditional logic (C8). A data-driven lookup table (associative array or case statement mapping step name to artifact path + validation command) is more maintainable than 10 separate if/then blocks. Table structure: step_name -> entry_artifact, validation_cmd, skip_check_field. Lookup table is sourced from a JSON config or embedded in the script as a case statement (bash 3.2 compatible, no associative arrays).
      alternatives: hardcoded per-step branches (fragile, duplicative), external JSON config (adds jq dependency per gate check)
      critique_refs: C8
  
    D8: Wave 1 scripts read execute-protocol.md without modifying it — documented assumption
      rationale: validate-gates.sh reads the enforcement contract table. Hand-authored packages reference execute-protocol.md step content. Neither modifies execute-protocol.md in wave 1. Only 03-04 (wave 2) modifies execute-protocol.md to add script references. This ordering assumption must be documented in plan dependencies (C12).
      alternatives: move enforcement table to separate file (unnecessary complexity)
      critique_refs: C12
  
  components[6]{name,responsibility,interface}:
    C1: scripts/validate-plan.sh
      responsibility: Validates plan.jsonl structure — header keys, task keys, wave ordering, no circular deps. Replaces LLM-based plan validation during QA step.
      interface: INPUT --plan {path}. OUTPUT JSON {valid:bool,errors:[]}. EXIT 0=valid, 1=invalid.
  
    C2: scripts/validate-gates.sh
      responsibility: Validates verification gate artifacts for a given step. Checks entry artifact existence per enforcement contract table. Handles skip status from .execution-state.json. Uses lookup table for step-to-artifact mapping.
      interface: INPUT --step {step_name} --phase-dir {path}. OUTPUT JSON {gate:pass|fail,step:str,missing:[]}. EXIT 0=pass, 1=fail.
  
    C3: scripts/generate-execution-state.sh
      responsibility: Generates initial .execution-state.json from plan.jsonl files in phase directory. Replaces inline JSON construction in execute-protocol.md Step 3.
      interface: INPUT --phase-dir {path} --phase {N}. OUTPUT writes .execution-state.json. EXIT 0=success, 1=error.
  
    C4: references/packages/{role}.toon (9 files)
      responsibility: Self-contained per-role reference packages. Each contains: primary step(s) protocol, verification gate template, escalation chain, cross-step references, artifact schemas produced/consumed, shared preamble (commit format, escalation protocol). Hand-authored, maintained alongside execute-protocol.md.
      interface: Static TOON files. Read by compile-context.sh. 9 files: architect, lead, senior, dev, tester, qa, qa-code, critic, security. Department-prefixed roles reuse base-role packages.
  
    C5: config/tool-permissions.json + scripts/resolve-tool-permissions.sh
      responsibility: Maps project type to per-role tool restriction overrides. resolve-tool-permissions.sh merges base agent YAML tools with project-type overrides from tool-permissions.json. Output consumed by compile-context.sh for soft enforcement in compiled context.
      interface: INPUT --role {role} --project-dir {path}. OUTPUT JSON {role,project_type,tools:[],disallowed_tools:[]}. Uses detect-stack.sh for project type.
  
    C6: scripts/compile-context.sh (modified)
      responsibility: Extended to include per-role reference package path and resolved tool permissions in compiled context. Backward compatible when packages/ absent. Token budget enforcement accounts for package content size.
      interface: Same as current. OUTPUT now includes reference_package and tool_restrictions sections in .ctx-{role}.toon.
  
  data_flow[4]{from,to,protocol}:
    DF1: detect-stack.sh -> resolve-tool-permissions.sh
      protocol: detect-stack.sh detects project type (e.g. "cli-tool"). resolve-tool-permissions.sh calls detect-stack.sh, reads project type, looks up overrides in tool-permissions.json.
  
    DF2: resolve-tool-permissions.sh -> compile-context.sh
      protocol: compile-context.sh calls resolve-tool-permissions.sh for the current role. Output JSON parsed via jq. disallowed_tools array included in .ctx-{role}.toon as tool_restrictions section.
  
    DF3: references/packages/{role}.toon -> compile-context.sh
      protocol: compile-context.sh resolves BASE_ROLE from ROLE (existing mapping). If references/packages/{BASE_ROLE}.toon exists, includes content or @-reference in compiled context. If not found, falls back to full @-reference files (D6).
  
    DF4: validate-gates.sh + validate-plan.sh -> execute-protocol.md
      protocol: execute-protocol.md updated to reference validate-gates.sh for entry gate checks and validate-plan.sh for plan validation. generate-execution-state.sh replaces inline JSON construction in Step 3. These are additive references — all existing protocol content preserved.
  
  constraints[5]:
    CN1: bash 3.2 compatible — no associative arrays, no declare -A, no ${!arr[@]}
    CN2: zero dependencies — jq only, no npm/pip/external tools
    CN3: 606 regression baseline must pass after all changes
    CN4: backward compatible — packages/ absent falls back to full reference files
    CN5: agent YAML files are static plugin assets — never modified at runtime
  
  risks[4]{risk,impact,mitigation}:
    R1: Hand-authored packages drift from execute-protocol.md source
      impact: Agents receive stale protocol instructions, causing step failures
      mitigation: BATS sync test validates each package contains expected section keywords from execute-protocol.md. Test runs in regression suite. Any execute-protocol.md change triggers package review.
  
    R2: Soft tool enforcement ignored by agents
      impact: Agent uses restricted tool despite compiled context instruction
      mitigation: Acceptable for phase 3 — soft enforcement covers 95% of cases. Hard enforcement via hooks can be added in future phase if needed. EnterPlanMode/ExitPlanMode remain hard-enforced via YAML disallowedTools.
  
    R3: Token budget math changes when packages add content to previously-empty protocol section
      impact: Compiled context exceeds token budget, gets truncated, loses critical content
      mitigation: compile-context.sh enforce_budget() already handles truncation. Package content is small (1-3KB per role). Budget enforcement accounts for package size. BATS test verifies compiled context stays within budget after package inclusion.
  
    R4: Test fixtures missing for validation scripts
      impact: BATS tests cannot exercise edge cases, false confidence in script correctness
      mitigation: T4 in 03-01 plan explicitly creates fixture files: valid-plan.jsonl, invalid-plan.jsonl, mock-phase-dir with artifact combinations. Fixture creation is part of test task, not deferred.
  
  integration_notes:
    build-reference-packages.sh: Removed from architecture. Packages are hand-authored, not script-generated. The script becomes a sync-checker that validates packages match expected keywords from source files, not a generator.
    compile-context.sh: Gets new helper get_reference_package() that resolves packages/{BASE_ROLE}.toon. Gets new section in output for tool_restrictions from resolve-tool-permissions.sh.
    execute-protocol.md: Additive updates only — references to validate-gates.sh, validate-plan.sh, generate-execution-state.sh, resolve-tool-permissions.sh. No existing content removed. Enforcement contract table stays in execute-protocol.md (D8).
    protocol_context_flow: Currently agents receive protocol context via agent YAML body (inline instructions) and execute-protocol.md @-references in Task prompts. Packages replace the @-references with smaller, role-specific content. Agent YAML bodies are not modified.


patterns: @.yolo-planning/codebase/PATTERNS.md

conventions[15]{category,rule}:
  file-structure,Commands are kebab-case .md files in commands/
  naming,Agents named yolo-{role}.md or yolo-{dept}-{role}.md in agents/
  naming,Scripts are kebab-case .sh files in scripts/
  naming,Phase directories follow {NN}-{slug}/ pattern
  naming,Plan files named {NN-MM}.plan.jsonl, summaries {NN-MM}.summary.jsonl
  style,Commits follow {type}({scope}): {desc} format, one commit per task
  style,Stage files individually with git add, never git add . or git add -A
  style,Shell scripts use set -u minimum, set -euo pipefail for critical scripts
  tooling,Use jq for all JSON parsing, never grep/sed on JSON
  style,YAML frontmatter description must be single-line (multi-line breaks discovery)
  style,No prettier-ignore comment before YAML frontmatter, use .prettierignore instead
  patterns,All hooks route through hook-wrapper.sh for graceful degradation (DXP-01)
  patterns,Zero-dependency design: no package.json, npm, or build step
  tooling,All scripts target bash, not POSIX sh
  patterns,Plugin cache resolution via ls | sort -V | tail -1, never glob expansion
