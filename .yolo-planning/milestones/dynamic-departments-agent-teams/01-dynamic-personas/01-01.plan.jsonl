{"p":"01-01","n":"Project Type Config & Classification","t":3,"w":1,"mh":["REQ-02"],"obj":"Create config/project-types.json with 6 extensible type definitions and enhance detect-stack.sh to output project_type classification based on stack detection signals.","sk":["commit"],"fm":["config/project-types.json","scripts/detect-stack.sh"]}
{"id":"01-01-01","n":"Create project type configuration","f":["config/project-types.json"],"d":[],"ac":["config/project-types.json exists with 6 type entries: web-app, api-service, cli-tool, library, mobile-app, monorepo","Each type has: id, name, detect signals (file patterns, stack matches), department mappings for backend/frontend/uiux","Each type has ux_focus field mapping interface type (UI design, help text, API docs, API surface, UI gestures, per-package)","JSON is valid and parseable by jq","Extensible: users can add custom types by adding entries to the array"],"spec":"Create config/project-types.json. Top-level JSON object with keys: _description (string, usage note), _priority_order (array of type IDs in tie-breaking order: [monorepo, mobile-app, web-app, api-service, cli-tool, library, generic]), types (array of 7 objects). Each type object has: id (string, kebab-case), name (string, human label), priority (int, higher wins ties: monorepo=7, mobile-app=6, web-app=5, api-service=4, cli-tool=3, library=2, generic=1), detect (array of signal objects with pattern and weight fields), department_conventions (object with backend/frontend/uiux keys, each containing conventions block), ux_focus (object with focus_areas array, testing_approach string, artifact_types array, vocabulary object). Signal patterns reuse detect-stack.sh format: file paths (e.g. 'routes/', 'src/lib.rs') for file existence, and 'file:dep' for dependency detection (e.g. 'package.json:react'). Weight is integer 1-10. Type definitions: (1) web-app: detect=[{pattern:'package.json:react',w:8},{pattern:'package.json:vue',w:8},{pattern:'package.json:svelte',w:8},{pattern:'package.json:next',w:9},{pattern:'package.json:nuxt',w:8},{pattern:'package.json:angular',w:8},{pattern:'src/pages',w:4},{pattern:'src/app',w:3},{pattern:'app/',w:3}], dept_conventions.backend={language:'TypeScript/JavaScript',testing:'jest or vitest',tooling:'Node.js, npm/yarn/pnpm'}, dept_conventions.frontend={framework:'React/Vue/Svelte (per detection)',component_lib:'per detection',css:'Tailwind or CSS-in-JS'}, ux_focus={focus_areas:['UI design','component specs','design tokens','responsive breakpoints','interaction patterns'],testing_approach:'visual regression + usability checklists',artifact_types:['wireframes','design-tokens.jsonl','component-specs.jsonl'],vocabulary:{interface:'web UI',user:'end user',layout:'responsive grid'}}. (2) api-service: detect=[{pattern:'package.json:express',w:7},{pattern:'package.json:fastify',w:7},{pattern:'requirements.txt:fastapi',w:7},{pattern:'requirements.txt:flask',w:7},{pattern:'requirements.txt:django',w:7},{pattern:'manage.py',w:6},{pattern:'routes/',w:4},{pattern:'controllers/',w:4},{pattern:'Gemfile:rails',w:7},{pattern:'go.mod:gin',w:7},{pattern:'go.mod:echo',w:7}], dept_conventions.backend={language:'per detection (Node/Python/Ruby/Go)',testing:'per language framework',tooling:'REST/GraphQL, OpenAPI'}, ux_focus={focus_areas:['API documentation','OpenAPI specs','developer experience','error response design','rate limiting UX'],testing_approach:'API contract testing + DX review',artifact_types:['openapi-spec.yaml','error-catalog.jsonl'],vocabulary:{interface:'API surface',user:'API consumer',layout:'endpoint structure'}}. (3) cli-tool: detect=[{pattern:'bin/',w:5},{pattern:'scripts/',w:3},{pattern:'Cargo.toml:clap',w:8},{pattern:'package.json:commander',w:7},{pattern:'package.json:yargs',w:7},{pattern:'go.mod:cobra',w:8},{pattern:'setup.py',w:2},{pattern:'pyproject.toml:click',w:7}], dept_conventions.backend={language:'Bash/Rust/Go/Node (per detection)',testing:'BATS (shell), cargo test (Rust), go test',tooling:'jq, shell scripting'}, ux_focus={focus_areas:['help text quality','error output formatting','progress indicators','user prompts','man page conventions'],testing_approach:'CLI output validation + error message review',artifact_types:['help-text-spec.md','error-messages.jsonl'],vocabulary:{interface:'CLI',user:'CLI user',layout:'command structure'}}. (4) library: detect=[{pattern:'src/lib.rs',w:8},{pattern:'src/index.ts',w:4},{pattern:'src/index.js',w:4},{pattern:'tsconfig.json',w:2},{pattern:'Cargo.toml',w:3},{pattern:'setup.py',w:4},{pattern:'pyproject.toml',w:3}], dept_conventions.backend={language:'per detection',testing:'unit tests (per language)',tooling:'documentation generation'}, ux_focus={focus_areas:['API surface design','code examples','README quality','type documentation','changelog maintenance'],testing_approach:'API ergonomics review + documentation completeness',artifact_types:['api-reference.md','usage-examples.md'],vocabulary:{interface:'public API',user:'library consumer',layout:'module structure'}}. (5) mobile-app: detect=[{pattern:'ios/',w:8},{pattern:'android/',w:8},{pattern:'package.json:react-native',w:9},{pattern:'package.json:expo',w:9},{pattern:'flutter.yaml',w:9},{pattern:'pubspec.yaml',w:8},{pattern:'*.xcodeproj',w:7}], dept_conventions.backend={language:'Swift/Kotlin/Dart/TypeScript',testing:'XCTest/Espresso/widget tests',tooling:'platform SDKs'}, ux_focus={focus_areas:['UI design','gesture interactions','platform conventions','adaptive layouts','accessibility'],testing_approach:'device testing + gesture usability + a11y audit',artifact_types:['screen-specs.jsonl','gesture-map.jsonl','platform-guidelines.md'],vocabulary:{interface:'mobile UI',user:'app user',layout:'screen layout'}}. (6) monorepo: detect=[{pattern:'package.json:workspaces',w:9},{pattern:'lerna.json',w:9},{pattern:'pnpm-workspace.yaml',w:9},{pattern:'Cargo.toml:workspace',w:8},{pattern:'go.work',w:9},{pattern:'nx.json',w:9},{pattern:'turbo.json',w:8}], dept_conventions.backend={language:'per dominant sub-type',testing:'per dominant sub-type',tooling:'workspace tooling (turborepo/nx/lerna)'}, ux_focus={focus_areas:['per-package type detection','shared design system','cross-package consistency','workspace navigation'],testing_approach:'per-package + integration',artifact_types:['workspace-map.jsonl'],vocabulary:{interface:'per dominant sub-type',user:'per dominant sub-type',layout:'workspace structure'}}. (7) generic: detect=[] (empty, always matches as fallback with score 0), dept_conventions.backend={language:'per project',testing:'per project',tooling:'per project'}, ux_focus={focus_areas:['documentation quality','error handling','user feedback'],testing_approach:'general usability review',artifact_types:[],vocabulary:{interface:'interface',user:'user',layout:'structure'}}. Edge cases: signal weights are tuned so framework-specific signals (w:7-9) always outweigh structural signals (w:2-5). The generic type has no detect signals and score 0, acting as guaranteed fallback per D2. File must be valid JSON parseable by jq -e '.types | length' returning 7.","ts":"tests/unit/detect-stack-classify.bats will cover this (in task 01-01-03). For this config-only task, validation is: (1) jq -e . config/project-types.json succeeds (valid JSON). (2) jq '.types | length' returns 7. (3) Each type has id, name, priority, detect, department_conventions, ux_focus fields. (4) generic type has empty detect array. (5) Priority values are unique integers 1-7. The Dev should verify with: jq -e '.types[] | select(.id and .name and .priority and .detect and .department_conventions and .ux_focus)' config/project-types.json | wc -l == 7."}
{"id":"01-01-02","n":"Add project type classification to detect-stack.sh","f":["scripts/detect-stack.sh"],"d":["01-01-01"],"ac":["detect-stack.sh reads config/project-types.json alongside stack-mappings.json","Output JSON includes new project_type field with best-match type ID","Classification uses: file existence checks, detected_stack overlap with type signals, priority ordering (monorepo > specific > generic)","Fallback to generic when no type matches","Existing detected_stack, installed, recommended_skills, suggestions fields unchanged (backward compatible)"],"spec":"Modify scripts/detect-stack.sh to add project type classification. Changes are ADDITIVE to existing code -- all current functionality must remain. (1) After line 19 (MAPPINGS=...), add: PROJECT_TYPES=\"$SCRIPT_DIR/../config/project-types.json\". Add existence check: if [ ! -f \"$PROJECT_TYPES\" ]; then ... (but DO NOT exit -- fallback to generic if missing, so just set PROJECT_TYPES_AVAILABLE=false). (2) After the existing ENTRIES loop (after line 159), add a new section '# --- Project Type Classification ---'. Read project-types.json using jq to extract types as flat lines: id|priority|detect_patterns_semicolon_separated|weight_semicolon_separated. For each type, iterate its detect patterns calling the existing check_pattern() function (reuse!). Sum matched signal weights to compute score. Track: TYPE_SCORES associative array (type_id -> score). (3) After scoring all types, find the winner: iterate TYPE_SCORES, pick highest score. On ties, use priority field (higher priority wins). If no type scored > 0, winner is 'generic'. Store result in PROJECT_TYPE variable. (4) For monorepo type: if PROJECT_TYPE=monorepo, additionally detect sub-workspace types by checking for package.json files in subdirectories or Cargo workspace members. Find dominant sub-type (most common). Store in DOMINANT_SUBTYPE variable (default: 'web-app'). (5) Modify the final jq output block (line 182-200) to add two new fields: project_type (string, the winning type ID) and type_confidence (string, 'high' if winner score >= 2x runner-up, 'medium' if > runner-up, 'low' if tied or only generic). Keep ALL existing output fields unchanged. New output shape: {detected_stack:[...], installed:{...}, recommended_skills:[...], suggestions:[...], find_skills_available:bool, project_type:string, type_confidence:string}. (6) If PROJECT_TYPES file is missing, output project_type:'generic' and type_confidence:'low'. Implementation details: Use bash associative arrays (declare -A TYPE_SCORES). The check_pattern function already handles both file existence and dependency patterns -- reuse it directly. For monorepo sub-type detection: ls directories, check for package.json/Cargo.toml/go.mod in each, classify each sub-workspace, count by type. Edge cases: empty project -> generic. Multiple frameworks detected -> highest weighted match wins. Monorepo with no sub-workspaces -> use generic as dominant sub-type.","ts":"Tests in task 01-01-03 cover this. Key verification: run detect-stack.sh on (a) web-app fixture (package.json with react) -> project_type=web-app. (b) empty dir -> project_type=generic. (c) cli fixture (bin/ dir, no package.json) -> project_type=cli-tool. (d) existing fields (detected_stack, installed, etc.) still present in output."}
{"id":"01-01-03","n":"Add project type classification tests","f":["tests/unit/detect-stack-classify.bats"],"d":["01-01-02"],"ac":["BATS test file validates project type detection for at least 4 project types","Tests use fixture directories with signature files (e.g. package.json+react for web-app, Cargo.toml+src/main.rs for cli-tool)","Verifies backward compatibility: existing output fields still present","Verifies fallback: empty directory returns generic type","Tests pass with assert_success and jq-based output validation"],"spec":"Create tests/unit/detect-stack-classify.bats. Follow exact pattern from tests/unit/detect-stack.bats. Header: #!/usr/bin/env bats comment block. setup() function loads '../test_helper/common', '../test_helper/fixtures', '../test_helper/mock_stdin', calls mk_test_workdir, sets SUT=\"$SCRIPTS_DIR/detect-stack.sh\", exports CLAUDE_CONFIG_DIR=\"$TEST_WORKDIR/mock-claude\", creates mkdir -p \"$CLAUDE_CONFIG_DIR/skills\". Helper run_detect() same as detect-stack.bats: run bash -c \"cd '$TEST_WORKDIR' && CLAUDE_CONFIG_DIR='$CLAUDE_CONFIG_DIR' bash '$SUT' '$TEST_WORKDIR'\". Tests (9 minimum): (1) '@test \"classifies empty project as generic\"' -- empty TEST_WORKDIR, run_detect, assert_success, echo \"$output\" | jq -e '.project_type == \"generic\"'. (2) '@test \"classifies web-app from react dependency\"' -- create package.json with {\"dependencies\":{\"react\":\"^18\"}}, run_detect, assert_success, echo \"$output\" | jq -e '.project_type == \"web-app\"'. (3) '@test \"classifies api-service from express dependency\"' -- package.json with express, run_detect, jq -e '.project_type == \"api-service\"'. (4) '@test \"classifies cli-tool from bin directory\"' -- mkdir -p \"$TEST_WORKDIR/bin\", add a shell script in scripts/, run_detect, jq -e '.project_type == \"cli-tool\"'. (5) '@test \"classifies library from src/lib.rs\"' -- create Cargo.toml and src/lib.rs, run_detect, jq -e '.project_type == \"library\"'. (6) '@test \"classifies monorepo from workspaces in package.json\"' -- package.json with {\"workspaces\":[\"packages/*\"]}, run_detect, jq -e '.project_type == \"monorepo\"'. (7) '@test \"backward compat: output still has detected_stack field\"' -- create package.json with react, run_detect, echo \"$output\" | jq -e '.detected_stack'. (8) '@test \"backward compat: output still has installed field\"' -- run_detect, echo \"$output\" | jq -e '.installed'. (9) '@test \"type_confidence present in output\"' -- run_detect, echo \"$output\" | jq -e '.type_confidence'. (10) '@test \"higher weight signal wins over lower\"' -- create both src/lib.rs (library w:8) and routes/ (api-service w:4) alongside Cargo.toml, verify project_type is library not api-service (since library signals score higher total). (11) '@test \"monorepo beats web-app when both match\"' -- package.json with both react and workspaces, verify monorepo wins (higher priority). Edge case tests rely on the signal weight tuning in project-types.json.","ts":"This IS the test task. The test file itself is the deliverable. Verify by running: bats tests/unit/detect-stack-classify.bats -- all tests should pass. Minimum 9 tests, all using assert_success + jq -e output validation pattern from existing detect-stack.bats."}
