{"p":"02-02","n":"Hook and State Adaptations","t":3,"w":1,"d":[],"mh":{"tr":["agent-start.sh writes .dept-status-{dept}.json via dept-status.sh when a department Lead starts","agent-start.sh detects department from agent_type prefix (fe-=frontend, ux-=uiux, no prefix=backend)","state-updater.sh writes .phase-orchestration.json alongside .execution-state.json when multi_dept=true","Single-dept mode (no dept prefix) has zero behavioral change in both hooks"],"ar":[{"p":"scripts/agent-start.sh","pv":"echo '{\"agent_type\":\"yolo-fe-lead\"}' | bash scripts/agent-start.sh creates .dept-status-frontend.json in planning dir","c":"Department Lead detection triggers status file creation via dept-status.sh"},{"p":"scripts/state-updater.sh","pv":"When .phase-orchestration.json exists, state-updater updates department step progress in it","c":"Multi-dept state tracking alongside existing .execution-state.json updates"}],"kl":[{"fr":"scripts/agent-start.sh","to":"scripts/dept-status.sh","vi":"agent-start calls dept-status.sh --action write when dept Lead detected"},{"fr":"scripts/state-updater.sh","to":".phase-orchestration.json","vi":"state-updater writes per-department progress to orchestration file when multi_dept=true"}]},"obj":"Adapt 2 existing hooks (agent-start.sh, state-updater.sh) to support multi-department tracking while preserving backward compatibility for single-department mode.","sk":["commit"],"fm":["scripts/agent-start.sh","scripts/state-updater.sh","tests/unit/agent-start.bats","tests/unit/state-updater.bats"]}
{"id":"02-02-01","n":"Update agent-start.sh for department status tracking","f":["scripts/agent-start.sh"],"d":[],"ac":["agent-start.sh detects department from agent_type prefix: yolo-fe-* -> frontend, yolo-ux-* -> uiux, yolo-{lead|architect|senior|dev|tester|qa|qa-code} -> backend","When agent_type is a department Lead (yolo-lead, yolo-fe-lead, yolo-ux-lead): calls dept-status.sh to write initial status","dept-status.sh called with: --dept {detected_dept} --phase-dir {active_phase_dir} --action write --status running --step planning","Phase dir resolved from .execution-state.json or latest phase directory","Non-Lead agents (yolo-dev, yolo-senior etc) do NOT trigger dept-status writes","Existing .active-agent write behavior unchanged","Graceful degradation: if dept-status.sh not found or fails, exit 0 (fail-open)","Still exit 0 always (SubagentStart hook is observe-only)"],"spec":"FILE: scripts/agent-start.sh (modify existing, 22 lines currently). PRESERVE all existing code (lines 1-21). ADD new department detection and dept-status call AFTER the existing case block (after line 19, before exit 0). EXACT CHANGES: (1) After the existing 'case \"$AGENT_TYPE\" in yolo-*) ... esac' block and before 'exit 0', add a new section with a comment '# --- Department Lead detection: write initial dept status ---'. (2) Detect department using SAME case pattern as department-guard.sh lines 50-57: case \"$AGENT_TYPE\" in yolo-fe-*) DEPT=\"frontend\" ;; yolo-ux-*) DEPT=\"uiux\" ;; yolo-*) DEPT=\"backend\" ;; *) DEPT=\"\" ;; esac. (3) Only proceed if DEPT is non-empty AND agent_type is a Lead. Detect Leads with: case \"$AGENT_TYPE\" in yolo-lead|yolo-fe-lead|yolo-ux-lead) IS_LEAD=true ;; *) IS_LEAD=false ;; esac. (4) Guard: [ \"$IS_LEAD\" != \"true\" ] && exit 0. (5) Resolve PHASE_DIR: first try reading from .execution-state.json — PHASE_NUM=$(jq -r '.phase // empty' \"$PLANNING_DIR/.execution-state.json\" 2>/dev/null); PHASE_NAME=$(jq -r '.phase_name // empty' \"$PLANNING_DIR/.execution-state.json\" 2>/dev/null); if both non-empty, construct PHASE_DIR=\"$PLANNING_DIR/phases/$(printf '%02d' \"$PHASE_NUM\")-${PHASE_NAME}\". If that dir does not exist, fallback: PHASE_DIR=$(ls -d \"$PLANNING_DIR/phases/\"*/ 2>/dev/null | sort | tail -1). Strip trailing slash. (6) Guard: [ -z \"$PHASE_DIR\" ] || [ ! -d \"$PHASE_DIR\" ] && exit 0. (7) Locate dept-status.sh: DEPT_STATUS_SCRIPT in same directory as agent-start.sh — SCRIPT_DIR=$(cd \"$(dirname \"$0\")\" && pwd); DEPT_STATUS=\"$SCRIPT_DIR/dept-status.sh\". (8) Guard: [ ! -f \"$DEPT_STATUS\" ] && exit 0. (9) Call: bash \"$DEPT_STATUS\" --dept \"$DEPT\" --phase-dir \"$PHASE_DIR\" --action write --status running --step planning 2>/dev/null || true. The '|| true' ensures fail-open behavior. (10) Keep 'exit 0' as final line. IMPORTS: No new imports. Uses jq (already used on line 12), ls, sort, tail. ERROR HANDLING: Every new operation is guarded with early exit 0 or || true. The hook MUST always exit 0 (SubagentStart is observe-only). BACKWARD COMPAT: When agent_type has no department prefix (non-yolo agent), DEPT is empty and exits immediately. When agent is not a Lead, exits after IS_LEAD check. Single-dept backend-only projects with yolo-lead will correctly get DEPT=backend and write .dept-status-backend.json, which is fine (dept-status.sh handles it). EDGE CASES: (a) .execution-state.json missing or malformed — jq returns empty, fallback to ls scan. (b) No phase directories exist — PHASE_DIR empty, exit 0. (c) dept-status.sh missing (plan 02-01 not yet implemented) — file check fails, exit 0. (d) dept-status.sh fails with non-zero — || true catches it, exit 0. (e) PLANNING_DIR missing — already handled by existing line 7.","ts":"FILE: tests/unit/agent-start.bats (extend existing file, currently 65 lines). ADD new tests AFTER line 65 (after existing tests). Use same setup() which loads common, fixtures, mock_stdin helpers and sets SUT. FRAMEWORK: BATS with bats-support, bats-assert, bats-file. REQUIRED NEW TESTS (minimum 5): (T1) '@test \"fe-lead triggers frontend dept-status write\"' — Setup: mk_planning_dir, create a mock dept-status.sh in $SCRIPTS_DIR that writes its received args to a capture file (e.g. $TEST_WORKDIR/.dept-status-call). Create .execution-state.json with phase=1 phase_name=test. Create phase dir $TEST_WORKDIR/.yolo-planning/phases/01-test/. Run: echo '{\"agent_type\":\"yolo-fe-lead\"}' | bash '$SUT'. Assert: .dept-status-call file exists and contains '--dept frontend' and '--status running' and '--step planning'. (T2) '@test \"ux-lead triggers uiux dept-status write\"' — Same pattern as T1 but with agent_type=yolo-ux-lead. Assert --dept uiux in captured args. (T3) '@test \"lead triggers backend dept-status write\"' — Same pattern with agent_type=yolo-lead. Assert --dept backend. (T4) '@test \"non-lead agents skip dept-status write\"' — Setup with mock dept-status.sh. Run with agent_type=yolo-dev. Assert: .dept-status-call file does NOT exist (dept-status.sh was never called). Also test with yolo-fe-senior, yolo-ux-qa. (T5) '@test \"missing dept-status.sh degrades gracefully\"' — Setup: do NOT create mock dept-status.sh (or rename it). Create .execution-state.json and phase dir. Run with agent_type=yolo-fe-lead. Assert: exit 0 (success), no .dept-status file created. MOCK STRATEGY: Create a mock dept-status.sh that captures its arguments: #!/bin/bash; echo \"$@\" > \"$PLANNING_DIR/.dept-status-call\" where PLANNING_DIR is passed via env or derived from --phase-dir arg. The simplest approach: the mock script writes \"$@\" to a fixed path relative to its own location: echo \"$@\" > \"$(dirname \"$0\")/../.yolo-planning/.dept-status-call\". Actually simpler: since agent-start.sh resolves DEPT_STATUS via SCRIPT_DIR=$(cd $(dirname $0) && pwd), the mock needs to be at $SCRIPTS_DIR/dept-status.sh. Create it in setup or per-test. CLEANUP: bats auto-cleans BATS_TEST_TMPDIR. For the mock, write it to $TEST_WORKDIR/scripts/ and ensure SUT resolves relative to that. NOTE: The SUT ($SCRIPTS_DIR/agent-start.sh) uses SCRIPT_DIR=$(cd $(dirname $0) && pwd) to find dept-status.sh. In tests, $0 resolves to the real scripts/ dir. To mock dept-status.sh, either: (a) copy agent-start.sh to $TEST_WORKDIR/scripts/ and place mock dept-status.sh alongside it, then set SUT to the copy, OR (b) create a wrapper that sets PATH to include a mock dir first. Option (a) is cleanest — add a per-test helper: mk_agent_start_with_mock() that copies agent-start.sh to $TEST_WORKDIR/scripts/ and creates mock dept-status.sh there, then sets SUT to the copy."}
{"id":"02-02-02","n":"Update state-updater.sh for multi-dept orchestration state","f":["scripts/state-updater.sh"],"d":[],"ac":["state-updater.sh checks for .phase-orchestration.json existence in phase dir","When .phase-orchestration.json exists: updates department status and step on summary/plan writes","On summary write: updates departments.{dept}.status and departments.{dept}.step in .phase-orchestration.json","Department detected from plan file prefix (fe-* -> frontend, ux-* -> uiux, standard -> backend)","Gate status updates: when all departments show complete, updates gates.all-depts.status to passed","When .phase-orchestration.json does NOT exist: zero change to existing behavior","Uses jq for all JSON manipulation","Existing .execution-state.json, STATE.MD, ROADMAP.md, state.json updates unchanged","Backward compatible: single-dept projects never have .phase-orchestration.json so hit no new code paths"],"spec":"FILE: scripts/state-updater.sh (modify existing, 343 lines currently). ADD a new function update_phase_orchestration() and call it alongside existing update functions. EXACT CHANGES: (1) Add new function 'update_phase_orchestration()' AFTER the advance_phase() function (after line 214) and BEFORE commit_state_artifacts() (before line 216). Function signature: update_phase_orchestration() { local phase_dir=\"$1\" file_path=\"$2\" }. (2) Function body: ORCH_FILE=\"$phase_dir/.phase-orchestration.json\". Guard: [ -f \"$ORCH_FILE\" ] || return 0. Guard: command -v jq >/dev/null 2>&1 || return 0. (3) Detect department from .active-agent file: ACTIVE_AGENT=\"\"; [ -f \".yolo-planning/.active-agent\" ] && ACTIVE_AGENT=$(<\".yolo-planning/.active-agent\"). Dept detection: case \"$ACTIVE_AGENT\" in yolo-fe-*) ORCH_DEPT=\"frontend\" ;; yolo-ux-*) ORCH_DEPT=\"uiux\" ;; yolo-*) ORCH_DEPT=\"backend\" ;; *) return 0 ;; esac. (4) Determine the step name from the file_path. If file_path matches plan.jsonl pattern: ORCH_STEP=\"planning\". If file_path matches summary.jsonl pattern: ORCH_STEP=\"complete\". Else return 0. Use: case \"$file_path\" in *plan.jsonl) ORCH_STEP=\"planning\" ;; *summary.jsonl) ORCH_STEP=\"implementation\" ;; *) return 0 ;; esac. (5) Update the orchestration file atomically: local tmp=\"${ORCH_FILE}.tmp.$$\". Use jq: jq --arg dept \"$ORCH_DEPT\" --arg step \"$ORCH_STEP\" --arg now \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" '.departments[$dept].step = $step | .departments[$dept].updated_at = $now' \"$ORCH_FILE\" > \"$tmp\" 2>/dev/null && mv \"$tmp\" \"$ORCH_FILE\" 2>/dev/null || rm -f \"$tmp\" 2>/dev/null. (6) For summary writes, also check if department is now complete. Count plans and summaries for this department. Since dept plan files follow the naming convention (fe-* prefix for frontend, ux-* prefix for uiux, no prefix for backend), count accordingly. However, the simpler approach per architecture: on summary write, update status to 'running' with the current step. The actual 'complete' status is written by the department Lead via dept-status.sh when its 10-step workflow finishes. So state-updater only tracks step progress, not completion. Simplify: just update step and updated_at. (7) Gate check: After updating the department, check if ALL departments in .phase-orchestration.json have status=complete. local all_complete=$(jq '[.departments[]] | all(.status == \"complete\")' \"$ORCH_FILE\" 2>/dev/null). if [ \"$all_complete\" = \"true\" ]; then local tmp=\"${ORCH_FILE}.tmp.$$\"; jq --arg now \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\" '.gates[\"all-depts\"].status = \"passed\" | .gates[\"all-depts\"].passed_at = $now' \"$ORCH_FILE\" > \"$tmp\" 2>/dev/null && mv \"$tmp\" \"$ORCH_FILE\" 2>/dev/null || rm -f \"$tmp\" 2>/dev/null; fi. (8) CALL SITE: Add call to update_phase_orchestration in TWO places. First: in the plan trigger block (around line 266, after update_state_json), add: update_phase_orchestration \"$PHASE_DIR\" \"$FILE_PATH\". Second: in the summary trigger block (around line 337, after advance_phase), add: update_phase_orchestration \"$PHASE_DIR\" \"$FILE_PATH\". (9) Also add .phase-orchestration.json to commit_state_artifacts: In the commit_state_artifacts function (line 222), add the orchestration file to the loop. Change the for loop to include: for f in .yolo-planning/STATE.md .yolo-planning/state.json .yolo-planning/ROADMAP.md .yolo-planning/.execution-state.json \"$PHASE_DIR/.phase-orchestration.json\"; do. BUT commit_state_artifacts takes only a msg param, not phase_dir. Two options: (a) make phase_dir a global (it already is — PHASE_DIR is set at line 247), or (b) pass it as a second param. Since PHASE_DIR is already a script-level variable set before any function calls, the simplest approach is to add a glob pattern: also check for any .phase-orchestration.json. Change the for loop to: for f in .yolo-planning/STATE.md .yolo-planning/state.json .yolo-planning/ROADMAP.md .yolo-planning/.execution-state.json; do ... done. Then after the loop, also check: if [ -n \"${PHASE_DIR:-}\" ] && [ -f \"$PHASE_DIR/.phase-orchestration.json\" ]; then — add to git if changed. This avoids passing PHASE_DIR as parameter. IMPORTS: No new imports. Uses jq (already used), date (standard). ERROR HANDLING: Every jq operation uses 2>/dev/null with tmp file pattern (consistent with existing code). Function returns 0 on any failure. BACKWARD COMPAT: When .phase-orchestration.json does not exist (all single-dept projects), the function returns immediately at the first guard. Zero new code paths hit. When .active-agent is missing or not a yolo-* agent, returns at case fallback. EDGE CASES: (a) .phase-orchestration.json exists but is malformed JSON — jq fails silently, tmp not created, mv skipped, rm cleans up. (b) .active-agent missing — ACTIVE_AGENT is empty string, case hits '*' pattern, returns. (c) Department key not in .phase-orchestration.json departments object — jq creates it (jq auto-vivifies paths with = operator). This is acceptable since if the file exists, all active departments should be in it. (d) Race condition with dept-status.sh writing simultaneously — both use tmp files with PID suffix, no collision. The .phase-orchestration.json is NOT flock-protected here since state-updater is called per-agent and each agent writes sequentially.","ts":"FILE: tests/unit/state-updater.bats (extend existing file, currently 246 lines). ADD new tests AFTER line 246. Use same setup() and run_updater() helper. FRAMEWORK: BATS with bats-support, bats-assert, bats-file. REQUIRED NEW TESTS (minimum 4): (T1) '@test \"summary write updates .phase-orchestration.json department step\"' — Setup: mk_state_md, mk_state_json, mk_execution_state. Create phase dir with 1 plan. Create .phase-orchestration.json in phase dir with: {\"departments\":{\"backend\":{\"status\":\"running\",\"step\":\"planning\"}},\"gates\":{\"all-depts\":{\"status\":\"pending\"}}}. Create .active-agent with 'yolo-lead'. Create summary file. Run run_updater with summary path. Assert: jq '.departments.backend.step' of .phase-orchestration.json equals 'implementation' (since summary write sets step to implementation). Assert: .departments.backend.updated_at is non-empty. (T2) '@test \"all depts complete triggers gate update in .phase-orchestration.json\"' — Setup: Create .phase-orchestration.json with departments.backend.status=complete AND departments.frontend.status=complete. Create .active-agent with yolo-lead. Create phase dir, plan, summary. Run run_updater. Assert: jq '.gates[\"all-depts\"].status' equals 'passed'. (T3) '@test \"missing .phase-orchestration.json has no effect\"' — Setup: mk_state_md, mk_state_json, mk_execution_state. Create phase dir with plan and summary. Do NOT create .phase-orchestration.json. Create .active-agent. Run run_updater with summary. Assert success. Assert .phase-orchestration.json does NOT exist (was not created). (T4) '@test \"existing .execution-state.json update still works with orchestration\"' — Setup: Create both .execution-state.json and .phase-orchestration.json. Create .active-agent with yolo-lead. Create phase dir, plan, summary. Run run_updater. Assert: .execution-state.json was updated (plan status = complete). Assert: .phase-orchestration.json was also updated (department step changed). Both systems work side by side. FIXTURE HELPER: Add a helper function mk_phase_orchestration() to create .phase-orchestration.json: mk_phase_orchestration() { local phase_dir=\"$1\"; local depts=\"$2\"; echo \"$depts\" > \"$phase_dir/.phase-orchestration.json\"; }. For T1, pass '{\"departments\":{\"backend\":{\"status\":\"running\",\"step\":\"planning\"}},\"gates\":{\"all-depts\":{\"status\":\"pending\"}}}'. For T2, pass '{\"departments\":{\"backend\":{\"status\":\"complete\",\"step\":\"signoff\"},\"frontend\":{\"status\":\"complete\",\"step\":\"signoff\"}},\"gates\":{\"all-depts\":{\"status\":\"pending\"}}}'."}
{"id":"02-02-03","n":"Write hook adaptation tests","f":["tests/unit/agent-start.bats","tests/unit/state-updater.bats"],"d":["02-02-01","02-02-02"],"ac":["tests/unit/agent-start.bats extended with minimum 5 new tests for dept tracking: fe-lead triggers frontend dept-status, ux-lead triggers uiux dept-status, lead triggers backend dept-status, non-lead agents skip dept-status, missing dept-status.sh degrades gracefully","tests/unit/state-updater.bats extended with minimum 4 new tests for multi-dept: summary write updates .phase-orchestration.json department step, all depts complete triggers gate update, missing .phase-orchestration.json has no effect, existing .execution-state.json update still works","New tests coexist with existing tests (extend the file, do not replace)","All tests pass with bats including pre-existing tests"],"spec":"This task verifies and finalizes the tests written as part of 02-02-01 and 02-02-02. The ts fields on those tasks define the exact tests to write during implementation. This task's Dev responsibility: (1) Run the full existing test suites: cd /Users/slavpetroff/Projects/yolo && bats tests/unit/agent-start.bats && bats tests/unit/state-updater.bats. (2) Verify ALL pre-existing tests still pass (no regressions). (3) Verify all new tests from 02-02-01 ts (5 tests) and 02-02-02 ts (4 tests) are present and pass. (4) If any test fails, fix the test or the implementation (within the scope of 02-02-01/02-02-02 specs). (5) Run combined: bats tests/unit/agent-start.bats tests/unit/state-updater.bats — all must pass. SPECIFIC CHECKS: For agent-start.bats: should have 6 original tests + 5 new = 11+ total. For state-updater.bats: should have 12 original tests + 4 new = 16+ total. EDGE CASE TESTING: If the mock dept-status.sh approach in 02-02-01 ts causes issues (SUT resolving SCRIPT_DIR to real scripts/ instead of test copy), the fix is: in each dept-tracking test, copy agent-start.sh to $TEST_WORKDIR/scripts/ and create mock dept-status.sh alongside it. Set local SUT=\"$TEST_WORKDIR/scripts/agent-start.sh\". This ensures SCRIPT_DIR resolves to the test directory. PASS CRITERIA: zero failures across both test files, zero skipped tests.","ts":""}

