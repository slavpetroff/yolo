phase: 02
goal: Replace Task-only spawning with Teammate API for multi-dept mode — one team per department with parallel execution

architecture:
  phase: 02
  title: Agent Teams Integration Architecture
  decision: Option B — File-Based Coordination with Background Subagents (No Teammate API)
  
  rationale: The Teammate API (spawnTeam, SendMessage) is experimental with critical
    known bugs: message delivery failures (GitHub #23415, #24108), delegate mode
    strips file tools (#25037), idle agents never poll inbox, no nested teams,
    one team per session. The user directive: "if thats unreliable then we should
    simply go with files communication and think locks on them." Background Task
    subagents are stable, support up to 10 concurrent executions, and run within
    the proven single-session architecture. File-based coordination with lockfiles
    is deterministic, debuggable, survives crashes, and requires zero experimental
    API dependencies.
  
  alternatives_rejected:
    - Teammate API (full): 3 critical API constraints (C-01, C-02, C-03), experimental
      status, message delivery unreliable, no nested teams, one team per session
    - Hybrid (Team + Task): Still depends on experimental spawnTeam for outer
      coordination layer. SendMessage for handoffs is unreliable. Adds complexity
      without reliability gain over pure Task approach.
  
  ## Coordination Model
  
  model: file-based-with-background-subagents
  description: Departments execute as background Task subagents (run_in_background=true).
    go.md spawns department Leads as parallel background subagents. Coordination
    uses sentinel files in the phase directory with flock-based locking for atomic
    state transitions. No Teammate API, no SendMessage, no spawnTeam.
  
  principles:
    - Deterministic: file existence = gate state. No async message delivery.
    - Debuggable: all coordination state is on disk in JSON files.
    - Crash-safe: sentinel files persist across session restarts.
    - Backward-compatible: when multi_dept=false, zero changes to existing flow.
  
  coordination_files:
    - .dept-status-{dept}.json: Per-department status tracking (pending/running/complete/failed)
    - .handoff-ux-complete: Sentinel file — UX department finished, triggers FE+BE wave
    - .handoff-api-contract: Sentinel file — API contract agreed between FE and BE
    - .dept-lock-{dept}: flock lockfile for atomic status updates
    - .phase-orchestration.json: Master orchestration state (all departments, gates, timing)
  
  ## Department Lifecycle
  
  lifecycle: per-phase
  description: Each active department runs a full 10-step workflow as a background
    Task subagent. go.md orchestrates the lifecycle by spawning subagents and
    polling status files.
  
  ### Spawn Sequence (parallel workflow)
  
  step_0: go.md reads resolve-departments.sh output (existing script, no changes)
  step_1: If ux_active, spawn UX Lead as background Task subagent
    - UX Lead runs its 10-step workflow using foreground Task subagents internally
    - On completion, UX Lead writes .dept-status-uiux.json with status=complete
    - UX Lead writes .handoff-ux-complete sentinel file
  step_2: go.md polls for .handoff-ux-complete (500ms interval, configurable timeout)
    - Timeout after 30min (configurable): STOP with error, cleanup
  step_3: Spawn FE Lead + BE Lead as parallel background Task subagents
    - Each Lead runs its 10-step workflow independently
    - Each Lead writes .dept-status-{dept}.json on completion
  step_4: go.md polls for all .dept-status-{dept}.json files to reach complete
  step_5: Integration QA (sequential, after all departments complete)
  step_6: Security audit (sequential, shared agent)
  step_7: Owner sign-off
  
  ### Spawn Sequence (sequential workflow)
  
  Same as above but UX -> FE -> BE each wait for predecessor .handoff-{dept}-complete
  
  ### Spawn Sequence (backend_only)
  
  No changes. Single Lead spawned as foreground Task subagent (existing behavior).
  
  ## go.md Execute Mode Changes
  
  scope: Minimal additions to execute mode routing
  description: The multi_dept=true branch in Execute mode gets a new orchestration
    pattern. Single-dept path is untouched.
  
  changes:
    - Read multi_dept and workflow from resolve-departments.sh (already done)
    - When multi_dept=true: invoke dept-orchestrate.sh to get spawn plan
    - Spawn department Leads as background Task subagents per spawn plan
    - Poll .dept-status-{dept}.json files for completion
    - On all complete: run Integration QA, Security, Owner Sign-off
  
  new_orchestration_flow:
    1. go.md calls dept-orchestrate.sh which outputs JSON spawn plan
    2. go.md spawns wave 1 (UX if active) as background Task subagent
    3. go.md enters poll loop: check .handoff-ux-complete every 500ms
    4. On UX complete: spawn wave 2 (FE + BE) as parallel background Task subagents
    5. go.md enters poll loop: check .dept-status-frontend.json + .dept-status-backend.json
    6. On all complete: proceed to Integration QA (foreground)
    7. Security audit (foreground)
    8. Owner sign-off (foreground)
  
  polling_mechanism: Bash loop with sleep and file existence check
    while [ ! -f "$PHASE_DIR/.handoff-ux-complete" ]; do sleep 0.5; done
    Timeout guard: track elapsed seconds, abort after configurable max
  
  ## Script Changes
  
  ### New Scripts
  
  dept-orchestrate.sh:
    purpose: Generate department spawn plan as JSON from resolve-departments.sh output
    input: config.json path, phase directory
    output: JSON with waves array, each wave lists departments to spawn in parallel
    example_output: |
      {"waves":[
        {"id":1,"depts":["uiux"],"gate":"handoff-ux-complete"},
        {"id":2,"depts":["frontend","backend"],"gate":"all-depts-complete"}
      ],"timeout_minutes":30}
    notes: Pure data script. No tool invocations. Reads config, outputs plan.
  
  dept-status.sh:
    purpose: Atomic read/write of department status files using flock
    input: --dept, --phase-dir, --action (read|write), --status, --step, --error
    output: Reads or writes .dept-status-{dept}.json atomically
    locking: Uses flock on .dept-lock-{dept} for atomic writes
    schema: |
      {"dept":"backend","status":"running","step":"implementation",
       "started_at":"ISO8601","updated_at":"ISO8601",
       "plans_complete":2,"plans_total":3,"error":""}
  
  dept-gate.sh:
    purpose: Check handoff gate conditions (sentinel files + artifact validation)
    input: --gate (ux-complete|api-contract|all-depts), --phase-dir, --timeout
    output: exit 0 when gate satisfied, exit 1 on timeout, exit 2 on failure
    validation: For ux-complete gate, validates design-handoff.jsonl, design-tokens.jsonl,
      component-specs.jsonl exist and are valid JSONL (same checks as cross-team-protocol.md Gate 1)
  
  dept-cleanup.sh:
    purpose: Remove coordination files after phase completion or on failure
    input: --phase-dir, --reason (complete|failure|timeout)
    output: Removes .dept-status-*.json, .handoff-*, .dept-lock-*, .phase-orchestration.json
    safety: Only removes YOLO coordination files, never user artifacts
  
  ### Modified Scripts
  
  agent-start.sh:
    change: Write department to .dept-status-{dept}.json via dept-status.sh when
      a department Lead subagent starts (detect via agent_type prefix)
    backward_compat: No change when agent_type has no department prefix
  
  state-updater.sh:
    change: When multi_dept=true, update .phase-orchestration.json alongside
      .execution-state.json to reflect per-department step progress
    backward_compat: Single-dept mode writes .execution-state.json only (no change)
  
  resolve-departments.sh:
    change: None. Existing output (multi_dept, workflow, leads_to_spawn, spawn_order)
      is sufficient. dept-orchestrate.sh consumes this output.
    rationale: Addresses C-13 — no team_spawn_plan field added to this script
  
  validate-send-message.sh:
    change: None. SendMessage is not used for coordination in this architecture.
      The hook remains for future Teammate API adoption or manual team use.
    rationale: Addresses C-14 — no dual-path resolution needed
  
  ## Protocol Updates
  
  ### execute-protocol.md
  
  section: Multi-Department Execution
  change: Replace "Read multi-dept-protocol.md" paragraph with inline orchestration
    instructions for file-based coordination. Keep protocol reference for dept
    workflow order but add concrete polling + gate mechanics.
  additions:
    - Department spawn as background Task subagents
    - Polling loop for handoff gates
    - Timeout handling and fallback to sequential
    - Cleanup on completion or failure
    - Per-department .execution-state.json extension
  
  ### multi-dept-protocol.md
  
  section: Phase Execution
  change: Replace vague "run in PARALLEL" with concrete background Task subagent
    mechanism. Add polling, gate files, status files, cleanup.
  additions:
    - Coordination files section (what files, where, schema)
    - Polling mechanism section (interval, timeout, error handling)
    - Cleanup section (when and what to remove)
  removal: Remove references to spawnTeam, SendMessage for coordination
  
  ### cross-team-protocol.md
  
  section: Handoff Gates
  change: Make gate validation concrete — reference dept-gate.sh for each gate.
    Gate 1 (UX -> FE+BE) checks .handoff-ux-complete + artifact validation.
    Gate 2 (FE <-> BE API contract) checks .handoff-api-contract.
    Gate 3 (Integration QA) checks all .dept-status-{dept}.json = complete.
  additions:
    - File-based gate definitions with exact paths
    - dept-gate.sh invocation examples
    - Timeout and failure handling per gate
  
  ### company-hierarchy.md
  
  section: Multi-Department Structure
  change: Add note that parallel execution uses background Task subagents,
    not Teammate API. Coordination via file-based gates.
  minimal: This is a documentation-only update, not behavioral.
  
  ## Handoff Gates
  
  gate_1:
    name: UX Complete
    trigger: UX department 10-step workflow reaches Sign-off
    mechanism: UX Lead writes .handoff-ux-complete sentinel file
    validation: dept-gate.sh --gate ux-complete checks:
      - .handoff-ux-complete file exists
      - design-handoff.jsonl exists with status=complete
      - design-tokens.jsonl exists
      - component-specs.jsonl exists with all status=ready
    consumer: go.md polling loop releases FE+BE wave
    timeout: 30 minutes (configurable via config.json)
    on_timeout: STOP with error, run dept-cleanup.sh --reason timeout
  
  gate_2:
    name: API Contract
    trigger: Frontend proposes API contract, Backend agrees
    mechanism: api-contracts.jsonl written with status=agreed
    validation: dept-gate.sh --gate api-contract checks:
      - api-contracts.jsonl exists with at least one entry with status=agreed
    consumer: Both FE and BE Leads check during their Step 6 (Implementation)
    notes: Non-blocking — FE and BE proceed in parallel and negotiate async.
      FE Lead writes proposed contract. BE Lead reads and updates status.
      Both operate on same file with flock locking via dept-status.sh.
  
  gate_3:
    name: All Departments Complete
    trigger: All active department .dept-status-{dept}.json show status=complete
    mechanism: go.md polls all status files
    validation: dept-gate.sh --gate all-depts checks:
      - Every active department has .dept-status-{dept}.json with status=complete
      - Every department has at least one summary.jsonl
    consumer: go.md proceeds to Integration QA
    timeout: 60 minutes (configurable)
    on_timeout: STOP with per-department status report
  
  gate_4:
    name: Owner Sign-off
    trigger: Integration QA + Security complete
    mechanism: Standard Step 10 from execute-protocol.md
    notes: No change from current protocol
  
  ## Execution State Extensions
  
  ### .phase-orchestration.json (NEW — multi-dept only)
  
  schema: |
    {
      "phase": "02",
      "multi_dept": true,
      "workflow": "parallel",
      "departments": {
        "uiux": {"status":"complete","step":"signoff","started":"ISO","completed":"ISO"},
        "frontend": {"status":"running","step":"implementation","started":"ISO"},
        "backend": {"status":"running","step":"code_review","started":"ISO"}
      },
      "gates": {
        "ux-complete": {"status":"passed","passed_at":"ISO"},
        "api-contract": {"status":"pending"},
        "all-depts": {"status":"pending"}
      },
      "integration_qa": {"status":"pending"},
      "security": {"status":"pending"},
      "owner_signoff": {"status":"pending"},
      "started_at": "ISO",
      "timeout_minutes": 30
    }
  
  ### .dept-status-{dept}.json (NEW — one per active department)
  
  schema: |
    {
      "dept": "backend",
      "status": "running|complete|failed",
      "step": "critique|architecture|planning|...|signoff",
      "started_at": "ISO8601",
      "updated_at": "ISO8601",
      "plans_complete": 2,
      "plans_total": 3,
      "error": ""
    }
  
  ### .execution-state.json (EXISTING — extended)
  
  extension: When multi_dept=true, add departments object mirroring
    .phase-orchestration.json department statuses. This keeps the existing
    single source of truth pattern while adding multi-dept tracking.
  
  ## Backward Compatibility
  
  guarantee: When agent_teams=false OR multi_dept=false OR department_workflow=backend_only,
    ZERO changes to existing behavior. All new code paths are gated behind
    multi_dept=true checks.
  
  gates:
    - dept-orchestrate.sh: Only called when multi_dept=true
    - dept-status.sh: Only called when multi_dept=true
    - dept-gate.sh: Only called when multi_dept=true
    - dept-cleanup.sh: Only called when multi_dept=true
    - go.md polling loop: Only entered when multi_dept=true
    - .phase-orchestration.json: Only created when multi_dept=true
    - agent-start.sh dept tracking: Only fires for dept-prefixed agents
  
  single_dept_path: go.md Execute mode reads multi_dept flag first. If false,
    follows existing execute-protocol.md 10-step with foreground Task subagent.
    No file polling, no sentinel files, no department status tracking.
  
  ## Config Changes
  
  ### defaults.json
  
  no_new_keys: The existing agent_teams, departments, department_workflow,
    cross_team_handoff keys are sufficient. agent_teams=true enables the
    file-based parallel orchestration when multi_dept=true.
  
  optional_future_keys:
    - dept_timeout_minutes: Override default 30min per-gate timeout
    - dept_poll_interval_ms: Override default 500ms polling interval
  
  ### No team-profiles.json
  
  rationale: Addresses C-06. Agent roster data already lives in
    company-hierarchy.md and agent files. resolve-departments.sh already
    knows active departments. resolve-agent-model.sh already resolves
    models per role. No new config file needed.
  
  ## Files Modified/Created
  
  ### Created (4 new scripts)
  
  scripts/dept-orchestrate.sh: Department spawn plan generator
  scripts/dept-status.sh: Atomic department status read/write with flock
  scripts/dept-gate.sh: Handoff gate validation
  scripts/dept-cleanup.sh: Coordination file cleanup
  
  ### Modified (4 existing files)
  
  scripts/agent-start.sh: Add department status tracking on Lead start
  scripts/state-updater.sh: Add .phase-orchestration.json updates for multi-dept
  references/execute-protocol.md: Add file-based multi-dept orchestration details
  references/multi-dept-protocol.md: Replace placeholder parallelism with concrete mechanism
  
  ### Updated (2 existing files — documentation only)
  
  references/cross-team-protocol.md: Concrete gate file references
  references/company-hierarchy.md: Note on background Task subagent approach
  
  ### Not Modified (preserved as-is)
  
  scripts/resolve-departments.sh: Already outputs everything needed (C-13)
  scripts/validate-send-message.sh: Remains for manual team use, not coordination (C-14)
  config/defaults.json: Existing keys sufficient
  commands/go.md: Orchestration logic embedded via execute-protocol.md reference
  
  ### Not Created (eliminated by architecture)
  
  config/team-profiles.json: Not needed (C-06)
  scripts/spawn-team.sh: Not needed — no Teammate API (C-04)
  scripts/shutdown-team.sh: Not needed — no Teammate API (C-05)
  
  ## Risks and Mitigations
  
  risks[5]{risk,impact,mitigation}:
  
  risk_1:
    risk: Background Task subagent polling adds latency vs event-driven
    impact: Low — 500ms poll interval is imperceptible. Total overhead for a
      30-minute department workflow is ~60 poll cycles = negligible.
    mitigation: Configurable poll interval. Can reduce to 100ms if needed.
  
  risk_2:
    risk: File locking (flock) may behave differently across platforms
    impact: Medium — flock is POSIX but macOS/Linux implementations differ.
    mitigation: dept-status.sh uses flock with fallback to mkdir-based locking
      (mkdir is atomic on all POSIX systems). Test on macOS and Linux.
  
  risk_3:
    risk: Background subagent may silently fail without updating status file
    impact: High — go.md would poll forever waiting for a dead department.
    mitigation: Timeout guard on every gate. Timeout = configurable, default 30min.
      On timeout, dept-gate.sh returns exit 2, go.md runs dept-cleanup.sh and
      reports which departments are stalled. Future enhancement: heartbeat file
      updated every 60s by agent-start.sh hook.
  
  risk_4:
    risk: Concurrent file writes to api-contracts.jsonl from FE and BE
    impact: Medium — race condition could corrupt the JSONL file.
    mitigation: All writes go through dept-status.sh with flock locking.
      FE writes proposed entries, BE reads and writes agreed entries.
      flock ensures atomic append operations.
  
  risk_5:
    risk: Context window limits for background subagents running full 10-step
    impact: Medium — each department Lead drives 10 steps with its own subagents,
      consuming significant context.
    mitigation: Background subagents get auto-compaction at 95% capacity (Claude
      Code built-in). Department Leads are spawned with focused context (dept
      CONTEXT file only, not full project context). Each internal agent (Senior,
      Dev, etc.) is a further subagent with its own context window.
  
  ## Integration Points
  
  integration_points[4]{from,to,protocol}:
  
  point_1:
    from: go.md (Owner proxy)
    to: Department Lead subagents
    protocol: Task tool with run_in_background=true. Lead receives dept CONTEXT
      file path, phase directory, ROADMAP.md, REQUIREMENTS.md. Lead writes
      .dept-status-{dept}.json and handoff sentinel files on completion.
  
  point_2:
    from: Department Lead subagents
    to: go.md (Owner proxy)
    protocol: File-based. Lead writes .dept-status-{dept}.json with current
      step and completion status. go.md polls these files. No direct messaging.
  
  point_3:
    from: UX Lead subagent
    to: FE Lead subagent (via files)
    protocol: UX writes design-handoff.jsonl, design-tokens.jsonl,
      component-specs.jsonl to phase directory. Writes .handoff-ux-complete
      sentinel. go.md detects sentinel, spawns FE Lead which reads handoff files.
  
  point_4:
    from: FE Lead subagent
    to: BE Lead subagent (via files)
    protocol: FE writes proposed api-contracts.jsonl entries. BE reads and
      updates status to agreed. Both use flock for atomic access. No direct
      messaging between FE and BE subagents.
  
  ## Success Criteria (Updated)
  
  criteria:
    - Multi-dept execution spawns department Leads as background Task subagents
    - Departments run in parallel (FE + BE simultaneously after UX handoff gate)
    - Handoff gates use sentinel files with artifact validation
    - Status tracking via .dept-status-{dept}.json with flock locking
    - Graceful timeout with cleanup on any gate failure
    - Single-dept mode works identically when agent_teams=false or multi_dept=false
    - Zero dependency on Teammate API (spawnTeam, SendMessage not required)
    - All coordination files cleaned up after phase completion
  
  ## Critique Resolution Summary
  
  C-01 (critical): addressed — No SendMessage. File-based gates are synchronous and deterministic.
  C-02 (critical): addressed — No nested teams. No Teammate API at all. Background Task subagents.
  C-03 (critical): addressed — No spawnTeam. Background Task subagents run in single session.
  C-04 (major): addressed — No spawn-team.sh. dept-orchestrate.sh outputs data only.
  C-05 (major): addressed — No shutdown-team.sh. dept-cleanup.sh removes files only.
  C-06 (major): addressed — No team-profiles.json. Existing config + hierarchy is sufficient.
  C-07 (major): addressed — No team_id/dept in hook input. agent-start.sh detects dept from agent_type prefix.
  C-08 (major): addressed — No TaskList dependency. File-based coordination is session-scoped.
  C-09 (major): addressed — Orchestration in execute-protocol.md, not embedded in go.md.
  C-10 (major): addressed — Superseded by Option B. Hybrid model rejected due to API unreliability.
  C-11 (minor): addressed — Scope reduced: 4 new scripts, 4 modified files, 2 doc updates. ~10 tasks.
  C-12 (minor): addressed — Timeout + dept-cleanup.sh handles partial failures. Sequential fallback.
  C-13 (minor): addressed — resolve-departments.sh unchanged. dept-orchestrate.sh consumes its output.
  C-14 (minor): addressed — validate-send-message.sh unchanged. No dual-path needed.
  C-15 (minor): addressed — Minimal state: .dept-status-{dept}.json + .phase-orchestration.json only.


patterns: @.yolo-planning/codebase/PATTERNS.md

conventions[15]{category,rule}:
  file-structure
  naming
  naming
  naming
  naming
  style
  style
  style
  tooling
  style
  style
  patterns
  patterns
  tooling
  patterns
