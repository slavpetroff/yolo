{"id":"C-01","severity":"critical","category":"api-constraint","finding":"SendMessage delivery is async and not guaranteed. Plans (02-03, 02-04) assume synchronous coordination where Leads exchange handoff messages reliably. In practice, teammates go idle between turns and messages queue — delivery timing is unpredictable. 10-step workflow orchestration via SendMessage creates fragile coordination chains.","recommendation":"Use TaskList (shared task list) as primary coordination mechanism, not SendMessage. Tasks are persistent and polled, not pushed. Reserve SendMessage for notifications only, never as blocking gates.","st":"addressed","resolution":"Architecture chose Option B: no Teammate API at all. All coordination uses file-based sentinel files with flock locking. No SendMessage, no async delivery concerns. Gates are deterministic file-existence checks."}
{"id":"C-02","severity":"critical","category":"api-constraint","finding":"Teammate API forbids nested teams. Plans assume per-department teams where each department Lead creates a sub-team of specialists (02-01 spawn-team.sh spawns per-department). But teammates cannot call spawnTeam — only the session owner can create one team. A department Lead running as a teammate CANNOT spawn its own specialist team.","recommendation":"Redesign as flat structure: one team with department Leads as direct teammates of the Owner. Each Lead uses Task tool (subagents, not teammates) for its internal specialists. This preserves the existing 10-step per-department workflow while using teams for cross-department parallelism.","st":"addressed","resolution":"Architecture chose Option B: no Teammate API. Department Leads spawn as background Task subagents (run_in_background=true), not teammates. Each Lead uses foreground Task subagents for internal specialists. No nested team constraint applies."}
{"id":"C-03","severity":"critical","category":"api-constraint","finding":"One team per session. Plans (02-04) call spawnTeam 3 times (once per department) to create 3 simultaneous department teams. But team context is session-scoped — spawnTeam creates one team that the owner manages. Multiple simultaneous teams are not supported by the API.","recommendation":"Single team with all department Leads as teammates. Owner coordinates via TaskList. Leads coordinate with each other via SendMessage (Lead-to-Lead). Each Lead runs its 10-step workflow independently using Task tool subagents.","st":"addressed","resolution":"Architecture chose Option B: no spawnTeam at all. Parallel departments via multiple background Task subagents within single session. Claude Code supports up to 10 concurrent background subagents — sufficient for 3 department Leads."}
{"id":"C-04","severity":"major","category":"design","finding":"spawn-team.sh (02-01-02) attempts to programmatically orchestrate Teammate API calls from a bash script. But spawnTeam and SendMessage are Claude Code tools, not CLI commands. Scripts cannot invoke tools directly — they can only output instructions for the Owner agent to interpret.","recommendation":"spawn-team.sh should output a team configuration manifest (JSON) that go.md reads and translates into Teammate+Task tool calls. Script outputs data, Owner agent acts on it.","st":"addressed","resolution":"spawn-team.sh eliminated entirely. Replaced by dept-orchestrate.sh which outputs a JSON spawn plan (waves + departments). go.md reads this plan and spawns Task subagents directly. Pattern: script=data, agent=action — as recommended."}
{"id":"C-05","severity":"major","category":"design","finding":"shutdown-team.sh (02-01-03) same problem as C-04. It attempts to send shutdown_request from a script, but SendMessage is a tool only callable by the agent. The script cannot interact with the Teammate API.","recommendation":"shutdown-team.sh outputs shutdown instructions. go.md Owner agent reads these and calls SendMessage(type:shutdown_request) per teammate. Pattern: script=data, agent=action.","st":"addressed","resolution":"shutdown-team.sh eliminated entirely. Replaced by dept-cleanup.sh which removes coordination files (.dept-status-*.json, .handoff-*, .dept-lock-*, .phase-orchestration.json). Background Task subagents terminate naturally when their work completes — no shutdown protocol needed."}
{"id":"C-06","severity":"major","category":"duplication","finding":"config/team-profiles.json (02-01-01) duplicates agent roster data already in references/company-hierarchy.md and config/defaults.json. 26 agents with roles, models, departments are already defined. A second source of truth creates sync drift.","recommendation":"Derive team composition from existing config/defaults.json departments + company-hierarchy.md roster. No new config file needed — resolve-departments.sh already knows which departments are active and which agents belong to each.","st":"addressed","resolution":"team-profiles.json not created. Architecture uses existing resolve-departments.sh output for department routing and resolve-agent-model.sh for per-role model resolution. Zero new config files. Single source of truth preserved."}
{"id":"C-07","severity":"major","category":"gap","finding":"02-02-01 agent-start.sh team context assumes SubagentStart hook input includes team_id and dept fields. But SubagentStart event format is defined by Claude Code, not YOLO. The actual event payload may not contain team membership data.","recommendation":"Team context should come from the team config file (~/.claude/teams/{team-name}/config.json) which is readable by any teammate. Don't assume hook input contains team fields — read team config instead.","st":"addressed","resolution":"No team context needed. agent-start.sh detects department from agent_type prefix (yolo-fe-* = frontend, yolo-ux-* = uiux, yolo-* = backend). Writes .dept-status-{dept}.json via dept-status.sh. Uses only the existing SubagentStart agent_type field — no custom fields assumed."}
{"id":"C-08","severity":"major","category":"assumption","finding":"02-03-03 cross-team-protocol.md assumes TaskList is shared across all teams and departments. But Teams have 1:1 correspondence with TaskLists. If using a single team (per C-02/C-03 fix), this works. But if the plans keep per-department teams, each team has its own isolated TaskList.","recommendation":"This is resolved if the architecture adopts the single-team model (C-02/C-03). With one team, one shared TaskList coordinates all departments naturally.","st":"addressed","resolution":"No TaskList dependency. Architecture uses file-based coordination (.dept-status-{dept}.json, .handoff-* sentinel files). All departments operate within a single session using background Task subagents. No team-scoped TaskList isolation concern."}
{"id":"C-09","severity":"major","category":"scope","finding":"02-04-02 go.md execute mode changes are massive: reading team_spawn_plan, calling spawnTeam per department, dispatching via SendMessage, tracking team_ids, handling errors with --force shutdown. This is effectively a rewrite of the execute path, but go.md is already 300+ lines and the primary orchestration surface.","recommendation":"Extract team orchestration into a dedicated section or helper logic. Keep go.md focused on mode detection and dispatch. Team lifecycle management should be in execute-protocol.md instructions, not embedded in go.md prompt logic.","st":"addressed","resolution":"Orchestration logic lives in execute-protocol.md Multi-Department Execution section, not in go.md. go.md calls dept-orchestrate.sh for spawn plan, spawns background Task subagents, and polls status files. The concrete polling/gate logic is documented in execute-protocol.md. go.md remains focused on mode detection and dispatch."}
{"id":"C-10","severity":"major","category":"alternative","finding":"Hybrid model alternative: go.md creates ONE team with department Leads as teammates. Each Lead runs the existing 10-step workflow using Task tool (subagents) for its internal specialists. This preserves the proven single-agent workflow per department while enabling parallel cross-department execution via the team.","recommendation":"ADOPT THIS MODEL. It addresses C-01 through C-03, reuses existing Task-tool-based workflow, and only requires wiring: (1) spawnTeam with 3 Lead teammates, (2) TaskList for cross-department coordination, (3) SendMessage for Lead-to-Lead handoffs, (4) shutdown at phase end. Much smaller scope than current plans.","st":"addressed","resolution":"Hybrid model superseded by Option B (file-based only). Research confirmed Teammate API has critical reliability issues (GitHub #23415, #24108, #25037). User directive: prefer file-based communication with locks. Option B achieves the same parallelism via background Task subagents without any experimental API dependency. Even simpler scope than hybrid."}
{"id":"C-11","severity":"minor","category":"scope","finding":"18 tasks across 4 plans is large for infrastructure changes. Wave 1 alone creates 4 new scripts + config + 8 test files. Risk of implementation taking too long relative to value delivered.","recommendation":"If adopting hybrid model (C-10), scope shrinks significantly: no spawn-team.sh, no shutdown-team.sh, no team-profiles.json. Just protocol updates + go.md wiring + hook adaptations. Estimate 10-12 tasks instead of 18.","st":"addressed","resolution":"Scope reduced to 4 new scripts (dept-orchestrate.sh, dept-status.sh, dept-gate.sh, dept-cleanup.sh), 4 modified scripts (agent-start.sh, state-updater.sh, execute-protocol.md, multi-dept-protocol.md), and 2 documentation updates. Estimated 10-12 tasks across 2-3 plans. Eliminated: spawn-team.sh, shutdown-team.sh, team-profiles.json, and all Teammate API wiring."}
{"id":"C-12","severity":"minor","category":"edge-case","finding":"No rollback mechanism if team spawn partially fails. If 2 of 3 department Leads join but the 3rd fails, no cleanup path exists. Partial team state is orphaned.","recommendation":"go.md should have a cleanup-on-failure path: if any Lead fails to spawn within timeout, send shutdown_request to all active Leads and fall back to sequential Task tool mode.","st":"addressed","resolution":"Every handoff gate has a configurable timeout (default 30 min). On timeout, dept-gate.sh returns exit 2, go.md runs dept-cleanup.sh to remove all coordination files, and reports which departments stalled. Background Task subagents that are still running will complete or fail independently — their status files are cleaned up. Sequential fallback is possible by re-running with department_workflow=sequential."}
{"id":"C-13","severity":"minor","category":"gap","finding":"resolve-departments.sh team_spawn_plan field (02-04-01) mixes configuration concerns (which departments) with orchestration concerns (how to spawn). resolve-departments already outputs department lists — adding spawn instructions couples it to the Teammate API.","recommendation":"resolve-departments.sh outputs departments + agents (existing). go.md decides HOW to spawn based on agent_teams flag. No team_spawn_plan field needed.","st":"addressed","resolution":"resolve-departments.sh is unchanged. New dept-orchestrate.sh consumes its output and generates the spawn plan. Clean separation: resolve-departments.sh = what departments are active, dept-orchestrate.sh = how to spawn them."}
{"id":"C-14","severity":"minor","category":"risk","finding":"validate-send-message.sh Lead-to-Lead rule (02-02-03) requires knowing sender and recipient roles. In team mode, roles come from team config. In Task mode, roles come from .active-agent. The dual-path resolution adds complexity.","recommendation":"Simplify: in team mode, all teammates are registered in config.json. validate-send-message reads config.json members array. No dual-path needed.","st":"addressed","resolution":"validate-send-message.sh is unchanged. Architecture does not use SendMessage for coordination — all coordination is file-based. The existing hook remains functional for any manual Teammate API usage but is not on the critical path. No dual-path resolution needed."}
{"id":"C-15","severity":"minor","category":"improvement","finding":"state-updater.sh (02-04-03) new team tracking fields add complexity to already complex execution state JSON. departments.{dept}.team_id, agents[], status — these are runtime concerns that may not need persistence.","recommendation":"Minimal state: track only department completion status in execution state. Team membership is in team config.json (managed by Teammate API). Don't duplicate team state in execution state.","st":"addressed","resolution":"Minimal state: .dept-status-{dept}.json tracks per-department status (one file per dept, simple schema). .phase-orchestration.json tracks overall orchestration state (gates, timing). .execution-state.json gets a departments object only when multi_dept=true. No team_id, no agents array, no Teammate API state duplication."}
