{"p":"02-01","n":"Department Coordination Scripts","t":4,"w":1,"d":[],"mh":{"tr":["dept-orchestrate.sh outputs JSON spawn plan from resolve-departments.sh output","dept-status.sh performs atomic read/write of .dept-status-{dept}.json using flock with mkdir fallback","dept-gate.sh validates handoff gate conditions (sentinel files + artifact checks) with configurable timeout","dept-cleanup.sh removes only YOLO coordination files (.dept-status-*, .handoff-*, .dept-lock-*, .phase-orchestration.json)","All scripts are no-ops or exit cleanly when multi_dept=false"],"ar":[{"p":"scripts/dept-orchestrate.sh","pv":"bash scripts/dept-orchestrate.sh .yolo-planning/config.json .yolo-planning/phases/02-test/ outputs valid JSON with waves array","c":"Outputs JSON spawn plan with waves, depts per wave, gate names, and timeout"},{"p":"scripts/dept-status.sh","pv":"bash scripts/dept-status.sh --dept backend --phase-dir /tmp/test --action write --status running --step planning creates .dept-status-backend.json","c":"Atomic JSON write with flock locking and read-back verification"},{"p":"scripts/dept-gate.sh","pv":"bash scripts/dept-gate.sh --gate ux-complete --phase-dir /tmp/test --timeout 1 exits 0 or 1","c":"Gate checker with 3 exit codes: 0=satisfied, 1=timeout, 2=failure"},{"p":"scripts/dept-cleanup.sh","pv":"bash scripts/dept-cleanup.sh --phase-dir /tmp/test --reason complete removes coordination files only","c":"Safe cleanup that never touches user artifacts or plan/summary files"}],"kl":[{"fr":"scripts/resolve-departments.sh","to":"scripts/dept-orchestrate.sh","vi":"dept-orchestrate consumes resolve-departments output to build spawn plan"},{"fr":"scripts/dept-status.sh","to":"scripts/dept-gate.sh","vi":"dept-gate reads .dept-status-{dept}.json files written by dept-status"},{"fr":"scripts/dept-gate.sh","to":"scripts/dept-cleanup.sh","vi":"dept-cleanup removes files created/checked by dept-gate and dept-status"}]},"obj":"Create 4 new coordination scripts that implement file-based multi-department orchestration: spawn plan generation, atomic status tracking, handoff gate validation, and cleanup.","sk":["commit"],"fm":["scripts/dept-orchestrate.sh","scripts/dept-status.sh","scripts/dept-gate.sh","scripts/dept-cleanup.sh","tests/unit/dept-orchestrate.bats","tests/unit/dept-status.bats","tests/unit/dept-gate.bats","tests/unit/dept-cleanup.bats"]}
{"id":"02-01-01","n":"Create dept-orchestrate.sh","f":["scripts/dept-orchestrate.sh"],"d":[],"ac":["scripts/dept-orchestrate.sh exists and is executable","Accepts config_path and phase_dir as positional args","Calls resolve-departments.sh internally and parses its output","Outputs JSON: {waves:[{id:N,depts:[...],gate:string}],timeout_minutes:N}","For parallel workflow with UX+FE+BE: wave 1=[uiux] gate=handoff-ux-complete, wave 2=[frontend,backend] gate=all-depts-complete","For parallel without UX: wave 1=[frontend,backend] gate=all-depts-complete","For sequential: one dept per wave with per-dept gates","For backend_only: single wave=[backend] gate=all-depts-complete","When multi_dept=false: outputs {waves:[{id:1,depts:[\"backend\"],gate:\"all-depts-complete\"}],timeout_minutes:30}","Uses set -euo pipefail, jq for JSON output","Exits 0 on success, 1 on invalid args"],"spec":"FILE: scripts/dept-orchestrate.sh (new, chmod +x)\nSHEBANG: #!/usr/bin/env bash\nFLAGS: set -euo pipefail\n\nPURPOSE: Generate JSON spawn plan from resolve-departments.sh output. Pure data script -- no tool invocations.\n\nARGS:\n  $1 = config_path (required) -- path to config.json\n  $2 = phase_dir (required) -- path to phase directory (used in output metadata, not read)\n  If either arg missing: echo 'Usage: dept-orchestrate.sh <config_path> <phase_dir>' to stderr, exit 1.\n\nCONSTANTS:\n  DEFAULT_TIMEOUT=30  (minutes)\n  SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"  -- for locating resolve-departments.sh\n\nSTEP 1: CALL resolve-departments.sh\n  Run: bash \"$SCRIPT_DIR/resolve-departments.sh\" \"$CONFIG_PATH\"\n  Capture output into a variable.\n  Parse key=value pairs into shell vars using eval on each line:\n    while IFS= read -r line; do\n      case \"$line\" in\n        multi_dept=*|workflow=*|active_depts=*|leads_to_spawn=*|spawn_order=*|ux_active=*|fe_active=*)\n          eval \"$line\" ;;\n      esac\n    done <<< \"$RESOLVE_OUTPUT\"\n  NOTE: Use a case statement whitelist for safety -- only eval known keys.\n\nSTEP 2: BUILD WAVES ARRAY\n  Use a bash variable WAVES_JSON to accumulate wave objects.\n  Initialize WAVE_ID=1.\n\n  Case 1: multi_dept=false OR workflow=backend_only\n    Single wave: {\"id\":1,\"depts\":[\"backend\"],\"gate\":\"all-depts-complete\"}\n\n  Case 2: workflow=parallel\n    Parse leads_to_spawn which uses | for wave separators and , for parallel depts within a wave.\n    For each wave (split on |):\n      Map lead names to dept names: ux-lead->uiux, fe-lead->frontend, lead->backend\n      Create wave object: {\"id\":$WAVE_ID,\"depts\":[...],\"gate\":\"...\"}\n      Gate assignment:\n        - If wave contains only [\"uiux\"]: gate=\"handoff-ux-complete\"\n        - If wave contains only [\"frontend\"] or only [\"backend\"]: gate=\"handoff-{dept}-complete\"\n        - Otherwise (last wave or multi-dept wave): gate=\"all-depts-complete\"\n      Increment WAVE_ID.\n\n  Case 3: workflow=sequential\n    Same parsing as parallel but each lead is in its own wave (split on |).\n    Gate for each dept wave: gate=\"handoff-{dept}-complete\" EXCEPT last wave which gets \"all-depts-complete\".\n\nSTEP 3: OUTPUT JSON\n  Use jq to construct final output. Build the waves array in bash as a JSON string, then pipe to jq for validation:\n    echo \"$WAVES_JSON\" | jq --argjson timeout \"$DEFAULT_TIMEOUT\" '{waves: ., timeout_minutes: $timeout}'\n  This ensures output is always valid JSON.\n\nLEAD-TO-DEPT MAPPING FUNCTION:\n  lead_to_dept() {\n    case \"$1\" in\n      ux-lead) echo \"uiux\" ;;\n      fe-lead) echo \"frontend\" ;;\n      lead)    echo \"backend\" ;;\n      *)       echo \"$1\" ;;  # passthrough unknown\n    esac\n  }\n\nGATE ASSIGNMENT FUNCTION:\n  assign_gate() {\n    local depts_csv=\"$1\" is_last=\"$2\"\n    if [ \"$is_last\" = true ]; then\n      echo \"all-depts-complete\"\n    elif [ \"$depts_csv\" = \"uiux\" ]; then\n      echo \"handoff-ux-complete\"\n    elif [ \"$depts_csv\" = \"frontend\" ]; then\n      echo \"handoff-frontend-complete\"\n    elif [ \"$depts_csv\" = \"backend\" ]; then\n      echo \"handoff-backend-complete\"\n    else\n      echo \"all-depts-complete\"\n    fi\n  }\n\nJSON CONSTRUCTION:\n  Build waves as a bash string array, then join:\n  WAVE_ITEMS=()  # array of JSON wave objects\n  For each wave: WAVE_ITEMS+=(\"$(jq -n --argjson id $WAVE_ID --argjson depts '[\"dept1\",\"dept2\"]' --arg gate \"$GATE\" '{id:$id,depts:$depts,gate:$gate}')\")\n  Final: printf '%s\\n' \"${WAVE_ITEMS[@]}\" | jq -s --argjson timeout $DEFAULT_TIMEOUT '{waves:.,timeout_minutes:$timeout}'\n\nEDGE CASES:\n  - resolve-departments.sh fails (exit non-zero): propagate error, exit 1\n  - config_path does not exist: resolve-departments.sh handles this gracefully (outputs defaults), so dept-orchestrate still works\n  - Empty leads_to_spawn: should not happen (resolve-departments always sets it), but guard: if empty, default to single backend wave\n\nEXIT CODES: 0=success (valid JSON on stdout), 1=invalid args or resolve-departments failure\n\nEXAMPLE OUTPUTS:\n  Parallel UX+FE+BE: {\"waves\":[{\"id\":1,\"depts\":[\"uiux\"],\"gate\":\"handoff-ux-complete\"},{\"id\":2,\"depts\":[\"frontend\",\"backend\"],\"gate\":\"all-depts-complete\"}],\"timeout_minutes\":30}\n  Parallel FE+BE (no UX): {\"waves\":[{\"id\":1,\"depts\":[\"frontend\",\"backend\"],\"gate\":\"all-depts-complete\"}],\"timeout_minutes\":30}\n  Sequential UX+FE+BE: {\"waves\":[{\"id\":1,\"depts\":[\"uiux\"],\"gate\":\"handoff-ux-complete\"},{\"id\":2,\"depts\":[\"frontend\"],\"gate\":\"handoff-frontend-complete\"},{\"id\":3,\"depts\":[\"backend\"],\"gate\":\"all-depts-complete\"}],\"timeout_minutes\":30}\n  Backend only: {\"waves\":[{\"id\":1,\"depts\":[\"backend\"],\"gate\":\"all-depts-complete\"}],\"timeout_minutes\":30}\n\nPATTERN: Follow resolve-departments.sh style -- same shebang, same SCRIPT_DIR resolution, same jq usage for output. Pure data script (script=data, agent=action per C-04 resolution).","ts":"FILE: tests/unit/dept-orchestrate.bats\nFRAMEWORK: BATS with bats-support, bats-assert, bats-file\nLOAD: load '../test_helper/common' and load '../test_helper/fixtures'\n\nSETUP:\n  setup() {\n    load '../test_helper/common'\n    load '../test_helper/fixtures'\n    mk_test_workdir\n    SUT=\"$SCRIPTS_DIR/dept-orchestrate.sh\"\n  }\n\nHELPER mk_config: Same as resolve-departments.bats -- creates config.json at $TEST_WORKDIR/.yolo-planning/config.json with departments and department_workflow fields via jq -n.\n\nHELPER run_orchestrate:\n  run_orchestrate() {\n    local config=\"${1:-$TEST_WORKDIR/.yolo-planning/config.json}\"\n    local phase_dir=\"${2:-$TEST_WORKDIR/.yolo-planning/phases/02-test}\"\n    run bash \"$SUT\" \"$config\" \"$phase_dir\"\n  }\n\nTEST CASES (minimum 6):\n\n1. @test \"parallel 3-dept: UX wave then FE+BE wave\"\n   mk_config true true true parallel\n   run_orchestrate\n   assert_success\n   Verify output with jq: .waves | length == 2\n   Verify .waves[0].depts == [\"uiux\"] and .waves[0].gate == \"handoff-ux-complete\"\n   Verify .waves[1].depts contains \"frontend\" and \"backend\" and .waves[1].gate == \"all-depts-complete\"\n   Verify .timeout_minutes == 30\n\n2. @test \"parallel no-UX: single wave FE+BE\"\n   mk_config true true false parallel\n   run_orchestrate\n   assert_success\n   Verify .waves | length == 1\n   Verify .waves[0].depts contains \"frontend\" and \"backend\"\n   Verify .waves[0].gate == \"all-depts-complete\"\n\n3. @test \"sequential 3-dept: three waves\"\n   mk_config true true true sequential\n   run_orchestrate\n   assert_success\n   Verify .waves | length == 3\n   Verify .waves[0].depts == [\"uiux\"] and gate == \"handoff-ux-complete\"\n   Verify .waves[1].depts == [\"frontend\"] and gate == \"handoff-frontend-complete\"\n   Verify .waves[2].depts == [\"backend\"] and gate == \"all-depts-complete\"\n\n4. @test \"backend-only: single wave\"\n   mk_config true false false backend_only\n   run_orchestrate\n   assert_success\n   Verify .waves | length == 1\n   Verify .waves[0].depts == [\"backend\"]\n   Verify .waves[0].gate == \"all-depts-complete\"\n\n5. @test \"output is valid JSON\"\n   mk_config true true true parallel\n   run_orchestrate\n   assert_success\n   Run: echo \"$output\" | jq . (must succeed, not fail)\n   Verify .waves is array, .timeout_minutes is number\n\n6. @test \"missing config: defaults to backend-only wave\"\n   run_orchestrate \"$TEST_WORKDIR/nonexistent.json\" \"$TEST_WORKDIR/phase\"\n   assert_success\n   Verify .waves | length == 1\n   Verify .waves[0].depts == [\"backend\"]\n\n7. @test \"missing args: exits 1 with usage\"\n   run bash \"$SUT\"\n   assert_failure\n   assert_output --partial \"Usage\"\n\n8. @test \"parallel UX-only (no FE): two waves\"\n   mk_config true false true parallel\n   run_orchestrate\n   assert_success\n   Verify .waves | length == 2\n   Verify .waves[0].depts == [\"uiux\"]\n   Verify .waves[1].depts == [\"backend\"]\n\nASSERTION PATTERN: Use jq -r on $output to extract fields. Example:\n  local wave_count=$(echo \"$output\" | jq '.waves | length')\n  assert_equal \"$wave_count\" \"2\""}
{"id":"02-01-02","n":"Create dept-status.sh","f":["scripts/dept-status.sh"],"d":[],"ac":["scripts/dept-status.sh exists and is executable","Accepts --dept, --phase-dir, --action (read|write), --status, --step, --error flags","Write action: creates/updates .dept-status-{dept}.json with flock on .dept-lock-{dept}","flock fallback: uses mkdir-based locking when flock unavailable (macOS compat)","JSON schema: {dept,status,step,started_at,updated_at,plans_complete,plans_total,error}","Read action: outputs current status JSON to stdout, exits 1 if file missing","Write action: sets started_at on first write, updates updated_at on every write","Accepts --plans-complete and --plans-total optional flags for progress tracking","Uses set -euo pipefail, jq for JSON manipulation","Exits 0 on success, 1 on missing file (read), 2 on lock timeout"],"spec":"FILE: scripts/dept-status.sh (new, chmod +x)\nSHEBANG: #!/usr/bin/env bash\nFLAGS: set -euo pipefail\n\nPURPOSE: Atomic read/write of per-department status files using flock with mkdir fallback.\n\nARGS (parsed via while-shift loop):\n  --dept <name>          (required) Department name: backend|frontend|uiux\n  --phase-dir <path>     (required) Phase directory path\n  --action <read|write>  (required) Operation to perform\n  --status <value>       (write only) Status: pending|running|complete|failed\n  --step <value>         (write only) Current step: critique|architecture|planning|design_review|implementation|code_review|testing|qa|security|signoff\n  --error <message>      (write only, optional) Error message string\n  --plans-complete <N>   (write only, optional, default 0) Number of completed plans\n  --plans-total <N>      (write only, optional, default 0) Total number of plans\n\nARG PARSING:\n  DEPT=\"\" PHASE_DIR=\"\" ACTION=\"\" STATUS=\"\" STEP=\"\" ERROR=\"\" PLANS_COMPLETE=0 PLANS_TOTAL=0\n  while [ $# -gt 0 ]; do\n    case \"$1\" in\n      --dept) DEPT=\"$2\"; shift 2 ;;\n      --phase-dir) PHASE_DIR=\"$2\"; shift 2 ;;\n      --action) ACTION=\"$2\"; shift 2 ;;\n      --status) STATUS=\"$2\"; shift 2 ;;\n      --step) STEP=\"$2\"; shift 2 ;;\n      --error) ERROR=\"$2\"; shift 2 ;;\n      --plans-complete) PLANS_COMPLETE=\"$2\"; shift 2 ;;\n      --plans-total) PLANS_TOTAL=\"$2\"; shift 2 ;;\n      *) echo \"Unknown flag: $1\" >&2; exit 1 ;;\n    esac\n  done\n\nVALIDATION:\n  If DEPT, PHASE_DIR, or ACTION empty: echo usage to stderr, exit 1.\n  If ACTION=write and STATUS empty: echo 'ERROR: --status required for write action' >&2, exit 1.\n  If ACTION=write and STEP empty: echo 'ERROR: --step required for write action' >&2, exit 1.\n  If ACTION not read|write: echo 'ERROR: --action must be read or write' >&2, exit 1.\n\nFILE PATHS:\n  STATUS_FILE=\"$PHASE_DIR/.dept-status-${DEPT}.json\"\n  LOCK_FILE=\"$PHASE_DIR/.dept-lock-${DEPT}\"\n  LOCK_DIR=\"$PHASE_DIR/.dept-lock-${DEPT}.d\"  # mkdir fallback\n\nLOCKING MECHANISM:\n  LOCK_TIMEOUT=10  # seconds\n\n  acquire_lock() {\n    # Try flock first\n    if command -v flock >/dev/null 2>&1; then\n      exec 9>\"$LOCK_FILE\"\n      if ! flock -w \"$LOCK_TIMEOUT\" 9; then\n        echo \"ERROR: Lock timeout after ${LOCK_TIMEOUT}s on $LOCK_FILE\" >&2\n        exit 2\n      fi\n    else\n      # mkdir fallback (atomic on all POSIX systems)\n      local attempts=0\n      local max_attempts=$((LOCK_TIMEOUT * 10))  # 100ms intervals\n      while ! mkdir \"$LOCK_DIR\" 2>/dev/null; do\n        attempts=$((attempts + 1))\n        if [ \"$attempts\" -ge \"$max_attempts\" ]; then\n          echo \"ERROR: Lock timeout after ${LOCK_TIMEOUT}s on $LOCK_DIR\" >&2\n          exit 2\n        fi\n        sleep 0.1\n      done\n      # Set trap to clean up lock dir on exit\n      trap 'rmdir \"$LOCK_DIR\" 2>/dev/null || true' EXIT\n    fi\n  }\n\n  release_lock() {\n    if command -v flock >/dev/null 2>&1; then\n      exec 9>&-  # close fd\n    else\n      rmdir \"$LOCK_DIR\" 2>/dev/null || true\n    fi\n  }\n\nREAD ACTION:\n  if [ \"$ACTION\" = \"read\" ]; then\n    if [ ! -f \"$STATUS_FILE\" ]; then\n      echo \"ERROR: Status file not found: $STATUS_FILE\" >&2\n      exit 1\n    fi\n    cat \"$STATUS_FILE\"\n    exit 0\n  fi\n\nWRITE ACTION:\n  NOW=$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\n  acquire_lock\n\n  # Determine started_at: preserve from existing file, or set to NOW\n  STARTED_AT=\"$NOW\"\n  if [ -f \"$STATUS_FILE\" ]; then\n    EXISTING_STARTED=$(jq -r '.started_at // \"\"' \"$STATUS_FILE\" 2>/dev/null)\n    if [ -n \"$EXISTING_STARTED\" ] && [ \"$EXISTING_STARTED\" != \"null\" ]; then\n      STARTED_AT=\"$EXISTING_STARTED\"\n    fi\n  fi\n\n  # Write status JSON atomically (write to temp, then mv)\n  TEMP_FILE=\"${STATUS_FILE}.tmp.$$\"\n  jq -n \\\n    --arg dept \"$DEPT\" \\\n    --arg status \"$STATUS\" \\\n    --arg step \"$STEP\" \\\n    --arg started_at \"$STARTED_AT\" \\\n    --arg updated_at \"$NOW\" \\\n    --argjson plans_complete \"$PLANS_COMPLETE\" \\\n    --argjson plans_total \"$PLANS_TOTAL\" \\\n    --arg error \"$ERROR\" \\\n    '{dept:$dept,status:$status,step:$step,started_at:$started_at,updated_at:$updated_at,plans_complete:$plans_complete,plans_total:$plans_total,error:$error}' \\\n    > \"$TEMP_FILE\"\n  mv \"$TEMP_FILE\" \"$STATUS_FILE\"\n\n  release_lock\n  exit 0\n\nJSON OUTPUT SCHEMA:\n  {\n    \"dept\": \"backend\",\n    \"status\": \"running\",\n    \"step\": \"implementation\",\n    \"started_at\": \"2026-02-17T01:00:00Z\",\n    \"updated_at\": \"2026-02-17T01:05:00Z\",\n    \"plans_complete\": 2,\n    \"plans_total\": 3,\n    \"error\": \"\"\n  }\n\nEDGE CASES:\n  - Phase dir does not exist: jq write will fail, set -e will catch it. Let it fail with clear error.\n  - Concurrent writes: flock/mkdir prevents corruption.\n  - First write vs update: started_at is set on first write, preserved on subsequent.\n  - Read of non-existent file: exit 1 with descriptive error.\n  - Lock timeout: exit 2.\n  - jq not available: set -euo will fail at jq invocation. This is acceptable (jq is a YOLO requirement).\n\nEXIT CODES: 0=success, 1=missing file (read) or invalid args, 2=lock timeout\n\nPATTERN: Follow resolve-departments.sh style for arg handling. Follow state-updater.sh pattern for atomic write (temp file + mv).","ts":"FILE: tests/unit/dept-status.bats\nFRAMEWORK: BATS with bats-support, bats-assert, bats-file\nLOAD: load '../test_helper/common' and load '../test_helper/fixtures'\n\nSETUP:\n  setup() {\n    load '../test_helper/common'\n    load '../test_helper/fixtures'\n    mk_test_workdir\n    SUT=\"$SCRIPTS_DIR/dept-status.sh\"\n    # Create phase dir for all tests\n    PHASE_DIR=\"$TEST_WORKDIR/.yolo-planning/phases/02-test\"\n    mkdir -p \"$PHASE_DIR\"\n  }\n\nHELPER run_status:\n  run_status() {\n    run bash \"$SUT\" \"$@\"\n  }\n\nTEST CASES (minimum 6):\n\n1. @test \"write creates .dept-status-backend.json\"\n   run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --status running --step planning\n   assert_success\n   assert_file_exists \"$PHASE_DIR/.dept-status-backend.json\"\n   Verify with jq: .dept == \"backend\", .status == \"running\", .step == \"planning\"\n\n2. @test \"read returns JSON to stdout\"\n   First write: run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --status running --step planning\n   Then read: run_status --dept backend --phase-dir \"$PHASE_DIR\" --action read\n   assert_success\n   Verify output is valid JSON: echo \"$output\" | jq . (must not fail)\n   Verify .dept == \"backend\"\n\n3. @test \"read exits 1 when file missing\"\n   run_status --dept frontend --phase-dir \"$PHASE_DIR\" --action read\n   assert_failure\n   assert_output --partial \"not found\"\n\n4. @test \"started_at set on first write, preserved on update\"\n   First write:\n   run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --status pending --step critique\n   assert_success\n   local first_started=$(jq -r '.started_at' \"$PHASE_DIR/.dept-status-backend.json\")\n   sleep 1  # ensure time difference\n   Second write:\n   run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --status running --step planning\n   assert_success\n   local second_started=$(jq -r '.started_at' \"$PHASE_DIR/.dept-status-backend.json\")\n   assert_equal \"$first_started\" \"$second_started\"  # started_at preserved\n\n5. @test \"updated_at changes on every write\"\n   First write:\n   run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --status pending --step critique\n   local first_updated=$(jq -r '.updated_at' \"$PHASE_DIR/.dept-status-backend.json\")\n   sleep 1\n   Second write:\n   run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --status running --step planning\n   local second_updated=$(jq -r '.updated_at' \"$PHASE_DIR/.dept-status-backend.json\")\n   Verify first_updated != second_updated (use refute_equal or [ \"$first_updated\" != \"$second_updated\" ])\n\n6. @test \"plans-complete and plans-total tracked\"\n   run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --status running --step implementation --plans-complete 2 --plans-total 3\n   assert_success\n   Verify .plans_complete == 2 and .plans_total == 3 via jq\n\n7. @test \"error field stored on write\"\n   run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --status failed --step implementation --error \"Build failed: missing dependency\"\n   assert_success\n   Verify .error == \"Build failed: missing dependency\" via jq\n\n8. @test \"missing required args exits 1\"\n   run_status --dept backend\n   assert_failure\n   run_status --action write\n   assert_failure\n\n9. @test \"write action without --status exits 1\"\n   run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --step planning\n   assert_failure\n   assert_output --partial \"--status required\"\n\n10. @test \"different departments create separate files\"\n    run_status --dept backend --phase-dir \"$PHASE_DIR\" --action write --status running --step planning\n    run_status --dept frontend --phase-dir \"$PHASE_DIR\" --action write --status pending --step critique\n    assert_file_exists \"$PHASE_DIR/.dept-status-backend.json\"\n    assert_file_exists \"$PHASE_DIR/.dept-status-frontend.json\"\n    Verify backend .status == \"running\" and frontend .status == \"pending\""}
{"id":"02-01-03","n":"Create dept-gate.sh and dept-cleanup.sh","f":["scripts/dept-gate.sh","scripts/dept-cleanup.sh"],"d":[],"ac":["scripts/dept-gate.sh exists and is executable","Accepts --gate (ux-complete|api-contract|all-depts), --phase-dir, --timeout (seconds, default 1800)","Gate ux-complete: checks .handoff-ux-complete exists + design-handoff.jsonl valid + design-tokens.jsonl exists + component-specs.jsonl valid","Gate api-contract: checks api-contracts.jsonl exists with at least one status=agreed entry","Gate all-depts: checks every .dept-status-{dept}.json has status=complete + at least one summary.jsonl per dept","Polling loop: checks gate condition, sleeps 0.5s, checks timeout","Exit codes: 0=gate satisfied, 1=timeout, 2=validation failure","scripts/dept-cleanup.sh exists and is executable","Accepts --phase-dir and --reason (complete|failure|timeout)","Removes: .dept-status-*.json, .handoff-*, .dept-lock-*, .phase-orchestration.json from phase-dir","Never removes: *.plan.jsonl, *.summary.jsonl, *.toon, *.md, or any non-coordination file","Outputs list of removed files to stdout","Uses set -euo pipefail","Both exit 0 on success"],"spec":"=== FILE 1: scripts/dept-gate.sh (new, chmod +x) ===\nSHEBANG: #!/usr/bin/env bash\nFLAGS: set -euo pipefail\n\nPURPOSE: Check handoff gate conditions with polling and timeout. Used by go.md to wait for department handoff gates.\n\nARGS (parsed via while-shift loop):\n  --gate <name>          (required) Gate type: ux-complete|api-contract|all-depts\n  --phase-dir <path>     (required) Phase directory path\n  --timeout <seconds>    (optional, default 1800) Max wait time in seconds\n  --poll-interval <secs> (optional, default 0.5) Seconds between checks\n  --no-poll              (optional flag) Check once and exit immediately (no polling loop). Useful for testing.\n\nARG PARSING:\n  GATE=\"\" PHASE_DIR=\"\" TIMEOUT=1800 POLL_INTERVAL=0.5 NO_POLL=false\n  while [ $# -gt 0 ]; do\n    case \"$1\" in\n      --gate) GATE=\"$2\"; shift 2 ;;\n      --phase-dir) PHASE_DIR=\"$2\"; shift 2 ;;\n      --timeout) TIMEOUT=\"$2\"; shift 2 ;;\n      --poll-interval) POLL_INTERVAL=\"$2\"; shift 2 ;;\n      --no-poll) NO_POLL=true; shift ;;\n      *) echo \"Unknown flag: $1\" >&2; exit 1 ;;\n    esac\n  done\n\nVALIDATION:\n  If GATE or PHASE_DIR empty: echo usage to stderr, exit 1.\n  If GATE not in ux-complete|api-contract|all-depts: echo 'ERROR: Unknown gate: $GATE' >&2, exit 1.\n\nGATE CHECK FUNCTIONS:\n\n  check_ux_complete() {\n    # 1. Sentinel file must exist\n    [ -f \"$PHASE_DIR/.handoff-ux-complete\" ] || return 1\n    # 2. design-handoff.jsonl must exist and have valid JSON on line 1\n    [ -f \"$PHASE_DIR/design-handoff.jsonl\" ] || return 1\n    jq empty \"$PHASE_DIR/design-handoff.jsonl\" 2>/dev/null || return 1\n    # 3. design-tokens.jsonl must exist\n    [ -f \"$PHASE_DIR/design-tokens.jsonl\" ] || return 1\n    # 4. component-specs.jsonl must exist and have valid JSON on line 1\n    [ -f \"$PHASE_DIR/component-specs.jsonl\" ] || return 1\n    jq empty \"$PHASE_DIR/component-specs.jsonl\" 2>/dev/null || return 1\n    return 0\n  }\n\n  check_api_contract() {\n    local contracts=\"$PHASE_DIR/api-contracts.jsonl\"\n    [ -f \"$contracts\" ] || return 1\n    # Must have at least one line with status=agreed\n    # Read line by line checking for agreed status\n    local found=false\n    while IFS= read -r line; do\n      local st\n      st=$(echo \"$line\" | jq -r '.status // \"\"' 2>/dev/null) || continue\n      if [ \"$st\" = \"agreed\" ]; then\n        found=true\n        break\n      fi\n    done < \"$contracts\"\n    [ \"$found\" = true ] && return 0 || return 1\n  }\n\n  check_all_depts() {\n    # Find all .dept-status-*.json files\n    local status_files\n    status_files=$(ls \"$PHASE_DIR\"/.dept-status-*.json 2>/dev/null) || return 1\n    [ -z \"$status_files\" ] && return 1\n    # Every status file must have status=complete\n    while IFS= read -r sf; do\n      local st\n      st=$(jq -r '.status // \"\"' \"$sf\" 2>/dev/null) || return 1\n      [ \"$st\" = \"complete\" ] || return 1\n    done <<< \"$status_files\"\n    # At least one summary.jsonl must exist in phase dir\n    local summaries\n    summaries=$(ls \"$PHASE_DIR\"/*.summary.jsonl 2>/dev/null | head -1) || true\n    [ -n \"$summaries\" ] || return 1\n    return 0\n  }\n\nPOLLING LOOP:\n  START_TIME=$(date +%s)\n  while true; do\n    # Check gate condition\n    if check_${GATE//-/_}; then\n      exit 0  # Gate satisfied\n    fi\n\n    # If --no-poll, single check mode\n    if [ \"$NO_POLL\" = true ]; then\n      exit 1  # Gate not satisfied, no polling\n    fi\n\n    # Check timeout\n    ELAPSED=$(( $(date +%s) - START_TIME ))\n    if [ \"$ELAPSED\" -ge \"$TIMEOUT\" ]; then\n      echo \"TIMEOUT: Gate '$GATE' not satisfied after ${TIMEOUT}s\" >&2\n      exit 1\n    fi\n\n    sleep \"$POLL_INTERVAL\"\n  done\n\nNOTE ON FUNCTION DISPATCH:\n  The gate name uses hyphens (ux-complete) but bash functions use underscores.\n  Convert: check_${GATE//-/_} turns \"ux-complete\" into check_ux_complete.\n\nEXIT CODES: 0=gate satisfied, 1=timeout or gate not met (single check), 2=validation failure (invalid gate name or structural error)\n\nEDGE CASES:\n  - PHASE_DIR does not exist: gate checks return 1 (file not found), polls until timeout\n  - jq validation fails on malformed JSONL: returns 1, keeps polling\n  - No .dept-status files for all-depts: returns 1 (no files to check)\n  - Timeout=0: immediate check, no loop (same as --no-poll)\n  - All gate checks must be non-destructive (read only)\n\n=== FILE 2: scripts/dept-cleanup.sh (new, chmod +x) ===\nSHEBANG: #!/usr/bin/env bash\nFLAGS: set -euo pipefail\n\nPURPOSE: Remove YOLO coordination files from phase directory after completion or failure. Safety guarantee: never removes user artifacts.\n\nARGS (parsed via while-shift loop):\n  --phase-dir <path>     (required) Phase directory path\n  --reason <value>       (required) Reason: complete|failure|timeout\n\nARG PARSING:\n  PHASE_DIR=\"\" REASON=\"\"\n  while [ $# -gt 0 ]; do\n    case \"$1\" in\n      --phase-dir) PHASE_DIR=\"$2\"; shift 2 ;;\n      --reason) REASON=\"$2\"; shift 2 ;;\n      *) echo \"Unknown flag: $1\" >&2; exit 1 ;;\n    esac\n  done\n\nVALIDATION:\n  If PHASE_DIR or REASON empty: echo usage to stderr, exit 1.\n  If REASON not in complete|failure|timeout: echo 'ERROR: --reason must be complete, failure, or timeout' >&2, exit 1.\n  If PHASE_DIR does not exist: echo \"WARNING: Phase dir does not exist: $PHASE_DIR\" >&2, exit 0.\n\nCLEANUP PATTERNS (explicit allowlist of coordination file patterns):\n  PATTERNS=(\n    \".dept-status-*.json\"    # Department status files\n    \".handoff-*\"             # Handoff sentinel files\n    \".dept-lock-*\"           # flock lockfiles\n    \".dept-lock-*.d\"         # mkdir lockfiles (fallback)\n    \".phase-orchestration.json\"  # Master orchestration state\n  )\n\nCLEANUP LOGIC:\n  REMOVED=()\n  for pattern in \"${PATTERNS[@]}\"; do\n    for file in \"$PHASE_DIR\"/$pattern; do\n      if [ -f \"$file\" ]; then\n        rm -f \"$file\"\n        REMOVED+=(\"$(basename \"$file\")\")\n      elif [ -d \"$file\" ]; then\n        rmdir \"$file\" 2>/dev/null || true  # mkdir lock dirs\n        REMOVED+=(\"$(basename \"$file\")\")\n      fi\n    done\n  done\n\nOUTPUT:\n  # Print removed files to stdout\n  if [ ${#REMOVED[@]} -gt 0 ]; then\n    echo \"Cleaned up ${#REMOVED[@]} coordination files (reason: $REASON):\"\n    for f in \"${REMOVED[@]}\"; do\n      echo \"  removed: $f\"\n    done\n  else\n    echo \"No coordination files to clean up in $PHASE_DIR\"\n  fi\n\nSAFETY GUARANTEES (enforced by pattern allowlist):\n  NEVER removed: *.plan.jsonl, *.summary.jsonl, *.toon, *.md, architecture.toon, decisions.jsonl, critique.jsonl, code-review.jsonl, test-plan.jsonl, any file not matching coordination patterns.\n  Pattern approach: only files starting with . (dot-prefixed) and matching exact patterns are removed. User artifacts do not start with dots.\n\nEXIT CODES: 0=always (cleanup is best-effort)\n\nEDGE CASES:\n  - Empty phase dir: outputs 'No coordination files' message, exits 0.\n  - Phase dir does not exist: warning to stderr, exits 0.\n  - Partial cleanup (some files already removed): skips missing files, reports remaining.\n  - Lock dirs from mkdir fallback: uses rmdir (safe, fails if non-empty).","ts":"=== FILE 1: tests/unit/dept-gate.bats ===\nFRAMEWORK: BATS with bats-support, bats-assert, bats-file\nLOAD: load '../test_helper/common' and load '../test_helper/fixtures'\n\nSETUP:\n  setup() {\n    load '../test_helper/common'\n    load '../test_helper/fixtures'\n    mk_test_workdir\n    SUT=\"$SCRIPTS_DIR/dept-gate.sh\"\n    PHASE_DIR=\"$TEST_WORKDIR/.yolo-planning/phases/02-test\"\n    mkdir -p \"$PHASE_DIR\"\n  }\n\nHELPER mk_ux_handoff_artifacts:\n  mk_ux_handoff_artifacts() {\n    touch \"$PHASE_DIR/.handoff-ux-complete\"\n    echo '{\"status\":\"complete\",\"dept\":\"uiux\"}' > \"$PHASE_DIR/design-handoff.jsonl\"\n    echo '{\"token\":\"primary\",\"value\":\"#000\"}' > \"$PHASE_DIR/design-tokens.jsonl\"\n    echo '{\"component\":\"Button\",\"status\":\"ready\"}' > \"$PHASE_DIR/component-specs.jsonl\"\n  }\n\nHELPER mk_dept_complete:\n  mk_dept_complete() {\n    local dept=\"$1\"\n    echo \"{\\\"dept\\\":\\\"$dept\\\",\\\"status\\\":\\\"complete\\\",\\\"step\\\":\\\"signoff\\\"}\" > \"$PHASE_DIR/.dept-status-${dept}.json\"\n  }\n\nTEST CASES (minimum 6):\n\n1. @test \"ux-complete gate passes with all artifacts\"\n   mk_ux_handoff_artifacts\n   run bash \"$SUT\" --gate ux-complete --phase-dir \"$PHASE_DIR\" --no-poll\n   assert_success\n\n2. @test \"ux-complete gate fails without sentinel file\"\n   # Create artifacts but NOT the sentinel\n   echo '{\"status\":\"complete\"}' > \"$PHASE_DIR/design-handoff.jsonl\"\n   echo '{\"token\":\"primary\"}' > \"$PHASE_DIR/design-tokens.jsonl\"\n   echo '{\"component\":\"Button\"}' > \"$PHASE_DIR/component-specs.jsonl\"\n   run bash \"$SUT\" --gate ux-complete --phase-dir \"$PHASE_DIR\" --no-poll\n   assert_failure\n\n3. @test \"ux-complete gate fails without design-handoff.jsonl\"\n   touch \"$PHASE_DIR/.handoff-ux-complete\"\n   echo '{\"token\":\"primary\"}' > \"$PHASE_DIR/design-tokens.jsonl\"\n   echo '{\"component\":\"Button\"}' > \"$PHASE_DIR/component-specs.jsonl\"\n   run bash \"$SUT\" --gate ux-complete --phase-dir \"$PHASE_DIR\" --no-poll\n   assert_failure\n\n4. @test \"all-depts gate passes when all complete\"\n   mk_dept_complete backend\n   mk_dept_complete frontend\n   echo '{\"p\":\"02-01\",\"n\":\"test\",\"s\":\"complete\"}' > \"$PHASE_DIR/02-01.summary.jsonl\"\n   run bash \"$SUT\" --gate all-depts --phase-dir \"$PHASE_DIR\" --no-poll\n   assert_success\n\n5. @test \"all-depts gate fails when one dept incomplete\"\n   mk_dept_complete backend\n   echo '{\"dept\":\"frontend\",\"status\":\"running\",\"step\":\"planning\"}' > \"$PHASE_DIR/.dept-status-frontend.json\"\n   echo '{\"p\":\"02-01\",\"n\":\"test\",\"s\":\"complete\"}' > \"$PHASE_DIR/02-01.summary.jsonl\"\n   run bash \"$SUT\" --gate all-depts --phase-dir \"$PHASE_DIR\" --no-poll\n   assert_failure\n\n6. @test \"timeout exits 1 with TIMEOUT message\"\n   run bash \"$SUT\" --gate ux-complete --phase-dir \"$PHASE_DIR\" --timeout 1 --poll-interval 0.3\n   assert_failure\n   assert_output --partial \"TIMEOUT\"\n\n7. @test \"api-contract gate passes with agreed entry\"\n   echo '{\"endpoint\":\"/api/users\",\"status\":\"agreed\"}' > \"$PHASE_DIR/api-contracts.jsonl\"\n   run bash \"$SUT\" --gate api-contract --phase-dir \"$PHASE_DIR\" --no-poll\n   assert_success\n\n8. @test \"api-contract gate fails with only proposed entries\"\n   echo '{\"endpoint\":\"/api/users\",\"status\":\"proposed\"}' > \"$PHASE_DIR/api-contracts.jsonl\"\n   run bash \"$SUT\" --gate api-contract --phase-dir \"$PHASE_DIR\" --no-poll\n   assert_failure\n\n9. @test \"unknown gate name exits with error\"\n   run bash \"$SUT\" --gate nonexistent --phase-dir \"$PHASE_DIR\" --no-poll\n   assert_failure\n   assert_output --partial \"Unknown gate\"\n\n=== FILE 2: tests/unit/dept-cleanup.bats ===\nFRAMEWORK: BATS with bats-support, bats-assert, bats-file\nLOAD: load '../test_helper/common' and load '../test_helper/fixtures'\n\nSETUP:\n  setup() {\n    load '../test_helper/common'\n    load '../test_helper/fixtures'\n    mk_test_workdir\n    SUT=\"$SCRIPTS_DIR/dept-cleanup.sh\"\n    PHASE_DIR=\"$TEST_WORKDIR/.yolo-planning/phases/02-test\"\n    mkdir -p \"$PHASE_DIR\"\n  }\n\nTEST CASES (minimum 4):\n\n1. @test \"removes coordination files\"\n   touch \"$PHASE_DIR/.dept-status-backend.json\"\n   touch \"$PHASE_DIR/.dept-status-frontend.json\"\n   touch \"$PHASE_DIR/.handoff-ux-complete\"\n   touch \"$PHASE_DIR/.dept-lock-backend\"\n   touch \"$PHASE_DIR/.phase-orchestration.json\"\n   run bash \"$SUT\" --phase-dir \"$PHASE_DIR\" --reason complete\n   assert_success\n   assert_file_not_exists \"$PHASE_DIR/.dept-status-backend.json\"\n   assert_file_not_exists \"$PHASE_DIR/.dept-status-frontend.json\"\n   assert_file_not_exists \"$PHASE_DIR/.handoff-ux-complete\"\n   assert_file_not_exists \"$PHASE_DIR/.dept-lock-backend\"\n   assert_file_not_exists \"$PHASE_DIR/.phase-orchestration.json\"\n   assert_output --partial \"removed\"\n\n2. @test \"preserves plan files\"\n   touch \"$PHASE_DIR/.dept-status-backend.json\"\n   echo '{\"p\":\"02-01\"}' > \"$PHASE_DIR/02-01.plan.jsonl\"\n   run bash \"$SUT\" --phase-dir \"$PHASE_DIR\" --reason complete\n   assert_success\n   assert_file_exists \"$PHASE_DIR/02-01.plan.jsonl\"\n\n3. @test \"preserves summary files\"\n   touch \"$PHASE_DIR/.dept-status-backend.json\"\n   echo '{\"p\":\"02-01\"}' > \"$PHASE_DIR/02-01.summary.jsonl\"\n   run bash \"$SUT\" --phase-dir \"$PHASE_DIR\" --reason complete\n   assert_success\n   assert_file_exists \"$PHASE_DIR/02-01.summary.jsonl\"\n\n4. @test \"handles empty dir gracefully\"\n   run bash \"$SUT\" --phase-dir \"$PHASE_DIR\" --reason complete\n   assert_success\n   assert_output --partial \"No coordination files\"\n\n5. @test \"handles nonexistent dir gracefully\"\n   run bash \"$SUT\" --phase-dir \"$TEST_WORKDIR/nonexistent\" --reason failure\n   assert_success\n   assert_output --partial \"WARNING\"\n\n6. @test \"preserves .toon and .md files\"\n   touch \"$PHASE_DIR/.dept-status-backend.json\"\n   echo 'architecture content' > \"$PHASE_DIR/architecture.toon\"\n   echo '# Decisions' > \"$PHASE_DIR/decisions.md\"\n   run bash \"$SUT\" --phase-dir \"$PHASE_DIR\" --reason complete\n   assert_success\n   assert_file_exists \"$PHASE_DIR/architecture.toon\"\n   assert_file_exists \"$PHASE_DIR/decisions.md\"\n\n7. @test \"outputs count of removed files\"\n   touch \"$PHASE_DIR/.dept-status-backend.json\"\n   touch \"$PHASE_DIR/.handoff-ux-complete\"\n   run bash \"$SUT\" --phase-dir \"$PHASE_DIR\" --reason timeout\n   assert_success\n   assert_output --partial \"2 coordination files\""}
{"id":"02-01-04","n":"Write coordination script tests","f":["tests/unit/dept-orchestrate.bats","tests/unit/dept-status.bats","tests/unit/dept-gate.bats","tests/unit/dept-cleanup.bats"],"d":["02-01-01","02-01-02","02-01-03"],"ac":["tests/unit/dept-orchestrate.bats has minimum 6 tests: parallel 3-dept output, parallel no-UX output, sequential output, backend-only output, JSON validity check, missing config graceful handling","tests/unit/dept-status.bats has minimum 6 tests: write creates file, read returns JSON, lock prevents concurrent writes, started_at set once, updated_at updates, missing file read exits 1","tests/unit/dept-gate.bats has minimum 6 tests: ux-complete gate passes with all artifacts, ux-complete fails without sentinel, all-depts passes when all complete, timeout exits 1, api-contract passes with agreed entry, validation failure exits 2","tests/unit/dept-cleanup.bats has minimum 4 tests: removes coordination files, preserves plan files, preserves summary files, handles empty dir gracefully","All tests use BATS test helpers (bats-support, bats-assert, bats-file)","All tests pass with bats"],"spec":"This task creates the 4 BATS test files specified in the ts fields of tasks 02-01-01, 02-01-02, and 02-01-03. The Dev MUST implement the test files exactly as described in those ts fields.\n\nFILES TO CREATE:\n  1. tests/unit/dept-orchestrate.bats -- implement ts from 02-01-01\n  2. tests/unit/dept-status.bats -- implement ts from 02-01-02\n  3. tests/unit/dept-gate.bats -- implement ts from 02-01-03 (FILE 1)\n  4. tests/unit/dept-cleanup.bats -- implement ts from 02-01-03 (FILE 2)\n\nPATTERN: Follow existing test file conventions exactly:\n  - Shebang: #!/usr/bin/env bats\n  - Comment header: script name, description, what it tests\n  - setup() loads common + fixtures, calls mk_test_workdir, sets SUT\n  - Helper functions at top (mk_config, run_* wrapper)\n  - Tests grouped by functionality with comment section headers\n  - Use assert_success, assert_failure, assert_output, assert_file_exists, assert_file_not_exists\n  - For JSON validation: use jq -r on $output or on files directly\n  - All temp files in $TEST_WORKDIR (auto-cleaned by BATS)\n\nREFERENCE FILES for pattern:\n  - tests/unit/resolve-departments.bats (closest analog for dept-orchestrate tests)\n  - tests/unit/validate-dept-spawn.bats (closest analog for flag-based tests)\n  - tests/unit/state-updater.bats (closest analog for file-writing tests)\n\nVERIFICATION:\n  After creating all 4 files, run: bats tests/unit/dept-orchestrate.bats tests/unit/dept-status.bats tests/unit/dept-gate.bats tests/unit/dept-cleanup.bats\n  All tests must pass.\n\nIMPORTANT: The test implementations in this task are the SAME tests described in the ts fields of 02-01-01, 02-01-02, and 02-01-03. The ts fields provide the specification; this task implements them as actual BATS files. Do NOT invent new tests -- implement exactly what the ts fields describe.","ts":"This task IS the test implementation task. No separate test file needed for tests-of-tests. Verification is done by running the BATS files and confirming all pass:\n  bats tests/unit/dept-orchestrate.bats tests/unit/dept-status.bats tests/unit/dept-gate.bats tests/unit/dept-cleanup.bats\nExpected: all tests green, zero failures."}
