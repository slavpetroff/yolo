{"p": "05", "n": "02", "t": "Wire upward escalation path -- blocker to user", "w": 1, "d": [], "mh": {"tr": ["execute-protocol.md has explicit escalation handling section with AskUserQuestion usage", "go.md Owner proxy handles escalation presentation to user", "Lead agent prompt documents escalation receipt and upward routing", "Architect escalation to user uses AskUserQuestion with structured options"], "ar": [{"f": "references/execute-protocol.md", "contains": "Escalation Handling"}, {"f": "commands/go.md", "contains": "Escalation from agents"}, {"f": "agents/yolo-lead.md", "contains": "Escalation Receipt"}], "kl": [{"from": "agents/yolo-dev.md", "to": "agents/yolo-senior.md", "rel": "Dev sends dev_blocker to Senior"}, {"from": "agents/yolo-senior.md", "to": "agents/yolo-lead.md", "rel": "Senior escalates unresolvable to Lead"}, {"from": "agents/yolo-lead.md", "to": "references/execute-protocol.md", "rel": "Lead routes to Architect/Owner per protocol"}, {"from": "references/execute-protocol.md", "to": "commands/go.md", "rel": "Protocol triggers AskUserQuestion via go.md proxy"}]}, "obj": "Wire the upward path so Dev blockers actually reach the user through the chain (REQ-08): Dev->Senior->Lead->Architect/Owner->go.md->AskUserQuestion->User", "sk": ["commit"]}
{"id": "T1", "a": "Add ## Escalation Handling section to references/execute-protocol.md (after ## Change Management section). Document the full upward flow: (1) Dev sends dev_blocker to Senior, (2) Senior attempts resolution -- if cannot, sends escalation to Lead, (3) Lead attempts resolution -- if cannot, in single-dept sends escalation to Architect (via go.md proxy), in multi-dept sends to Owner, (4) Architect/Owner surfaces to user via AskUserQuestion with structured options: the blocker description, evidence, recommendation, and 2-3 concrete options for the user to choose from. Include timeout trigger: if escalation pending longer than config escalation.timeout_seconds, Lead auto-escalates to next level. REQ-08.", "f": ["references/execute-protocol.md"], "v": "grep -q 'Escalation Handling' references/execute-protocol.md", "done": "Escalation Handling section exists with step-by-step upward flow, timeout trigger, AskUserQuestion usage pattern", "tp": "docs", "spec": "File: references/execute-protocol.md\n\nPlacement: Insert a new ## Escalation Handling section AFTER the ## Change Management section (which ends around line 724 before ## Multi-Department Execution at line 726). Insert between Change Management and Multi-Department Execution.\n\n## Escalation Handling\n\nWhen a Dev agent encounters a blocker it cannot resolve, the escalation flows upward through the company hierarchy until resolved. This section documents the exact upward path and timeout behavior.\n\n### Upward Escalation Flow\n\n**Level 1: Dev -> Senior**\nDev sends `dev_blocker` schema to Senior (via SendMessage in teammate mode, via Task result in task mode). Dev includes: blocker description, what was attempted, what is needed. Dev pauses current task (see ## Dev Pause Behavior below).\n\n**Level 2: Senior attempts resolution**\nSenior receives dev_blocker. Senior may: (a) clarify the spec and send updated instructions via `code_review_changes`, or (b) determine the issue is beyond spec-level and escalate to Lead via `escalation` schema.\n\n**Level 3: Lead assesses authority**\nLead receives escalation from Senior. Lead checks Decision Authority Matrix (see company-hierarchy.md). If within Lead's authority (task ordering, resource allocation, plan decomposition): Lead resolves and sends `escalation_resolution` back to Senior. If beyond Lead's authority (architecture, technology, scope): Lead escalates to Architect (single-dept) or Owner (multi-dept) via `escalation` schema.\n\n**Level 4: Architect/Owner -> go.md -> User**\nArchitect receives escalation. Architect packages a structured escalation with an options array containing 2-3 concrete choices for the user. Architect sends this to Lead via SendMessage (teammate mode) or returns via Task result (task mode). Lead forwards to go.md. go.md calls AskUserQuestion presenting:\n- Blocker summary (1-2 sentences)\n- Evidence bullets (from escalation chain)\n- 2-3 concrete resolution options (from Architect's options array)\n- Recommendation (Architect's preferred option, if any)\n\nIn multi-dept mode: Lead sends to Owner instead of Architect. Owner routes through go.md identically.\n\n**[teammate]** Intra-team escalation (Dev->Senior->Lead->Architect) uses SendMessage. Cross-team escalation (Lead->Owner, Architect->go.md) uses file-based artifacts per D3.\n\n**[task]** All escalation uses Task tool result returns or direct communication within the orchestrator session.\n\n### Timeout-Based Auto-Escalation\n\nIf an escalation remains at one level longer than `escalation.timeout_seconds` (default 300s from config/defaults.json):\n1. The orchestrator detects the timeout via `check-escalation-timeout.sh` (periodic call during Step 7)\n2. Auto-escalation fires ONLY if the current level has NOT already escalated upward (prevents duplicates per D4)\n3. The escalation's `level` field is updated to the next level, `last_escalated_at` is refreshed\n4. An `escalation_timeout_warning` schema is generated and sent to the next level\n5. If `escalation.auto_owner_on_timeout` is true and timeout fires at Architect level: auto-involve Owner/go.md to present to user\n\n### Max Round-Trips\n\n`escalation.max_round_trips` (default 2) caps how many times the same blocker (by escalation id) can bounce between levels. After max reached: force resolution at current level or STOP execution with blocker report to user.\n\n### Dev Pause Behavior\n\n**task mode:** Dev is a single-threaded Task session. When blocked, the orchestrator (Lead) simply does not assign the next task until the escalation resolves. The Dev Task session either completes (reporting the blocker in its return value) or remains active.\n\n**teammate mode:** Dev sends dev_blocker to Senior and continues the claim loop. The blocked task is NOT available for re-claiming (its status is claimed, not available). Dev may work on other unblocked tasks while waiting. On receiving resolution instructions from Senior (via code_review_changes), Dev resumes the blocked task.\n\nDo NOT modify existing sections. Only INSERT this new section between Change Management and Multi-Department Execution.", "ts": ""}
{"id": "T2", "a": "Add ## Escalation from Agents subsection to commands/go.md (inside Mode: Execute section, after spawn strategy gate). Document how go.md intercepts escalation that reaches the top of the chain and presents it to the user: (1) Receive escalation context from Architect (single-dept) or Owner (multi-dept), (2) Format AskUserQuestion with blocker summary, evidence bullets, and 2-3 concrete resolution options derived from the escalation recommendation field, (3) Wait for user response, (4) Package response into escalation_resolution schema with decision and action_items, (5) Return resolution to the escalating agent. Include example AskUserQuestion format. REQ-08.", "f": ["commands/go.md"], "v": "grep -q 'Escalation from Agents' commands/go.md", "done": "go.md has explicit protocol for receiving agent escalations and presenting to user via AskUserQuestion", "tp": "docs", "spec": "File: commands/go.md\n\nPlacement: Insert a new subsection INSIDE the ### Mode: Execute section. Place it AFTER item 5 (the MANDATORY SPAWN STRATEGY GATE paragraph ending at approximately line 335) and BEFORE the **Routing** line (approximately line 337). This means between the spawn strategy gate explanation and the routing decision.\n\n6. **Escalation from Agents:**\n\n   When an escalation reaches the top of the chain (Architect in single-dept, Owner in multi-dept), go.md intercepts and presents to the user:\n\n   a. **Receive escalation context:** Architect/Owner returns structured escalation via Task result (task mode) or file-based artifact (teammate mode). The escalation contains: issue description, evidence array, recommendation, options array (2-3 concrete choices), severity.\n\n   b. **Format for user:** Present via AskUserQuestion:\n      ```\n      Agent escalation requires your input:\n\n      Blocker: {issue description}\n      Evidence:\n        - {evidence[0]}\n        - {evidence[1]}\n      Recommendation: {recommendation}\n\n      Options:\n      1. {options[0]} (recommended)\n      2. {options[1]}\n      3. {options[2]}\n      ```\n\n   c. **Wait for response:** AskUserQuestion blocks until user responds. No timeout on user response.\n\n   d. **Package resolution:** Construct `escalation_resolution` schema:\n      ```json\n      {\n        \"type\": \"escalation_resolution\",\n        \"original_escalation\": \"{escalation_id}\",\n        \"decision\": \"{user's choice text}\",\n        \"rationale\": \"{user's explanation if provided, otherwise 'User selected option N'}\",\n        \"action_items\": [\"{derived from the selected option's implications}\"],\n        \"resolved_by\": \"user\"\n      }\n      ```\n\n   e. **Return resolution:** Send escalation_resolution back to the escalating agent (Architect/Owner). In task mode: return as Task result. In teammate mode (cross-team): write as file artifact `.escalation-resolution-{dept}.json` in phase dir (go.md acts as Owner proxy per D1).\n\n   f. **Update escalation state:** Update .execution-state.json escalation entry: set status to \"resolved\", resolved_at to current timestamp, resolution to decision text. Commit immediately: `chore(state): escalation resolved phase {N}`.\n\nNOTE: Renumber the existing **Routing** heading to account for this new item 6. The Routing section becomes the next logical continuation after step 6.\n\nDo NOT modify existing content. Only INSERT this new subsection.", "ts": ""}
{"id": "T3", "a": "Add ## Escalation Receipt and Routing section to agents/yolo-lead.md (after ## Escalation Table). Document how Lead receives escalations from Senior and routes them: (1) Assess if Lead can resolve (within decision authority), (2) If yes, resolve and send escalation_resolution back down, (3) If no, package as escalation with Lead's own assessment added, escalate to Architect (single-dept) or Owner (multi-dept), (4) Track escalation state: pending escalations with timestamps for timeout checking, (5) On receiving escalation_resolution from above, forward to the originating Senior. REQ-08, REQ-09.", "f": ["agents/yolo-lead.md"], "v": "grep -q 'Escalation Receipt' agents/yolo-lead.md", "done": "Lead agent prompt has Escalation Receipt section documenting receive, assess, route-or-resolve, and timeout tracking", "tp": "docs", "spec": "File: agents/yolo-lead.md\n\nPlacement: Insert a new ## Escalation Receipt and Routing section AFTER the existing ## Escalation Table section (which ends around line 28 with the NEVER escalate note). Insert BEFORE ## Output Format (approximately line 30).\n\nContent to add:\n\n## Escalation Receipt and Routing\n\nWhen Senior sends an `escalation` schema to Lead, Lead acts as the routing hub for the upward path.\n\n### Receive and Assess\n\n1. **Receive:** Senior sends `escalation` with issue, evidence, recommendation, severity.\n2. **Assess authority:** Check Decision Authority Matrix (references/company-hierarchy.md). Lead CAN decide: task ordering, resource allocation, plan decomposition, remediation assignment. Lead CANNOT decide: architecture, technology choices, scope changes, user-facing decisions.\n3. **Resolve (if within authority):** Construct `escalation_resolution` schema with decision, rationale, and action_items. Send back to originating Senior via SendMessage (teammate) or Task result (task).\n4. **Escalate (if beyond authority):** Add Lead's assessment to the escalation (what was tried, why it is beyond Lead authority). Forward to Architect (single-dept) or Owner (multi-dept) via `escalation` schema.\n\n### Escalation State Tracking\n\nWhen an escalation is received, Lead updates `.execution-state.json` immediately (per D8 crash recovery):\n- Add entry to `escalations` array: `{id, task, plan, severity, status:\"pending\", level:\"lead\", escalated_at, last_escalated_at, round_trips:0, resolution:\"\"}`\n- Commit: `chore(state): escalation received phase {N}`\n- Track `last_escalated_at` timestamp for timeout checking\n\n### Timeout Monitoring\n\nDuring Step 7 (Implementation), periodically call `check-escalation-timeout.sh` to detect stale escalations. If a pending escalation at Lead level exceeds `escalation.timeout_seconds`: auto-escalate to Architect/Owner (only if Lead has NOT already escalated -- prevents duplicates per D4).\n\n### Resolution Forwarding\n\nWhen Lead receives `escalation_resolution` from Architect/Owner:\n1. Update escalation entry in .execution-state.json: status=\"resolved\", resolved_at, resolution text\n2. Forward escalation_resolution to the originating Senior via SendMessage (teammate) or Task result (task)\n3. Commit state update: `chore(state): escalation resolved phase {N}`\n\n**[teammate]** Intra-team (Senior->Lead, Lead->Architect): SendMessage. Cross-team (Lead->Owner): file-based artifact `.escalation-resolution-{dept}.json`.\n\n**[task]** All communication via Task tool result returns within the orchestrator session.\n\nDo NOT modify existing sections (Escalation Table, Output Format, etc.). Only INSERT this new section.", "ts": ""}
{"id": "T4", "a": "Update agents/yolo-architect.md Escalation Table to add explicit AskUserQuestion protocol. Currently the table says 'AskUserQuestion (via Lead orchestration)' but does not specify how. Add: when Architect receives an escalation it cannot resolve, Architect packages it as a structured escalation with options array (2-3 concrete choices) and sends to go.md which presents via AskUserQuestion. Architect waits for escalation_resolution response. On receiving resolution, Architect may update architecture.toon if the decision affects design, then forwards resolution to Lead. REQ-08.", "f": ["agents/yolo-architect.md"], "v": "grep -q 'options array' agents/yolo-architect.md || grep -q 'structured escalation' agents/yolo-architect.md", "done": "Architect escalation table has explicit AskUserQuestion protocol with options format and resolution handling", "tp": "docs", "spec": "File: agents/yolo-architect.md\n\nThis task modifies the existing ## Escalation Table section (approximately lines 66-71). Do NOT replace the table -- ADD a new subsection below it.\n\nPlacement: Insert AFTER the existing Escalation Table section (after the last table row, line ~71, before ## Constraints & Effort at approximately line 73).\n\nContent to add:\n\n### Structured Escalation Protocol (AskUserQuestion via Lead/go.md)\n\nWhen Architect receives an escalation from Lead that requires user input:\n\n1. **Package structured escalation:** Construct a message with:\n   - `issue`: Clear 1-2 sentence description of the design decision needed\n   - `evidence`: Array of relevant facts from the architecture analysis\n   - `recommendation`: Architect's preferred option with rationale\n   - `options`: Array of 2-3 concrete choices, each with a brief description of implications\n   - `severity`: blocking | major\n\n   Example structure:\n   ```json\n   {\n     \"type\": \"escalation\",\n     \"from\": \"architect\",\n     \"to\": \"lead\",\n     \"issue\": \"Library A vs Library B for authentication -- both viable but different tradeoffs\",\n     \"evidence\": [\"Library A: better docs, larger community\", \"Library B: 3x faster, smaller bundle\"],\n     \"recommendation\": \"Library A (maintenance wins over raw performance)\",\n     \"options\": [\n       \"Use Library A (recommended: better long-term maintenance)\",\n       \"Use Library B (faster but higher maintenance risk)\",\n       \"Defer decision pending performance benchmarks\"\n     ],\n     \"severity\": \"blocking\"\n   }\n   ```\n\n2. **Send to Lead:** Via SendMessage (teammate mode) or Task result (task mode). Architect does NOT call AskUserQuestion directly (not in tool list per D2).\n\n3. **Receive resolution:** Lead forwards `escalation_resolution` from go.md/User. Architect reads `decision` and `action_items` fields.\n\n4. **Act on resolution:**\n   - If decision affects architecture: update architecture.toon with new/modified decision entry. Commit: `docs({phase}): architecture update per escalation resolution`\n   - Forward resolution to Lead for downstream routing (Lead -> Senior -> Dev)\n   - Log decision in decisions.jsonl\n\nDo NOT modify the existing Escalation Table rows. Only ADD this subsection after the table.", "ts": ""}
