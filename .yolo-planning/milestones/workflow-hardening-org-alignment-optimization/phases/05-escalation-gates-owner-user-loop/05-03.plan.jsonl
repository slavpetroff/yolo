{"p": "05", "n": "03", "t": "Wire downward resolution path -- user feedback to Dev", "w": 2, "d": ["01", "02"], "mh": {"tr": ["Senior agent prompt documents receiving escalation_resolution and translating to Dev instructions", "Dev agent prompt documents receiving resolution-driven spec updates", "Owner agent prompt documents receiving user feedback and routing to Leads", "company-hierarchy.md documents full round-trip including downward path"], "ar": [{"f": "agents/yolo-senior.md", "contains": "Resolution Routing"}, {"f": "agents/yolo-dev.md", "contains": "Escalation Resolution"}, {"f": "agents/yolo-owner.md", "contains": "Resolution Routing"}, {"f": "references/company-hierarchy.md", "contains": "Escalation Round-Trip"}], "kl": [{"from": "commands/go.md", "to": "agents/yolo-owner.md", "rel": "go.md passes user decision to Owner for routing"}, {"from": "agents/yolo-owner.md", "to": "agents/yolo-lead.md", "rel": "Owner routes resolution to department Lead"}, {"from": "agents/yolo-lead.md", "to": "agents/yolo-senior.md", "rel": "Lead forwards resolution to Senior who originated escalation"}, {"from": "agents/yolo-senior.md", "to": "agents/yolo-dev.md", "rel": "Senior translates resolution into updated spec or instructions for Dev"}]}, "obj": "Wire the downward path so user decisions flow back to unblock Dev (REQ-09): User->go.md->Owner/Architect->Lead->Senior->Dev with verification at each level", "sk": ["commit"]}
{"id": "T1", "a": "Add ## Resolution Routing section to agents/yolo-owner.md (after Mode 2: Conflict Resolution). Document: (1) Owner receives user feedback via go.md (as escalation_resolution from go.md proxy), (2) Owner identifies which department Lead originated the escalation, (3) Owner adds strategic context to resolution if needed (e.g., priority implications), (4) Owner forwards escalation_resolution to the correct Lead via file-based artifact (write .escalation-resolution-{dept}.json), (5) Owner logs the resolution in decisions.jsonl. Note: Owner is read-only so resolution routing uses the existing owner_review communication pattern (file artifacts that Leads read). REQ-09.", "f": ["agents/yolo-owner.md"], "v": "grep -q 'Resolution Routing' agents/yolo-owner.md", "done": "Owner agent prompt has Resolution Routing section with receive-assess-forward protocol", "tp": "docs", "spec": "File: agents/yolo-owner.md\n\nPlacement: Insert a new ### Mode 4: Resolution Routing section AFTER ### Mode 2: Cross-Department Conflict Resolution (which ends around line 52) and BEFORE ### Mode 3: Final Sign-off (approximately line 54). Renumber existing Mode 3 to Mode 5.\n\nWAIT -- actually, to avoid renumbering (which could break references), insert as a new section AFTER ### Mode 3: Final Sign-off (ending around line 63) and BEFORE ### Effort-Based Behavior (approximately line 65). This avoids renumbering.\n\nContent to add:\n\n### Mode 4: Escalation Resolution Routing (spawned on escalation resolution)\n\nInput: `escalation_resolution` from go.md (user decision packaged by go.md acting as Owner proxy).\n\nIMPORTANT: Owner is read-only (no Write/Edit/Bash tools per C1 and D1). Owner does NOT write file artifacts directly. Instead, Owner returns resolution content via SendMessage (teammate mode) or Task result (task mode). go.md/Lead writes the file artifact `.escalation-resolution-{dept}.json` on Owner's behalf.\n\n1. **Receive resolution:** go.md passes `escalation_resolution` to Owner. Contains: original_escalation id, decision, rationale, action_items, resolved_by.\n2. **Identify target department:** Read `original_escalation` id (format: ESC-{phase}-{plan}-T{N}) to determine which department Lead originated the escalation. Cross-reference with active department config.\n3. **Add strategic context:** If the decision has cross-department implications (e.g., priority changes affecting other departments), Owner adds strategic notes to the resolution. Owner may modify action_items to include cross-department coordination instructions.\n4. **Return resolution:** Owner returns the enriched escalation_resolution via SendMessage to go.md/Lead (teammate mode) or as Task result (task mode). go.md/Lead writes `.escalation-resolution-{dept}.json` to the phase directory on Owner's behalf.\n5. **Log decision:** Owner includes the resolution in its output for the orchestrator to append to decisions.jsonl: `{\"ts\":\"...\",\"agent\":\"owner\",\"task\":\"escalation\",\"dec\":\"...\",\"reason\":\"...\",\"alts\":[]}`\n\n**[teammate]** Owner is NOT in any department team (API constraint per D3). All communication is file-based regardless of team_mode. go.md writes the file artifact.\n\n**[task]** Owner returns resolution as Task result. go.md writes the file artifact.\n\nDo NOT modify existing modes (Mode 1, 2, 3). Only INSERT this new mode section.", "ts": ""}
{"id": "T2", "a": "Add ## Resolution Routing section to agents/yolo-senior.md (after ## Escalation Table). Document: (1) Senior receives escalation_resolution from Lead, (2) Senior maps the decision to concrete Dev instructions: if resolution changes spec, Senior re-enriches affected task spec field; if resolution is 'proceed as-is', Senior confirms Dev can continue; if resolution is 'change approach', Senior writes new code_review_changes with exact fix instructions, (3) Senior sends instructions to Dev via code_review_changes schema (reuse existing pattern), (4) Senior verifies Dev acknowledges and resumes. Include verification gate: Senior confirms Dev has unblocked before marking escalation resolved. REQ-09.", "f": ["agents/yolo-senior.md"], "v": "grep -q 'Resolution Routing' agents/yolo-senior.md", "done": "Senior agent prompt has Resolution Routing section with resolution-to-Dev-instruction translation", "tp": "docs", "spec": "File: agents/yolo-senior.md\n\nPlacement: Insert a new ## Resolution Routing section AFTER the ## Escalation Table section (which ends around line 79 with the NEVER escalate note). Insert BEFORE ## Decision Logging (approximately line 82).\n\nContent to add:\n\n## Resolution Routing\n\nWhen Senior receives an `escalation_resolution` from Lead (forwarded from Architect/Owner/User), Senior translates the resolution into concrete Dev instructions.\n\n### Translation Protocol\n\n1. **Receive resolution:** Lead forwards `escalation_resolution` to Senior via SendMessage (teammate) or Task result (task). Contains: decision, rationale, action_items.\n\n2. **Map decision to Dev instructions:** Based on the resolution:\n   - **Spec change needed:** Re-read the affected task in plan.jsonl. Update the `spec` field with new instructions reflecting the resolution. Write updated plan.jsonl. Commit: `docs({phase}): update spec per escalation resolution`\n   - **Proceed as-is:** Send `code_review_changes` to Dev with `changes: []` and a note confirming Dev can continue with original approach. No spec change needed.\n   - **Change approach:** Construct `code_review_changes` schema with exact fix instructions derived from `action_items`. Each action_item maps to a specific file change with line references and fix descriptions.\n\n3. **Send to Dev:** Use `code_review_changes` schema (reuse existing pattern from ## Mode 2: Code Review). In teammate mode: SendMessage directly to Dev. In task mode: return via Task result.\n\n4. **Verify unblocked:** After Dev receives instructions and resumes work:\n   - Teammate mode: Wait for `dev_progress` from Dev confirming task resumed\n   - Task mode: Monitor Dev Task completion\n   - Once Dev resumes: notify Lead that escalation is resolved\n\n### Verification Gate\n\nSenior MUST confirm Dev has unblocked before marking the escalation resolved. Do not mark resolved on sending instructions -- mark resolved only after Dev acknowledges receipt and resumes the task. If Dev reports a NEW blocker after receiving resolution, this starts a new escalation cycle (increment round_trips).\n\nDo NOT modify existing sections. Only INSERT this new section.", "ts": ""}
{"id": "T3", "a": "Add ## Escalation Resolution section to agents/yolo-dev.md (after ## Escalation Table). Document: (1) When Dev has an outstanding escalation (sent dev_blocker and waiting), Dev pauses current task and may work on other unblocked tasks if in teammate mode, (2) On receiving updated instructions from Senior (via code_review_changes or updated spec), Dev reads new instructions, (3) Dev resumes the blocked task with the resolution applied, (4) Dev commits with message referencing the escalation: fix({phase}-{plan}): resolve blocker {description}. REQ-09.", "f": ["agents/yolo-dev.md"], "v": "grep -q 'Escalation Resolution' agents/yolo-dev.md", "done": "Dev agent prompt has Escalation Resolution section documenting pause-receive-resume protocol", "tp": "docs", "spec": "File: agents/yolo-dev.md\n\nPlacement: Insert a new ## Escalation Resolution section AFTER the ## Escalation Table section (which ends around line 76 with the NEVER escalate note). Insert BEFORE ## Change Management (approximately line 78).\n\nContent to add:\n\n## Escalation Resolution\n\nWhen Dev has sent a `dev_blocker` to Senior and is waiting for resolution:\n\n### Pause Behavior\n\n**task mode:** Dev Task session is either still active (awaiting Senior response) or has completed with the blocker reported in the return value. The orchestrator (Lead) does not assign the next task until the escalation resolves. Dev does NOT need to explicitly pause -- the single-threaded Task session handles this naturally.\n\n**teammate mode:** After sending `dev_blocker`, Dev continues the claim loop (## Task Self-Claiming). The blocked task remains claimed (status: claimed, not available for others). Dev MAY work on other unblocked tasks while waiting. Dev does NOT need to explicitly track the blocked task -- Senior will send resolution instructions when ready.\n\n### Receive Resolution\n\nSenior sends resolution as `code_review_changes` schema (same format as code review fix instructions):\n- Read `changes` array for specific file modifications\n- If `changes` is empty with a note: original approach confirmed, resume as-is\n- If `changes` has entries: apply each fix per Senior's exact instructions (same protocol as ## Change Management)\n\nAlternatively, Senior may update the task `spec` field in plan.jsonl. In this case, Dev re-reads plan.jsonl for the updated spec before resuming.\n\n### Resume Protocol\n\n1. Read updated instructions from Senior (code_review_changes or updated spec)\n2. Resume the blocked task from where it was paused\n3. Apply resolution changes to the implementation\n4. Commit with escalation reference: `fix({phase}-{plan}): resolve blocker {description}`\n5. Send `dev_progress` to Senior confirming task resumed and resolution applied\n6. Continue normal execution flow (next task in plan or claim loop)\n\nDo NOT modify existing sections. Only INSERT this new section.", "ts": ""}
{"id": "T4", "a": "Update references/company-hierarchy.md ## Escalation Chain section to add a new ## Escalation Round-Trip subsection. Document the full bidirectional flow: UPWARD (Dev->Senior->Lead->Architect/Owner->User) and DOWNWARD (User->go.md->Owner/Architect->Lead->Senior->Dev). At each level, document what transformation happens: Senior adds context, Lead assesses authority, Architect evaluates design impact, Owner checks cross-dept implications. At each downward level: Owner adds strategic context, Lead routes to correct Senior, Senior translates to Dev instructions. Add verification: each level confirms the resolution was received and acted on before marking complete. REQ-08, REQ-09.", "f": ["references/company-hierarchy.md"], "v": "grep -q 'Escalation Round-Trip' references/company-hierarchy.md", "done": "company-hierarchy.md has Escalation Round-Trip section documenting full bidirectional flow with per-level transformations", "tp": "docs", "spec": "File: references/company-hierarchy.md\n\nPlacement: Insert a new ## Escalation Round-Trip subsection AFTER the existing ### QA Remediation Chain section (which ends around line 104) and BEFORE ### Code Review Chain (approximately line 106). Actually, to keep the escalation content together, insert it AFTER ### Rules (ending around line 97, before ### QA Remediation Chain at line 98). This groups all escalation content.\n\nWAIT -- better placement: insert AFTER ### Code Review Chain (ending around line 122 after the Phase 4 hooks mention) and BEFORE ## Decision Authority Matrix (approximately line 126). This keeps it at the end of the escalation section but before the authority matrix.\n\nContent to add:\n\n### Escalation Round-Trip (Full Bidirectional Flow)\n\nComplete path for a Dev blocker that requires user input and the resolution flowing back down.\n\n**UPWARD PATH (Blocker to User):**\n\n```\nDev          -> Senior       -> Lead         -> Architect/Owner -> go.md -> User\n(dev_blocker)  (escalation)   (escalation)    (structured opts)   (AskUserQuestion)\n```\n\n| Level | Agent | Transformation | Output |\n|-------|-------|---------------|--------|\n| 1 | Dev | Reports blocker with evidence of what was tried | `dev_blocker` schema |\n| 2 | Senior | Adds spec context, attempts resolution. If cannot: adds assessment | `escalation` schema to Lead |\n| 3 | Lead | Checks decision authority. If beyond scope: adds Lead assessment | `escalation` schema to Architect/Owner |\n| 4 | Architect | Evaluates design impact, constructs 2-3 concrete options | Structured escalation with options array |\n| 4a | Owner (multi-dept) | Checks cross-department implications, routes to go.md | Escalation context to go.md |\n| 5 | go.md | Formats for user, presents via AskUserQuestion | User sees blocker + options |\n\n**DOWNWARD PATH (Resolution to Dev):**\n\n```\nUser -> go.md -> Owner/Architect -> Lead         -> Senior       -> Dev\n(choice) (escalation_resolution)   (forward)       (translate)     (resume)\n```\n\n| Level | Agent | Transformation | Output |\n|-------|-------|---------------|--------|\n| 1 | go.md | Packages user choice as escalation_resolution | `escalation_resolution` schema |\n| 2 | Owner (multi-dept) | Adds strategic context, identifies target dept Lead | Enriched resolution |\n| 2a | Architect (single-dept) | Updates architecture.toon if decision affects design | Resolution + architecture update |\n| 3 | Lead | Routes to originating Senior, updates .execution-state.json | Forward resolution to Senior |\n| 4 | Senior | Translates resolution to Dev instructions: spec update or code_review_changes | `code_review_changes` schema |\n| 5 | Dev | Applies resolution, resumes blocked task | Commit with escalation reference |\n\n**Verification at each level:** Each agent confirms the resolution was received and acted on by the next level down before marking its part complete. Senior waits for Dev's dev_progress. Lead waits for Senior's confirmation. The escalation entry in .execution-state.json is only marked \"resolved\" after Dev resumes.\n\n**Timeout protection:** If any level does not respond within `escalation.timeout_seconds`, auto-escalation fires to the next level up. Max `escalation.max_round_trips` cycles per escalation id.\n\nDo NOT modify existing sections. Only INSERT this new subsection.", "ts": ""}
{"id": "T5", "a": "Update references/execute-protocol.md Step 7 (Implementation) to add escalation-aware behavior: (1) After Dev sends dev_blocker via Senior, the orchestrator tracks the escalation in .execution-state.json under a new escalations array with fields: id, task, severity, status (pending|resolved), escalated_at, resolved_at, (2) If escalation.timeout_seconds elapsed and status still pending, auto-escalate to next level per the Escalation Handling section added in Plan 05-02, (3) When escalation_resolution received, update status to resolved and record resolved_at, (4) Add verification gate: before marking implementation step complete, verify no escalations have status=pending (all must be resolved or timed-out-and-escalated). REQ-08, REQ-09.", "f": ["references/execute-protocol.md"], "v": "grep -q 'escalations' references/execute-protocol.md", "done": "execute-protocol.md Step 7 tracks escalations in execution state with timeout-based auto-escalation and completion verification gate", "tp": "docs", "spec": "File: references/execute-protocol.md\n\nThis task adds escalation-aware content to the EXISTING Step 7 section. Do NOT create a new section -- modify Step 7 inline.\n\nPlacement 1: Insert new content AFTER the **Dev escalation chain** paragraph (around line 420-421: \"Dev escalation chain: Dev -> Senior (not Lead). If Dev sends dev_blocker, route to Senior.\") and BEFORE the **Summary verification gate** heading (approximately line 422).\n\nContent to add at Placement 1:\n\n**Escalation State Tracking (mid-step, per D8):**\n\nWhen a Dev sends `dev_blocker` (received by Senior, potentially escalated to Lead), the orchestrator tracks the escalation immediately in `.execution-state.json`:\n\n```json\n{\n  \"escalations\": [\n    {\n      \"id\": \"ESC-05-01-T3\",\n      \"task\": \"05-01/T3\",\n      \"plan\": \"05-01\",\n      \"severity\": \"blocking\",\n      \"status\": \"pending\",\n      \"level\": \"senior\",\n      \"escalated_at\": \"2026-02-18T10:00:00Z\",\n      \"last_escalated_at\": \"2026-02-18T10:00:00Z\",\n      \"resolved_at\": \"\",\n      \"round_trips\": 0,\n      \"resolution\": \"\"\n    }\n  ]\n}\n```\n\nCommit immediately on receipt: `chore(state): escalation received phase {N}` (extends Commit-Every-Artifact pattern #4 to escalation state).\n\n**Periodic timeout check:** During Step 7, the orchestrator periodically calls:\n```bash\nresult=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/check-escalation-timeout.sh \\\n  --phase-dir \"{phase-dir}\" --config config/defaults.json)\ntimed_out=$(echo \"$result\" | jq -r '.timed_out | length')\n```\nIf `timed_out > 0`: auto-escalate each timed-out entry to the next level per ## Escalation Handling. Update the entry's `level` and `last_escalated_at` fields. Send `escalation_timeout_warning` schema.\n\n**Resolution handling:** When `escalation_resolution` is received (forwarded down the chain):\n1. Update escalation entry: `status: \"resolved\"`, `resolved_at: \"{ISO8601}\"`, `resolution: \"{decision text}\"`\n2. Commit: `chore(state): escalation resolved phase {N}`\n\nPlacement 2: Modify the existing **EXIT GATE** for Step 7 (approximately line 448). ADD one additional check to the exit gate paragraph. After the existing summary.jsonl verification, add:\n\nAlso verify: no escalations in .execution-state.json have `status: \"pending\"`. All must be `\"resolved\"` or escalated beyond the current step. Check via: `jq '[.escalations[] | select(.status == \"pending\")] | length' .yolo-planning/.execution-state.json` must equal 0. If pending escalations remain: STOP \"Step 7 cannot complete -- {N} pending escalation(s). Resolve or escalate before proceeding.\"\n\nDo NOT modify any other Step 7 content. Only INSERT at the two specified placements.", "ts": ""}
