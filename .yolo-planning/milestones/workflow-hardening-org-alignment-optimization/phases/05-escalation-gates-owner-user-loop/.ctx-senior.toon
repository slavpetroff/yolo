phase: 05
goal: Fix the broken escalation path so Dev blockers reach the user through Owner, and user feedback flows back down to unblock Dev â€” complete the round-trip

architecture:
  phase: 05
  title: Escalation Gates & Owner-User Loop Architecture
  goal: Fix the broken escalation path so Dev blockers reach the user through Owner, and user feedback flows back down to unblock Dev -- complete the round-trip (REQ-08, REQ-09)
  
  tech_decisions:
  
    D1: Owner communicates via SendMessage return value, not file writes -- go.md/Lead writes on behalf
      rationale: Owner has disallowedTools: Edit, Write, Bash. Plan 05-03 T1 instructs Owner to write .escalation-resolution-{dept}.json but Owner cannot write files (C1). Research R1 confirms Owner uses SendMessage pattern. Resolution: Owner sends escalation_resolution content via SendMessage (teammate mode) or Task tool return (task mode). Lead/go.md receives the resolution content and writes the file artifact on Owner's behalf. This mirrors the existing owner_review pattern where go.md acts as Owner proxy. Decisions.jsonl entry 4 from Lead already captures this intent but incorrectly says "file-based communication" -- the file is written by the PROXY, not by Owner. Plan 05-03 T1 must be updated: Owner's protocol says "return resolution via SendMessage/Task result" and go.md writes .escalation-resolution-{dept}.json. References: C1, R1.
      alternatives: Add Write tool to Owner (rejected: breaks read-only design principle); Owner returns via Task result only (rejected: inconsistent with teammate mode where Owner is not in any team)
  
    D2: Architect escalation uses structured SendMessage to Lead, not AskUserQuestion directly
      rationale: Architect's tool list does not include AskUserQuestion (C2). Research R2 confirms Architect has SendMessage. Current escalation table says "AskUserQuestion (via Lead orchestration)" which is directionally correct but mechanism is unclear. Resolution: Architect packages a structured escalation message with an options array (2-3 concrete choices for the user). Sends via SendMessage to Lead (teammate mode) or returns via Task result (task mode). Lead forwards to go.md. go.md calls AskUserQuestion presenting the options. go.md receives user response, packages it as escalation_resolution, returns to Lead. Lead forwards to Architect via SendMessage. Architect may update architecture.toon if decision affects design, then forwards resolution downward. This is a documentation-only change -- no new tools needed. References: C2, R2.
      alternatives: Add AskUserQuestion to Architect (rejected: Architect should not talk to user directly per company hierarchy); Architect writes escalation file for go.md to read (rejected: unnecessary indirection when SendMessage exists)
  
    D3: Teammate mode escalation uses SendMessage intra-team, file-based for cross-team/Owner
      rationale: C3 identifies no teammate mode handling in escalation design. Research R3 confirms Owner is NOT in any department team by design (spans all depts, API constraint: one team membership per agent). Resolution: Intra-team escalation (Dev->Senior->Lead) uses SendMessage unchanged. Lead-to-Architect uses SendMessage (both are in the department team). Architect-to-Owner or Lead-to-Owner crosses team boundaries -- uses file-based artifacts (.escalation-resolution-{dept}.json, read by Lead at gate boundaries). Owner-to-Lead also file-based (existing pattern). Plans 05-02 and 05-03 must add [teammate] blocks documenting these paths. No new mechanism needed -- this is the existing cross-team protocol applied to escalation. References: C3, R3.
      alternatives: Create a dedicated escalation team (rejected: over-engineering, adds API complexity); Add Owner to all teams (rejected: API constraint prevents multi-team membership)
  
    D4: Escalation deduplication via level tracking and last_escalated_at field
      rationale: C4 identifies timeout auto-escalation creating duplicate escalations. If Lead is working on resolution when timeout fires, both Lead and Architect could try resolving the same blocker. Resolution: Each escalation entry in .execution-state.json gains: id (unique per escalation), level (current: senior|lead|architect|owner), last_escalated_at (timestamp of last level transition), round_trips (count, max from config). Auto-escalation timeout only fires if: (a) current level has NOT already escalated upward, AND (b) elapsed since last_escalated_at exceeds timeout. max_round_trips is per-escalation-id (not per-phase). check-escalation-timeout.sh reads these fields for its determination. This prevents: Lead working on resolution being interrupted by premature auto-escalation to Architect. References: C4, R4.
      alternatives: No dedup (rely on agent coordination -- rejected: race conditions in parallel execution); Global lock per escalation (rejected: over-engineering for document-based system)
  
    D5: Remove Plan 05-01 T4 -- validate-send-message.sh does not do schema type validation
      rationale: C5 identifies that validate-send-message.sh only checks department boundaries, not schema types. Research R5 confirms the script checks cross-department boundaries via get_dept() function -- it produces warnings only (PostToolUse cannot block). Adding schema type recognition would be new functionality beyond the plan's scope. The existing schemas (escalation, escalation_resolution, escalation_timeout_warning) follow the same routing rules as all other schemas. The department boundary check already handles them correctly (upward chain allowed, cross-dept through Leads only). Resolution: Remove T4 from Plan 05-01. The three remaining tasks (T1: escalation_resolution schema, T2: escalation_timeout_warning schema, T3: config) are independently complete. Schema type validation belongs in agent prompts (already handled by type discriminator pattern), not PostToolUse hooks. References: C5, R5.
      alternatives: Redefine T4 to add schema-type logging (rejected: scope creep, no actionable value from PostToolUse position)
  
    D6: Dev pause mechanism -- task mode uses orchestrator tracking, teammate mode uses escalation_pending status
      rationale: C6 identifies Dev pause mechanism is undefined for both modes. Resolution: In task mode, Dev is a single-threaded Task session -- when blocked, the orchestrator (Lead) simply does not assign the next task until escalation resolves. Dev's Task session either completes (with blocker reported in return value) or remains active waiting for Senior's response. In teammate mode, Dev sends dev_blocker to Senior and enters a wait state. The Dev claim loop (yolo-dev.md ## Task Self-Claiming) naturally handles this: Dev does not claim new tasks while waiting for blocker resolution. Dev CAN work on other unblocked tasks if available (claim loop step 1 filters to available tasks). On receiving code_review_changes from Senior with resolution instructions, Dev resumes the blocked task. The escalation tracking in .execution-state.json records which task is blocked so crash recovery can re-establish the blocked state. References: C6.
      alternatives: Add explicit escalation_pending task status (rejected: unnecessary when claim loop already filters available tasks); Block Dev entirely during escalation (rejected: wastes capacity when other tasks available)
  
    D7: Wave 1 parallel execution is safe for Plans 05-01 and 05-02
      rationale: C7 identifies that 05-02 T1 references escalation_resolution schema defined by 05-01. Both are Wave 1 with d:[]. Research R6 confirms both plans modify different files and are safe as Wave 1 parallel. 05-01 modifies: references/handoff-schemas.md, config/defaults.json, (scripts/validate-send-message.sh removed per D5). 05-02 modifies: references/execute-protocol.md, commands/go.md, agents/yolo-lead.md, agents/yolo-architect.md. Zero file overlap. Forward references work for docs tasks -- 05-02 documents the escalation_resolution schema usage pattern while 05-01 defines the schema. Lead can validate both after Wave 1 completes. No dependency change needed. References: C7, R6.
      alternatives: Add 05-01 as dependency of 05-02 (rejected: unnecessary serialization, both are docs tasks with no file overlap)
  
    D8: Crash recovery for mid-step escalation state -- commit escalation state immediately
      rationale: C8 identifies that escalation state changes happen mid-Step-7 but .execution-state.json is committed at step transitions. A session crash would lose in-flight escalation state. Resolution: When an escalation is received (Dev sends dev_blocker), the orchestrator immediately commits .execution-state.json with the new escalation entry (not waiting for step transition). On resume, check-escalation-timeout.sh reads pending escalations. Any pending escalation with age > timeout is auto-escalated to the next level. This extends the existing Commit-Every-Artifact pattern (Pattern #4 in PATTERNS.md) to escalation state. The commit message: chore(state): escalation received phase {N}. References: C8.
      alternatives: Persist escalation state in a separate file (rejected: fragments state management, .execution-state.json is the canonical state file); Accept data loss on crash (rejected: escalation is critical path, loss could permanently block a phase)
  
  risks:
  
    - Timeout false positives: A 300s (5min) default timeout may be too aggressive for complex design decisions that require Architect analysis, or too lenient for simple spec clarifications. Mitigation: timeout configurable via escalation.timeout_seconds in config/defaults.json. Per-level tracking prevents premature escalation (D4). Auto-escalation only fires when current level has NOT already escalated upward.
  
    - Duplicate escalation race condition: In teammate mode with parallel Devs, multiple Devs could escalate similar blockers simultaneously. Mitigation: Each escalation has a unique id in .execution-state.json. Senior/Lead can identify related escalations by task/plan references and consolidate before escalating further. Level tracking (D4) prevents the same escalation from being escalated twice at the same level.
  
    - Crash recovery complexity: Mid-step escalation commits add state transitions outside the normal step boundary pattern. Mitigation: The commit is identical in format to step-transition commits (same .execution-state.json file, same jq update pattern). On resume, the escalation array is just another field to check, consistent with existing plan status reconciliation in Step 4.
  
    - Owner proxy pattern complexity: Owner returning resolution via SendMessage/Task result, then go.md/Lead writing the file artifact, adds an indirection layer. Mitigation: This mirrors the existing Critic pattern (Critic has no Write tool, returns findings to Lead who writes critique.jsonl). Well-established pattern in the codebase. Document explicitly in Owner agent prompt.
  
    - Unbounded escalation array: Over many phases with many blockers, the escalations array in .execution-state.json could grow. Mitigation: max_round_trips (default 2) caps per-escalation depth. Resolved escalations are marked resolved (not removed) for audit trail. Array is per-phase (not global), reset each phase. Post-phase cleanup can archive resolved escalations.
  
    - Short timeout for complex decisions: Some user decisions (e.g., "should we use library A or B?") require research time beyond 5 minutes. Mitigation: The timeout triggers auto-escalation to the next level, not auto-resolution. Each level adds context and narrows the question. By the time it reaches the user, it should be a concrete choice with options. User response has no timeout (AskUserQuestion blocks until answered).
  
  components:
  
    escalation-schemas:
      purpose: Define escalation_resolution and escalation_timeout_warning schemas in handoff-schemas.md. Add escalation config section to defaults.json with timeout_seconds, auto_owner_on_timeout, max_round_trips.
      files: references/handoff-schemas.md, config/defaults.json
      plan: 05-01 (T1, T2, T3)
      note: T4 removed per D5
  
    upward-escalation-protocol:
      purpose: Wire Dev->Senior->Lead->Architect/Owner->go.md->AskUserQuestion->User path. Add Escalation Handling section to execute-protocol.md. Add Escalation from Agents to go.md. Update Lead and Architect agent prompts with explicit escalation receipt/routing sections.
      files: references/execute-protocol.md, commands/go.md, agents/yolo-lead.md, agents/yolo-architect.md
      plan: 05-02 (T1, T2, T3, T4)
  
    downward-resolution-protocol:
      purpose: Wire User->go.md->Owner/Architect->Lead->Senior->Dev resolution path. Add Resolution Routing to Owner, Senior agent prompts. Add Escalation Resolution to Dev. Update company-hierarchy.md with full round-trip. Update execute-protocol.md Step 7 with escalation tracking in .execution-state.json.
      files: agents/yolo-owner.md, agents/yolo-senior.md, agents/yolo-dev.md, references/company-hierarchy.md, references/execute-protocol.md
      plan: 05-03 (T1, T2, T3, T4, T5)
  
    escalation-tests-and-tooling:
      purpose: Create check-escalation-timeout.sh script for timeout detection. Create integration and containment tests covering full round-trip. Update codebase mapping (ARCHITECTURE.md, INDEX.md, CONCERNS.md, PATTERNS.md).
      files: scripts/check-escalation-timeout.sh, tests/integration/escalation-round-trip.bats, tests/containment/escalation-chain.bats, .yolo-planning/codebase/ARCHITECTURE.md, .yolo-planning/codebase/INDEX.md, .yolo-planning/codebase/CONCERNS.md, .yolo-planning/codebase/PATTERNS.md
      plan: 05-04 (T1, T2, T3, T4)
      note: T4 expanded per C9 and C10 to include CONCERNS.md and PATTERNS.md updates
  
  integration_points:
  
    - execute-protocol.md Step 7 escalation tracking: When Dev sends dev_blocker, orchestrator adds escalation entry to .execution-state.json escalations array. Commit immediately (D8). check-escalation-timeout.sh called periodically during implementation to detect stale escalations.
  
    - execute-protocol.md Escalation Handling section: New section after Change Management documenting full upward flow with per-level responsibilities and timeout triggers. References config escalation.timeout_seconds.
  
    - commands/go.md Escalation from Agents: New subsection in Execute mode documenting how go.md intercepts top-of-chain escalations and presents to user via AskUserQuestion. Packages response as escalation_resolution.
  
    - agents/yolo-lead.md Escalation Receipt and Routing: Receives from Senior, assesses authority, routes up or resolves. Tracks pending escalations with timestamps. Forwards resolution back to originating Senior.
  
    - agents/yolo-architect.md AskUserQuestion protocol: Packages structured escalation with options array for go.md. Receives escalation_resolution. May update architecture.toon on design-affecting decisions.
  
    - agents/yolo-owner.md Resolution Routing: Receives user feedback via go.md (Task result or file artifact). Sends resolution to correct Lead via SendMessage/Task result (go.md writes file artifact on Owner's behalf per D1).
  
    - agents/yolo-senior.md Resolution Routing: Translates escalation_resolution into Dev instructions via code_review_changes pattern. Verifies Dev unblocked before marking escalation resolved.
  
    - agents/yolo-dev.md Escalation Resolution: Pause-receive-resume protocol. In teammate mode, claim loop naturally handles pause (Dev works other tasks). On receiving updated instructions, resumes blocked task.
  
    - config/defaults.json escalation section: New config key with timeout_seconds=300, auto_owner_on_timeout=true, max_round_trips=2.
  
    - .execution-state.json escalations array: New field tracking active and resolved escalations per phase. Schema: {id, task, plan, severity, status (pending|resolved|timed_out), level (senior|lead|architect|owner), escalated_at, last_escalated_at, resolved_at, round_trips, resolution}.
  
    - references/handoff-schemas.md: Two new schemas (escalation_resolution, escalation_timeout_warning) bringing total from 27 to 29.
  
    - references/company-hierarchy.md: New Escalation Round-Trip subsection documenting full bidirectional flow with per-level transformations.
  
    - scripts/check-escalation-timeout.sh: Reads .execution-state.json, compares pending escalations against timeout config, returns structured JSON. Called by orchestrator during Step 7 and by validate-gates.sh for Step 7 exit gate (C11).
  
  critique_disposition:
  
    C1: addressed -- Owner sends resolution via SendMessage/Task result. go.md/Lead writes file artifact on Owner's behalf. Mirrors existing Critic->Lead write-proxy pattern. See D1.
  
    C2: addressed -- Architect packages structured escalation with options array via SendMessage to Lead. Lead forwards to go.md. go.md calls AskUserQuestion. No AskUserQuestion in Architect directly. See D2.
  
    C3: addressed -- Intra-team escalation via SendMessage. Cross-team/Owner escalation via file-based artifacts (existing pattern). [teammate] blocks added to Plans 05-02 and 05-03. See D3.
  
    C4: addressed -- Level tracking per escalation with last_escalated_at field. Auto-escalation only fires if current level has not already escalated upward. max_round_trips per-escalation-id. See D4.
  
    C5: addressed -- Plan 05-01 T4 removed entirely. validate-send-message.sh does department boundary checking only. Schema type validation belongs in agent prompts via type discriminator pattern. See D5.
  
    C6: addressed -- Task mode: orchestrator tracks escalation, does not assign next task until resolved. Teammate mode: Dev claim loop naturally filters to available tasks, Dev works other unblocked tasks while waiting. On resolution, Dev resumes blocked task. See D6.
  
    C7: addressed -- Plans 05-01 and 05-02 modify different files, safe as Wave 1 parallel. No dependency change needed. See D7.
  
    C8: addressed -- Escalation state committed immediately on receipt (not waiting for step transition). On resume, check-escalation-timeout.sh detects stale escalations for auto-escalation. See D8.
  
    C9: addressed -- Plan 05-04 T4 expanded to include CONCERNS.md update alongside ARCHITECTURE.md and INDEX.md. New escalation timeout risks documented in CONCERNS.md. See components/escalation-tests-and-tooling note.
  
    C10: addressed -- Plan 05-04 T4 expanded to include PATTERNS.md update. Schema count updated from 27 to 29 in INDEX.md. Escalation round-trip added as Pattern #14 in PATTERNS.md. See components/escalation-tests-and-tooling note.
  
    C11: addressed -- check-escalation-timeout.sh called from validate-gates.sh for Step 7 exit gate check. Standalone script remains for orchestrator periodic checking. Integrated but not replaced. See integration_points.
  
  plan_modifications:
  
    05-01: Remove T4 (validate-send-message.sh update). 4 tasks -> 3 tasks. Remaining: T1 (escalation_resolution schema), T2 (escalation_timeout_warning schema), T3 (escalation config in defaults.json).
  
    05-03 T1: Rescope. Owner does NOT write .escalation-resolution-{dept}.json directly. Owner returns resolution via SendMessage/Task result. Document this in Owner agent prompt -- go.md/Lead writes the file artifact on Owner's behalf. Protocol: (1) Owner receives user feedback via go.md, (2) Owner adds strategic context, (3) Owner returns resolution via SendMessage to Lead or Task result to go.md, (4) go.md/Lead writes .escalation-resolution-{dept}.json.
  
    05-04 T4: Expand scope. Add CONCERNS.md update (escalation timeout risks, false-positive timeouts, unbounded escalation array). Add PATTERNS.md update (Pattern #14: Escalation Round-Trip, schema count 27->29). Add INDEX.md schema count update.
  
  escalation_state_schema:
  
    .execution-state.json gains escalations array:
      location: .yolo-planning/.execution-state.json (existing file)
      new_field: escalations[]
      schema_per_entry:
        id: string (e.g., "ESC-01-02-T3" = phase-plan-task)
        task: string (e.g., "01-02/T3")
        plan: string (e.g., "01-02")
        severity: string (blocking|major|minor)
        status: string (pending|resolved|timed_out)
        level: string (senior|lead|architect|owner)
        escalated_at: ISO8601
        last_escalated_at: ISO8601
        resolved_at: ISO8601 (empty until resolved)
        round_trips: number
        resolution: string (empty until resolved)
      committed: immediately on receipt (D8)
      consumers: check-escalation-timeout.sh, execute-protocol.md Step 7, validate-gates.sh Step 7 exit
  
  new_schema_definitions:
  
    escalation_resolution:
      type: escalation_resolution
      original_escalation: string (ref to escalation id)
      decision: string (user's choice or resolver's decision)
      rationale: string (why this decision)
      action_items: array of strings (specific instructions for downstream agents)
      resolved_by: string (user|owner|architect|lead)
      direction: inbound (never sent upward, only downward)
      plan: 05-01 T1
  
    escalation_timeout_warning:
      type: escalation_timeout_warning
      original_escalation: string (ref to escalation id)
      elapsed_seconds: number
      agent_blocked: string (who is waiting)
      current_level: string (where escalation is stalled)
      recommended_action: string (what should happen next)
      plan: 05-01 T2
  
  config_additions:
  
    defaults.json gains escalation object:
      escalation.timeout_seconds: 300 (5 minutes default)
      escalation.auto_owner_on_timeout: true (auto-involve Owner/go.md on timeout)
      escalation.max_round_trips: 2 (max times same blocker can bounce between levels)
      plan: 05-01 T3


patterns: @.yolo-planning/codebase/PATTERNS.md

conventions[15]{category,rule}:
  file-structure
  naming
  naming
  naming
  naming
  style
  style
  style
  tooling
  style
  style
  patterns
  patterns
  tooling
  patterns

dept_conventions:
  conventions:

reference_package: @references/packages/senior.toon
tool_restrictions:
  Do NOT use: EnterPlanMode, ExitPlanMode
