{"p":"02","n":"04","t":"Integrate filter-agent-context.sh into compile-context.sh","w":3,"d":["02-03"],"xd":[],"mh":{"tr":["compile-context.sh calls filter-agent-context.sh when including JSONL artifacts in compiled TOON","Dev compiled context (.ctx-dev.toon) contains only id,a,f,spec,ts,done from plan tasks (not mh,obj,w,d)","QA compiled context (.ctx-qa.toon) contains only mh,obj from plan header (not task specs)","Security compiled context (.ctx-security.toon) contains only fm from summaries (not full summary)","Token reduction is measurable: filtered context is smaller than unfiltered for dev, qa, security roles"],"ar":[{"p":"scripts/compile-context.sh","pv":"contains calls to filter-agent-context.sh for JSONL artifact inclusion","c":"role-filtered JSONL fields in compiled TOON output"}],"kl":[{"fr":"scripts/compile-context.sh dev case","to":"scripts/filter-agent-context.sh","vi":"dev case uses filter to extract only spec+id+a+f+ts+done"},{"fr":"scripts/compile-context.sh qa case","to":"scripts/filter-agent-context.sh","vi":"qa case uses filter to extract only mh+obj from header"}]},"obj":"Wire per-agent field filtering into the existing context compilation pipeline so agents automatically receive minimal context","sk":["commit"],"auto":true}
{"id":"T1","tp":"auto","a":"Modify compile-context.sh dev case to use filter-agent-context.sh (REQ-04). Replace the raw jq extraction of plan tasks with a call to filter-agent-context.sh --role=dev --artifact=PLAN_PATH --type=plan. This ensures Dev only sees id,a,f,spec,ts,done fields (not mh, obj, w, d from header or v from tasks that Dev does not need). Update the task formatting to work with filtered output.","f":["scripts/compile-context.sh"],"v":"compile-context.sh dev case calls filter-agent-context.sh","done":"Dev context uses field-filtered plan extraction","spec":"FILE: scripts/compile-context.sh. Modify the dev case (lines 410-458).\n\nSTEP 1 -- Add FILTER_SCRIPT variable. Insert AFTER line 274 (BUDGET=$(get_budget \"$ROLE\")) and BEFORE line 275 (ARCH_FILE=$(get_arch_file)):\n\n# --- Resolve filter-agent-context.sh path (D10: graceful degradation) ---\nFILTER_SCRIPT=\"${CLAUDE_PLUGIN_ROOT:-$(cd \"$(dirname \"$0\")\" && pwd)/..}/scripts/filter-agent-context.sh\"\nFILTER_AVAILABLE=false; [ -x \"$FILTER_SCRIPT\" ] && FILTER_AVAILABLE=true\n\nThis follows the same resolution pattern as get_tool_restrictions() on line 166. The variable is set once at top-level scope so all role cases can reference it.\n\nSTEP 2 -- Modify the dev case plan extraction block. Current code (lines 415-420):\n\n      if [ -n \"$PLAN_PATH\" ] && [ -f \"$PLAN_PATH\" ]; then\n        # Extract tasks from plan.jsonl (skip header line)\n        TASK_COUNT=$(tail -n +2 \"$PLAN_PATH\" | wc -l | tr -d ' ')\n        echo \"tasks[${TASK_COUNT}]{id,action,files,done,spec}:\"\n        tail -n +2 \"$PLAN_PATH\" | jq -r 'select((.id // empty) != \"\") | \"  \\(.id),\\(.a // \"\"),\\(.f // [] | join(\";\")),(.\\.done // \"\"),\\(.spec // \"\")\"' 2>/dev/null || true\n      fi\n\nReplace with:\n\n      if [ -n \"$PLAN_PATH\" ] && [ -f \"$PLAN_PATH\" ]; then\n        TASK_COUNT=$(tail -n +2 \"$PLAN_PATH\" | wc -l | tr -d ' ')\n        echo \"tasks[${TASK_COUNT}]{id,action,files,done,spec}:\"\n        if [ \"$FILTER_AVAILABLE\" = true ]; then\n          bash \"$FILTER_SCRIPT\" --role \"$BASE_ROLE\" --artifact \"$PLAN_PATH\" --type plan 2>/dev/null | \\\n            jq -r 'select((.id // empty) != \"\") | \"  \\(.id),\\(.a // \"\"),\\(.f // [] | join(\";\")),(.\\.done // \"\"),\\(.spec // \"\")\"' 2>/dev/null || true\n        else\n          # Fallback: inline jq (pre-filter behavior)\n          tail -n +2 \"$PLAN_PATH\" | jq -r 'select((.id // empty) != \"\") | \"  \\(.id),\\(.a // \"\"),\\(.f // [] | join(\";\")),(.\\.done // \"\"),\\(.spec // \"\")\"' 2>/dev/null || true\n        fi\n      fi\n\nKEY DETAILS:\n1. The filter script outputs JSONL with only {id,a,f,spec,ts,done} fields per task line. The jq -r formatting after the filter is unchanged because it still reads .id, .a, .f, .done, .spec from the filtered output -- those fields are preserved by the filter.\n2. Use $BASE_ROLE (not $ROLE) so fe-dev and ux-dev correctly route to the 'dev' filter mapping.\n3. Pipe stderr to /dev/null (2>/dev/null) on the filter call so errors in the filter fall through silently to the fallback-equivalent empty output. The || true prevents set -e from aborting.\n4. The fallback else branch is the EXACT current code (tail -n +2 | jq -r). This ensures D10 graceful degradation.\n5. Do NOT change the TOON header format string \"tasks[${TASK_COUNT}]{id,action,files,done,spec}:\" -- it stays the same because the TOON output format is unchanged, only the source data is filtered.\n\nVERIFICATION: (1) Run compile-context.sh with a plan containing tasks that have v, tp, w fields -- the dev .ctx output should NOT contain those field values. (2) Remove filter-agent-context.sh temporarily and run again -- output should be identical to pre-change behavior (graceful fallback).","ts":"Test file: tests/unit/compile-context.bats. Framework: bats-core. See T4 for full test specification covering dev case filtering verification. The dev-specific test is: 'dev context does not contain plan header fields (mh, obj) when filter available'."}
{"id":"T2","tp":"auto","a":"Modify compile-context.sh qa and qa-code cases to use filter-agent-context.sh (REQ-04). QA case: filter plan.jsonl to only mh,obj from header (no task details). QA-Code case: filter summary.jsonl to only fm field (files to check). Both roles should see smaller TOON output than before.","f":["scripts/compile-context.sh"],"v":"compile-context.sh qa case uses filtered plan header, qa-code case uses filtered summary","done":"QA and QA-Code contexts use field-filtered artifacts","spec":"FILE: scripts/compile-context.sh. Modify two cases: qa (lines 460-484) and qa-code (lines 487-518). Both use the FILTER_SCRIPT and FILTER_AVAILABLE variables added by T1.\n\nQA CASE (lines 460-484):\nThe qa case currently does NOT extract plan.jsonl data -- it emits success_criteria, requirements, and conventions. Per the agent-field-map.md, QA needs plan header fields mh and obj. The current code does not include plan data at all, so this task ADDS plan header extraction to the qa case using the filter.\n\nInsert after the emit_header + success_criteria block (after line 465 'echo \"\"') and before get_requirements (line 466):\n\n      # Plan header context (must-haves and objective)\n      if [ -n \"$PLAN_PATH\" ] && [ -f \"$PLAN_PATH\" ]; then\n        echo \"plan_context:\"\n        if [ \"$FILTER_AVAILABLE\" = true ]; then\n          bash \"$FILTER_SCRIPT\" --role \"$BASE_ROLE\" --artifact \"$PLAN_PATH\" --type plan 2>/dev/null | \\\n            jq -r '\"  obj: \\(.obj // \"\")\"' 2>/dev/null || true\n          bash \"$FILTER_SCRIPT\" --role \"$BASE_ROLE\" --artifact \"$PLAN_PATH\" --type plan 2>/dev/null | \\\n            jq -r '.mh.tr // [] | .[] | \"  must_have: \\(.)\"' 2>/dev/null || true\n        else\n          # Fallback: extract mh,obj from header inline\n          head -1 \"$PLAN_PATH\" | jq -r '\"  obj: \\(.obj // \"\")\"' 2>/dev/null || true\n          head -1 \"$PLAN_PATH\" | jq -r '.mh.tr // [] | .[] | \"  must_have: \\(.)\"' 2>/dev/null || true\n        fi\n        echo \"\"\n      fi\n\nNOTE: The qa filter (filter-agent-context.sh --role qa --type plan) outputs line 1 of the plan JSONL projected to {mh,obj}. The jq formatting here reads .obj and .mh.tr from that filtered output.\n\nALSO NOTE: The qa case signature needs PLAN_PATH passed. Currently compile-context.sh passes PLAN_PATH as arg 4. The qa case block is inside the same script so $PLAN_PATH is already available -- no arg parsing changes needed.\n\nQA-CODE CASE (lines 487-518):\nCurrent code (lines 492-499):\n\n      echo \"files_to_check:\"\n      for summary in \"$PHASE_DIR\"/*.summary.jsonl; do\n        if [ -f \"$summary\" ]; then\n          jq -r '.fm // [] | .[]' \"$summary\" 2>/dev/null | while IFS= read -r f; do\n            echo \"  $f\"\n          done\n        fi\n      done\n\nReplace with:\n\n      echo \"files_to_check:\"\n      for summary in \"$PHASE_DIR\"/*.summary.jsonl; do\n        if [ -f \"$summary\" ]; then\n          if [ \"$FILTER_AVAILABLE\" = true ]; then\n            bash \"$FILTER_SCRIPT\" --role \"$BASE_ROLE\" --artifact \"$summary\" --type summary 2>/dev/null | \\\n              jq -r '.fm // [] | .[]' 2>/dev/null | while IFS= read -r f; do\n                echo \"  $f\"\n              done\n          else\n            jq -r '.fm // [] | .[]' \"$summary\" 2>/dev/null | while IFS= read -r f; do\n              echo \"  $f\"\n            done\n          fi\n        fi\n      done\n\nKEY DETAILS:\n1. The qa-code filter (--role qa-code --type summary) outputs {fm} only. The subsequent jq -r '.fm // [] | .[]' reads the fm array and outputs one file per line -- identical to current behavior.\n2. The for-loop over *.summary.jsonl is preserved. Each summary file is filtered individually.\n3. Fallback else branch is the EXACT current code.\n4. The rest of the qa-code case (conventions, dept_conventions, get_research, reference_package, tool_restrictions) is UNCHANGED.\n\nVERIFICATION: (1) QA context now includes plan_context section with obj and must_have lines when PLAN_PATH is set. (2) QA-code context files_to_check list is identical with and without filter. (3) Remove filter script -- both cases produce same output as before.","ts":"Test file: tests/unit/compile-context.bats. Framework: bats-core. See T4 for full test specification. QA-specific tests: 'qa context includes plan_context with mh when filter and plan available', 'qa-code context files_to_check is same with or without filter'."}
{"id":"T3","tp":"auto","a":"Modify compile-context.sh security case to use filter-agent-context.sh for summary.jsonl (REQ-04). Security only needs fm (files_modified) from summaries. Filter out all other summary fields (s, tc, tt, ch, dv, built, tst). Also add filter for senior and tester cases where applicable.","f":["scripts/compile-context.sh"],"v":"compile-context.sh security case uses filtered summary with only fm field","done":"Security and other role contexts use filtered artifacts","spec":"FILE: scripts/compile-context.sh. Modify three cases: security (lines 582-606), senior (lines 364-408), tester (lines 521-553). All use FILTER_SCRIPT and FILTER_AVAILABLE from T1.\n\nSECURITY CASE (lines 582-606):\nCurrent code (lines 587-594):\n\n      echo \"files_to_audit:\"\n      for summary in \"$PHASE_DIR\"/*.summary.jsonl; do\n        if [ -f \"$summary\" ]; then\n          jq -r '.fm // [] | .[]' \"$summary\" 2>/dev/null | while IFS= read -r f; do\n            echo \"  $f\"\n          done\n        fi\n      done\n\nReplace with:\n\n      echo \"files_to_audit:\"\n      for summary in \"$PHASE_DIR\"/*.summary.jsonl; do\n        if [ -f \"$summary\" ]; then\n          if [ \"$FILTER_AVAILABLE\" = true ]; then\n            bash \"$FILTER_SCRIPT\" --role \"$BASE_ROLE\" --artifact \"$summary\" --type summary 2>/dev/null | \\\n              jq -r '.fm // [] | .[]' 2>/dev/null | while IFS= read -r f; do\n                echo \"  $f\"\n              done\n          else\n            jq -r '.fm // [] | .[]' \"$summary\" 2>/dev/null | while IFS= read -r f; do\n              echo \"  $f\"\n            done\n          fi\n        fi\n      done\n\nThis is structurally identical to the qa-code change in T2. The security filter (--role security --type summary) outputs {fm} only.\n\nSENIOR CASE (lines 364-408):\nThe senior case currently does not extract JSONL artifact data directly -- it emits architecture, requirements, patterns, conventions, and dept_conventions. Per agent-field-map.md, senior in design review mode reads plan tasks with {id,a,f,done,v} and critique with {id,desc,rec where st=open}. However, compile-context.sh senior case does NOT currently include plan task data. The senior receives its plan via the PLAN_PATH argument at execution time (passed by execute-protocol.md), not embedded in the compiled context.\n\nTherefore: NO CHANGE to the senior case body. The senior case does not embed JSONL artifact data in the TOON output. Senior reads plan.jsonl directly during its execution, not via compiled context. Adding filter integration to senior would mean embedding plan data in the senior TOON, which is NOT the current pattern and would be scope creep.\n\nHowever, if the senior case is extended in a future plan to embed plan or critique data, the FILTER_SCRIPT guard pattern is available.\n\nTESTER CASE (lines 521-553):\nCurrent code (lines 526-529):\n\n      if [ -n \"$PLAN_PATH\" ] && [ -f \"$PLAN_PATH\" ]; then\n        TASK_COUNT=$(tail -n +2 \"$PLAN_PATH\" | wc -l | tr -d ' ')\n        echo \"tasks[${TASK_COUNT}]{id,action,files,done,spec,test_spec}:\"\n        tail -n +2 \"$PLAN_PATH\" | jq -r 'select((.id // empty) != \"\") | \"  \\(.id),\\(.a // \"\"),\\(.f // [] | join(\";\")),(.\\.done // \"\"),\\(.spec // \"\"),\\(.ts // \"\")\"' 2>/dev/null || true\n      fi\n\nReplace with:\n\n      if [ -n \"$PLAN_PATH\" ] && [ -f \"$PLAN_PATH\" ]; then\n        TASK_COUNT=$(tail -n +2 \"$PLAN_PATH\" | wc -l | tr -d ' ')\n        echo \"tasks[${TASK_COUNT}]{id,action,files,done,spec,test_spec}:\"\n        if [ \"$FILTER_AVAILABLE\" = true ]; then\n          bash \"$FILTER_SCRIPT\" --role \"$BASE_ROLE\" --artifact \"$PLAN_PATH\" --type plan 2>/dev/null | \\\n            jq -r 'select((.id // empty) != \"\") | \"  \\(.id),\\(.a // \"\"),\\(.f // [] | join(\";\")),(.\\.done // \"\"),\\(.spec // \"\"),\\(.ts // \"\")\"' 2>/dev/null || true\n        else\n          tail -n +2 \"$PLAN_PATH\" | jq -r 'select((.id // empty) != \"\") | \"  \\(.id),\\(.a // \"\"),\\(.f // [] | join(\";\")),(.\\.done // \"\"),\\(.spec // \"\"),\\(.ts // \"\")\"' 2>/dev/null || true\n        fi\n      fi\n\nKEY DETAILS:\n1. The tester filter (--role tester --type plan) outputs {id,a,f,ts,spec} per task. The jq -r formatting reads .id, .a, .f, .done, .spec, .ts. Note that .done is NOT in the tester filter output, so it will be null/empty in filtered mode. This is correct per agent-field-map.md -- tester does not need .done.\n2. Wait -- the current TOON header says {id,action,files,done,spec,test_spec} and the jq expression includes .done. If the filter removes .done, the output will have an empty done field in the comma-separated TOON line. This is ACCEPTABLE because the empty field is still parseable and the tester does not use .done.\n3. ALTERNATIVELY, update the TOON header to match the filtered fields: echo \"tasks[${TASK_COUNT}]{id,action,files,spec,test_spec}:\" and remove .done from the jq expression. BUT this would change the fallback output format too, which could break existing tester behavior. DECISION: Keep the current TOON header and jq expression unchanged. The filter will pass through null for .done, which jq // \"\" handles as empty string. No behavioral change.\n4. Fallback else branch is the EXACT current code.\n\nSENIOR CASE DECISION: No change. Document in decisions.jsonl that senior case is excluded from filter integration because it does not embed JSONL artifact data in compiled TOON output.\n\nVERIFICATION: (1) Security context files_to_audit list identical with/without filter. (2) Tester context tasks list works with filter (done field may be empty). (3) Senior context unchanged. (4) All existing compile-context.bats tests still pass.","ts":"Test file: tests/unit/compile-context.bats. Framework: bats-core. See T4 for full test specification. Security-specific test: 'security context does not contain commit hashes from summaries when filter available'. Tester-specific test: 'tester context includes task lines from plan with filter'."}
{"id":"T4","tp":"auto","a":"Update existing compile-context.bats tests to verify field filtering (REQ-04). Add test cases: (1) dev TOON does not contain mh or obj strings from plan header, (2) qa TOON contains mh but not spec strings from tasks, (3) security TOON contains file paths but not commit hashes from summaries. These tests verify the integration works end-to-end.","f":["tests/unit/compile-context.bats"],"v":"bats tests/unit/compile-context.bats passes including new filtering verification tests","done":"Integration tests verify field filtering in compiled context","spec":"FILE: tests/unit/compile-context.bats. ADD new test cases at the end of the file (after the last existing test on line 485). Do NOT modify existing tests.\n\nPREREQUISITE: These tests need a richer plan fixture than valid-plan.jsonl. The existing fixture has minimal fields (no mh, obj, ts, v). Create a new fixture specifically for filter tests.\n\nSTEP 1 -- Create fixture file tests/fixtures/plans/filter-test-plan.jsonl (NEW):\nLine 1 (header): {\"p\":\"01\",\"n\":\"01\",\"t\":\"Filter test plan\",\"w\":1,\"d\":[],\"xd\":[],\"mh\":{\"tr\":[\"auth middleware exists\",\"returns 401 on invalid token\"],\"ar\":[{\"p\":\"src/auth.ts\",\"pv\":\"exists\",\"c\":\"middleware\"}],\"kl\":[]},\"obj\":\"Build auth middleware\",\"sk\":[\"commit\"],\"auto\":true}\nLine 2 (task): {\"id\":\"T1\",\"tp\":\"auto\",\"a\":\"Create auth middleware\",\"f\":[\"src/auth.ts\"],\"v\":\"middleware exports\",\"done\":\"Auth created\",\"spec\":\"Create src/auth.ts with JWT validation\",\"ts\":\"Test auth.ts validates tokens\"}\nLine 3 (task): {\"id\":\"T2\",\"tp\":\"auto\",\"a\":\"Create rate limiter\",\"f\":[\"src/rate-limit.ts\"],\"v\":\"limiter works\",\"done\":\"Rate limit created\",\"spec\":\"Create src/rate-limit.ts with express-rate-limit\",\"ts\":\"Test rate limiting\"}\n\nSTEP 2 -- Create fixture file tests/fixtures/summaries/filter-test-summary.jsonl (NEW):\nLine 1: {\"p\":\"01\",\"n\":\"01\",\"s\":\"complete\",\"dt\":\"2026-02-17\",\"tc\":2,\"tt\":2,\"ch\":[\"abc1234\",\"def5678\"],\"fm\":[\"src/auth.ts\",\"src/rate-limit.ts\"],\"dv\":[],\"built\":[\"auth middleware\",\"rate limiter\"],\"tst\":\"green_only\"}\n\nSTEP 3 -- Add 8 new test cases to tests/unit/compile-context.bats:\n\n# --- Field filtering integration tests (plan 02-04) ---\n\n@test \"dev context does not contain plan header obj field\" {\n  local plan=\"$PHASES_DIR/01-setup/01-01.plan.jsonl\"\n  cp \"$FIXTURES_DIR/plans/filter-test-plan.jsonl\" \"$plan\"\n  run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' 01 dev '$PHASES_DIR' '$plan'\"\n  assert_success\n  local ctx=\"$PHASES_DIR/01-setup/.ctx-dev.toon\"\n  # Dev context should have task data but NOT header obj field\n  run cat \"$ctx\"\n  assert_output --partial \"T1\"\n  refute_output --partial \"Build auth middleware\"\n}\n\n@test \"dev context does not contain task v field when filter available\" {\n  local plan=\"$PHASES_DIR/01-setup/01-01.plan.jsonl\"\n  cp \"$FIXTURES_DIR/plans/filter-test-plan.jsonl\" \"$plan\"\n  run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' 01 dev '$PHASES_DIR' '$plan'\"\n  assert_success\n  local ctx=\"$PHASES_DIR/01-setup/.ctx-dev.toon\"\n  run cat \"$ctx\"\n  # The 'v' field value 'middleware exports' should NOT appear in dev context\n  # Note: when filter is unavailable (fallback), 'v' also does not appear because\n  # the jq expression never extracts .v. So this test passes in both modes.\n  refute_output --partial \"middleware exports\"\n}\n\n@test \"dev context includes spec field from tasks\" {\n  local plan=\"$PHASES_DIR/01-setup/01-01.plan.jsonl\"\n  cp \"$FIXTURES_DIR/plans/filter-test-plan.jsonl\" \"$plan\"\n  run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' 01 dev '$PHASES_DIR' '$plan'\"\n  assert_success\n  local ctx=\"$PHASES_DIR/01-setup/.ctx-dev.toon\"\n  run cat \"$ctx\"\n  assert_output --partial \"JWT validation\"\n}\n\n@test \"qa context includes plan_context with must_have when plan provided\" {\n  local plan=\"$PHASES_DIR/01-setup/01-01.plan.jsonl\"\n  cp \"$FIXTURES_DIR/plans/filter-test-plan.jsonl\" \"$plan\"\n  run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' 01 qa '$PHASES_DIR' '$plan'\"\n  assert_success\n  local ctx=\"$PHASES_DIR/01-setup/.ctx-qa.toon\"\n  run cat \"$ctx\"\n  # QA should see plan header data\n  assert_output --partial \"Build auth middleware\"\n  assert_output --partial \"auth middleware exists\"\n  # QA should NOT see task spec details\n  refute_output --partial \"JWT validation\"\n  refute_output --partial \"express-rate-limit\"\n}\n\n@test \"security context includes file paths from summaries\" {\n  cp \"$FIXTURES_DIR/summaries/filter-test-summary.jsonl\" \"$PHASES_DIR/01-setup/01-01.summary.jsonl\"\n  run_cc 01 security\n  assert_success\n  local ctx=\"$PHASES_DIR/01-setup/.ctx-security.toon\"\n  run cat \"$ctx\"\n  assert_output --partial \"src/auth.ts\"\n  assert_output --partial \"src/rate-limit.ts\"\n}\n\n@test \"security context does not contain commit hashes from summaries\" {\n  cp \"$FIXTURES_DIR/summaries/filter-test-summary.jsonl\" \"$PHASES_DIR/01-setup/01-01.summary.jsonl\"\n  run_cc 01 security\n  assert_success\n  local ctx=\"$PHASES_DIR/01-setup/.ctx-security.toon\"\n  run cat \"$ctx\"\n  # Security should NOT see commit hashes (ch field)\n  refute_output --partial \"abc1234\"\n  refute_output --partial \"def5678\"\n  # Security should NOT see built descriptions\n  refute_output --partial \"auth middleware\"\n}\n\n@test \"tester context includes task test_spec from plan\" {\n  local plan=\"$PHASES_DIR/01-setup/01-01.plan.jsonl\"\n  cp \"$FIXTURES_DIR/plans/filter-test-plan.jsonl\" \"$plan\"\n  run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' 01 tester '$PHASES_DIR' '$plan'\"\n  assert_success\n  local ctx=\"$PHASES_DIR/01-setup/.ctx-tester.toon\"\n  run cat \"$ctx\"\n  assert_output --partial \"validates tokens\"\n  assert_output --partial \"rate limiting\"\n}\n\n@test \"qa-code context includes files_to_check from summaries\" {\n  cp \"$FIXTURES_DIR/summaries/filter-test-summary.jsonl\" \"$PHASES_DIR/01-setup/01-01.summary.jsonl\"\n  run_cc 01 qa-code\n  assert_success\n  local ctx=\"$PHASES_DIR/01-setup/.ctx-qa-code.toon\"\n  run cat \"$ctx\"\n  assert_output --partial \"files_to_check:\"\n  assert_output --partial \"src/auth.ts\"\n  # Should NOT have commit hashes\n  refute_output --partial \"abc1234\"\n}\n\nIMPORTANT NOTES:\n1. These tests work BOTH with and without filter-agent-context.sh present. The key assertions are about what data DOES and DOES NOT appear in the compiled TOON output.\n2. The 'dev context does not contain plan header obj field' test works even without the filter because the current dev case already skips the header (tail -n +2). The filter just adds an extra layer of field projection.\n3. The 'security context does not contain commit hashes' test is the KEY filter verification test. Without the filter, the current code (jq -r '.fm // [] | .[]') already only extracts fm. So this test validates that the filter does not regress the existing behavior AND that non-fm fields are excluded.\n4. The 'qa context includes plan_context' test is the NEW BEHAVIOR test. This only passes after T2 adds plan header extraction to the qa case. It tests that the qa case now includes mh and obj from the plan header.\n5. Use the new filter-test-plan.jsonl and filter-test-summary.jsonl fixtures that have richer field content than the existing valid-plan.jsonl / valid-summary.jsonl.\n6. Do NOT modify any existing tests. Only append new tests after line 485.\n\nVERIFICATION: Run bats tests/unit/compile-context.bats -- all existing tests pass (no regression), all 8 new tests pass.","ts":"These ARE the tests. The 8 test cases above are the deliverable. Verification: bats tests/unit/compile-context.bats passes all tests (existing + new). Coverage: dev (3 tests: no header obj, no task v, has spec), qa (1 test: has mh/obj, no task spec), security (2 tests: has fm files, no commit hashes), tester (1 test: has ts field), qa-code (1 test: has fm files, no commit hashes). Each test uses filter-test-plan.jsonl or filter-test-summary.jsonl fixtures. Both filter-available and filter-unavailable paths produce correct output because the tests assert on TOON output content, not on whether the filter was called."}
{"id":"T5","tp":"auto","a":"Add token reduction measurement to compile-context.sh (REQ-04). After enforce_budget, emit a comment line showing token count. Add a --measure flag that compares filtered vs unfiltered output size for the given role. Output: {\"role\":\"dev\",\"filtered_tokens\":N,\"unfiltered_tokens\":N,\"reduction_pct\":N}. This enables measurable token reduction verification.","f":["scripts/compile-context.sh"],"v":"compile-context.sh --measure flag outputs JSON with token reduction stats","done":"Measurable token reduction capability added","spec":"FILE: scripts/compile-context.sh. Add --measure flag support.\n\nSTEP 1 -- Add MEASURE flag parsing. Modify the argument section at the top of the file. Currently (lines 11-20):\n\nif [ $# -lt 2 ]; then\n  echo \"Usage: compile-context.sh <phase-number> <role> [phases-dir] [plan-path]\" >&2\n  exit 1\nfi\n\nPHASE=\"$1\"\nROLE=\"$2\"\nPHASES_DIR=\"${3:-.yolo-planning/phases}\"\nPLANNING_DIR=\".yolo-planning\"\nPLAN_PATH=\"${4:-}\"\n\nReplace with:\n\n# --- Parse --measure flag (must be first arg if present) ---\nMEASURE=false\nif [ \"${1:-}\" = \"--measure\" ]; then\n  MEASURE=true\n  shift\nfi\n\nif [ $# -lt 2 ]; then\n  echo \"Usage: compile-context.sh [--measure] <phase-number> <role> [phases-dir] [plan-path]\" >&2\n  exit 1\nfi\n\nPHASE=\"$1\"\nROLE=\"$2\"\nPHASES_DIR=\"${3:-.yolo-planning/phases}\"\nPLANNING_DIR=\".yolo-planning\"\nPLAN_PATH=\"${4:-}\"\n\nSTEP 2 -- Add measurement logic AFTER the enforce_budget call and BEFORE the final echo. Currently (lines 673-679):\n\n# --- Enforce token budget ---\nOUTPUT_FILE=\"${PHASE_DIR}/.ctx-${ROLE}.toon\"\nif [ -f \"$OUTPUT_FILE\" ]; then\n  enforce_budget \"$OUTPUT_FILE\" \"$BUDGET\"\nfi\n\necho \"$OUTPUT_FILE\"\n\nReplace with:\n\n# --- Enforce token budget ---\nOUTPUT_FILE=\"${PHASE_DIR}/.ctx-${ROLE}.toon\"\nif [ -f \"$OUTPUT_FILE\" ]; then\n  enforce_budget \"$OUTPUT_FILE\" \"$BUDGET\"\nfi\n\n# --- Token reduction measurement (D9: char/4 approximation) ---\nif [ \"$MEASURE\" = true ] && [ -f \"$OUTPUT_FILE\" ]; then\n  FILTERED_CHARS=$(wc -c < \"$OUTPUT_FILE\" | tr -d ' ')\n  FILTERED_TOKENS=$(( FILTERED_CHARS / 4 ))\n\n  # Generate unfiltered version for comparison\n  ORIG_FILTER=\"$FILTER_AVAILABLE\"\n  FILTER_AVAILABLE=false\n  UNFILTERED_FILE=\"${OUTPUT_FILE}.unfiltered.$$\"\n  # Re-run the role case with filter disabled, redirecting to temp file\n  # Instead of re-running (complex), calculate from the original plan/summary sizes\n  UNFILTERED_CHARS=0\n  if [ -n \"$PLAN_PATH\" ] && [ -f \"$PLAN_PATH\" ]; then\n    PLAN_CHARS=$(wc -c < \"$PLAN_PATH\" | tr -d ' ')\n    UNFILTERED_CHARS=$(( UNFILTERED_CHARS + PLAN_CHARS ))\n  fi\n  for summary in \"$PHASE_DIR\"/*.summary.jsonl 2>/dev/null; do\n    if [ -f \"$summary\" ]; then\n      SUMMARY_CHARS=$(wc -c < \"$summary\" | tr -d ' ')\n      UNFILTERED_CHARS=$(( UNFILTERED_CHARS + SUMMARY_CHARS ))\n    fi\n  done\n  # If no artifact data, use filtered as unfiltered (no reduction)\n  if [ \"$UNFILTERED_CHARS\" -eq 0 ]; then\n    UNFILTERED_CHARS=\"$FILTERED_CHARS\"\n  fi\n  UNFILTERED_TOKENS=$(( UNFILTERED_CHARS / 4 ))\n\n  if [ \"$UNFILTERED_TOKENS\" -gt 0 ]; then\n    REDUCTION_PCT=$(( (UNFILTERED_TOKENS - FILTERED_TOKENS) * 100 / UNFILTERED_TOKENS ))\n  else\n    REDUCTION_PCT=0\n  fi\n  FILTER_AVAILABLE=\"$ORIG_FILTER\"\n\n  # Output measurement JSON to stderr (stdout has the file path)\n  echo \"{\\\"role\\\":\\\"$ROLE\\\",\\\"filtered_chars\\\":$FILTERED_CHARS,\\\"unfiltered_chars\\\":$UNFILTERED_CHARS,\\\"reduction_pct\\\":$REDUCTION_PCT,\\\"note\\\":\\\"char/4 approx\\\"}\" >&2\nfi\n\necho \"$OUTPUT_FILE\"\n\nKEY DETAILS:\n1. --measure MUST be the first argument (before phase number). This avoids ambiguity with positional args.\n2. Output goes to STDERR (>&2) so it does not interfere with the stdout file path output that callers depend on. This matches D9 spec: --measure outputs JSON measurement data.\n3. The D9 schema uses field names: role, filtered_chars, unfiltered_chars, reduction_pct, note. The note field is always \"char/4 approx\".\n4. The unfiltered size is approximated from raw artifact file sizes (plan + summaries). This is an OVERESTIMATE of what the unfiltered TOON would contain because the TOON includes other sections (header, conventions, etc.) that are identical in both versions. But for the purposes of D9 (demonstrating that filtering reduces artifact data), comparing raw artifact size to filtered output size is a valid measurement.\n5. ALTERNATIVE APPROACH (more accurate but more complex): Re-run the entire case block with FILTER_AVAILABLE=false, capture to a temp file, measure that, delete temp file. This is rejected because it doubles execution time and the simpler approach is sufficient for the D9 requirement.\n6. The for loop over *.summary.jsonl uses 2>/dev/null to suppress 'no matches' error when glob does not expand.\n7. Integer arithmetic for reduction_pct uses bash $(( )) which truncates (floor division). This is acceptable for an approximation.\n8. When no artifacts are present (no plan, no summaries), unfiltered_chars equals filtered_chars and reduction_pct is 0.\n9. Usage string updated to show optional --measure flag.\n\nVERIFICATION: (1) Run: bash scripts/compile-context.sh --measure 01 dev .yolo-planning/phases .yolo-planning/phases/01-setup/01-01.plan.jsonl 2>measure.json. (2) Check measure.json contains valid JSON with role, filtered_chars, unfiltered_chars, reduction_pct, note fields. (3) Run without --measure: no measurement output on stderr. (4) Run with --measure but no plan or summary: reduction_pct is 0.","ts":"Test file: tests/unit/compile-context.bats. Framework: bats-core. Add 4 test cases:\n\n@test \"--measure flag outputs JSON measurement to stderr\" {\n  local plan=\"$PHASES_DIR/01-setup/01-01.plan.jsonl\"\n  cp \"$FIXTURES_DIR/plans/filter-test-plan.jsonl\" \"$plan\"\n  run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' --measure 01 dev '$PHASES_DIR' '$plan' 2>&1 1>/dev/null\"\n  assert_success\n  assert_output --partial '\"role\":\"dev\"'\n  assert_output --partial '\"filtered_chars\"'\n  assert_output --partial '\"reduction_pct\"'\n  assert_output --partial '\"note\":\"char/4 approx\"'\n}\n\n@test \"--measure outputs file path on stdout\" {\n  local plan=\"$PHASES_DIR/01-setup/01-01.plan.jsonl\"\n  cp \"$FIXTURES_DIR/plans/filter-test-plan.jsonl\" \"$plan\"\n  run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' --measure 01 dev '$PHASES_DIR' '$plan' 2>/dev/null\"\n  assert_success\n  assert_output --partial \".ctx-dev.toon\"\n}\n\n@test \"without --measure no JSON measurement on stderr\" {\n  local plan=\"$PHASES_DIR/01-setup/01-01.plan.jsonl\"\n  cp \"$FIXTURES_DIR/plans/filter-test-plan.jsonl\" \"$plan\"\n  run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' 01 dev '$PHASES_DIR' '$plan' 2>&1 1>/dev/null\"\n  assert_success\n  refute_output --partial '\"filtered_chars\"'\n}\n\n@test \"--measure with no artifacts shows 0 reduction\" {\n  run bash -c \"cd '$TEST_WORKDIR' && bash '$SUT' --measure 01 architect '$PHASES_DIR' 2>&1 1>/dev/null\"\n  assert_success\n  assert_output --partial '\"reduction_pct\":0'\n}\n\nThese 4 tests verify: (1) --measure produces JSON on stderr with correct fields, (2) --measure still produces file path on stdout, (3) without --measure no measurement output, (4) edge case with no artifacts produces 0% reduction."}
