# Phase 02 Architecture: R&D Research Flow & Context Optimization

scope: REQ-03 (R&D/research phase in workflow), REQ-04 (per-agent context filtering)
approach: Insert Scout research step into execute-protocol, enhance research.jsonl schema, build standalone field-filtering script, integrate into compile-context.sh
risk_profile: medium (touches execute-protocol.md core workflow + compile-context.sh pipeline; backward compat required)


## Design Decisions

D1: Display-only step renumbering with string state keys preserved [C1, C12]
The .execution-state.json uses string keys for step names (critique, architecture, planning, etc.), NOT numeric indices. Adding the research step means adding a "research" string key to the steps object schema -- it does NOT require renaming existing keys. The numeric step labels (Step 1, Step 2, ...) in prose documentation are display-only labels. Old Step 2 (Architecture) becomes display "Step 3" but its state key remains "architecture". The new research step gets state key "research" and display label "Step 2". The Mandatory vs Skippable section in execute-protocol.md must be rewritten using state key names instead of bare numbers to avoid future confusion. Updated Mandatory vs Skippable: "Skippable: critique (turbo or exists), research (turbo or exists), architecture (exists), test_authoring (turbo or no ts), qa (--skip-qa or turbo), security (--skip-security or config off). Mandatory (failure = STOP, no --force): planning, design_review, implementation, code_review, signoff." This eliminates the numeric reference problem entirely.

D2: Orchestrator writes research.jsonl, mirroring Critic pattern [C2]
Scout is a read-only agent (no Write tool, identical constraint to Critic). The execute-protocol.md research step must explicitly state that go.md (the orchestrator / Owner proxy) writes research.jsonl from Scout's returned findings. The pattern is: (1) Orchestrator spawns Scout (Task tool or SendMessage), (2) Scout returns findings as structured output (task result or scout_findings schema), (3) Orchestrator writes research.jsonl to phase directory, (4) Orchestrator commits. This mirrors the existing Critic pattern at Step 1 lines 144-146 where Critic returns findings and orchestrator writes critique.jsonl. In teammate mode, Scout sends scout_findings via SendMessage to Lead, and Lead writes research.jsonl.

D3: Append-mode research with pre-Critic vs post-Critic coexistence [C6]
The skip guard for the research step must NOT use simple file-existence checking. If research.jsonl exists from pre-Critic research (the /yolo:go --research-first flow), the post-Critic research step must still run and APPEND findings to the existing file. The skip guard is: skip if --effort=turbo. The research.jsonl file existence alone does NOT trigger skip -- only turbo effort does. Each research entry includes a "mode" field ("pre-critic" or "post-critic") so consumers can distinguish origin. Pre-Critic entries have no brief_for field (no critique exists yet). Post-Critic entries have brief_for linking to critique IDs. Both coexist in the same file. The get_research() helper in compile-context.sh reads all entries regardless of mode.

D4: Backward-compatible research.jsonl schema enhancement [C5]
New fields added to research.jsonl are ALL optional with jq // defaults: brief_for (string, defaults to empty -- links to critique ID that prompted research), mode (string, defaults to "standalone" -- values: "pre-critic", "post-critic", "standalone"), priority (string, defaults to "medium" -- derived from critique severity when brief_for exists). The existing get_research() function in compile-context.sh (lines 99-105) currently extracts `.q // .query` and `.finding` only. It must be updated to also extract `.brief_for // ""` and `.conf // ""` when present but with fallback to empty. Existing standalone /yolo:research output continues to work because all new fields default gracefully. The jq expression uses the // (alternative) operator throughout.

D5: Scout model resolution in Pre-Execution loop [C13]
The Pre-Execution model resolution loop (execute-protocol.md line 22) currently iterates: critic architect lead senior tester dev qa qa-code security. Scout is MISSING. Add "scout" to this loop so SCOUT_MODEL is resolved before the research step executes. The updated loop becomes: `for role in critic scout architect lead senior tester dev qa qa-code security; do`. Scout is placed after critic (since critique runs first, then research) and before architect. This ensures the model is resolved before it is needed.

D6: 11-step workflow label update across all files [C11]
All references to "10-step" across the codebase must be updated to "11-step". The grep identifies 15 files containing "10-step": execute-protocol.md, go.md, CLAUDE.md, agents/yolo-lead.md, agents/yolo-ux-lead.md, agents/yolo-fe-lead.md, references/handoff-schemas.md, references/teammate-api-patterns.md, references/cross-team-protocol.md, references/company-hierarchy.md, references/multi-dept-protocol.md, and 4 department TOON files. Plan 02-01 T1 handles execute-protocol.md directly. All other files are handled as part of T4 scope (company-hierarchy.md) and as a grep-and-replace sweep in T1. The update is mechanical: "10-step" to "11-step", "10-Step" to "11-Step", "10 steps" to "11 steps".

D7: Scout context enrichment with severity-filtered critique [C10]
The scout case in compile-context.sh (lines 657-665) currently emits only: header, requirements, reference_package, tool_restrictions. It must be enriched with: (1) critique.jsonl findings filtered to critical and major severity only (not minor -- prevents budget overflow on Scout's 1000-token limit), (2) codebase mapping references (INDEX.md, ARCHITECTURE.md). The critique filtering uses jq: `jq -r 'select(.sev == "critical" or .sev == "major") | "  C\(.id // ""): \(.q)"'`. This delivers targeted research directives without exceeding Scout's token budget. Full critique.jsonl is NOT passed to Scout.

D8: 26 agents map to 11 base roles via prefix stripping [C3]
The 26 agents across 4 departments map to exactly 11 base roles: architect, lead, senior, dev, tester, qa, qa-code, security, scout, debugger, owner. The fe-/ux- prefix stripping (already implemented in compile-context.sh lines 25-29) is the canonical mapping mechanism. The filter-agent-context.sh script accepts the full role name (e.g., "fe-dev") and strips the prefix to determine the base role for field mapping lookup. The agent-field-map.md documents all 11 base roles (not 26 agents). Owner and Debugger were missing from the initial plan scope -- they are now included. Owner needs: plan.jsonl header (all fields), summary (s, fm, dv), department results. Debugger needs: research.jsonl (q, finding), gaps.jsonl (all fields), summary (fm, ch, dv). The success criteria for "all 26 agents" is satisfied by covering all 11 base roles, since department variants use identical field mappings.

D9: Token measurement as character-count approximation [C4]
The char/4 proxy for token estimation is an approximation. It is well-documented in compile-context.sh (line 206 comment: "chars/4 = tokens") and in the enforce_budget function. The --measure flag added by plan 02-04 T5 outputs character counts and character-based reduction percentages. The success criteria for "measurable token reduction" is framed as: "filtered character count < unfiltered character count by at least 15% for dev, qa, and security roles". The output JSON from --measure includes: role, filtered_chars, unfiltered_chars, reduction_pct, note:"char/4 approx". This is explicitly documented as an approximation, not a precise token count. Precise tokenization would require a tokenizer dependency which violates the zero-dependency design constraint.

D10: Graceful degradation for filter-agent-context.sh dependency [C7]
compile-context.sh gains a runtime dependency on filter-agent-context.sh when including JSONL artifacts. If the filter script is missing (e.g., pre-phase-2 installations, partial upgrades), compile-context.sh MUST fall back to current inline jq extraction. The guard pattern follows resolve-tool-permissions.sh precedent (compile-context.sh lines 165-178): check if script exists and is executable, if not, fall back to current behavior silently. Implementation pattern:
```
FILTER_SCRIPT="${CLAUDE_PLUGIN_ROOT:-$(cd "$(dirname "$0")" && pwd)/..}/scripts/filter-agent-context.sh"
if [ -x "$FILTER_SCRIPT" ]; then
  # Use filter-agent-context.sh for field-level filtering
  bash "$FILTER_SCRIPT" --role "$BASE_ROLE" --artifact "$artifact" --type "$type"
else
  # Graceful degradation: fall back to current inline jq (pre-phase-2 compat)
  jq -r '...' "$artifact"
fi
```
This ensures zero breakage for existing installations. The filter is an optimization, not a hard requirement.

D11: JSONL header vs task detection via positional convention [C9]
Plan JSONL files use a fixed convention: line 1 is always the header (contains p, n, t, w, d fields), lines 2+ are always tasks (contain id, tp, a fields). filter-agent-context.sh uses `head -1` for header extraction and `tail -n +2` for task extraction. This matches the existing pattern in compile-context.sh (lines 416-419 for dev case, lines 526-529 for tester case). No heuristic detection is needed because the format is structurally fixed. The script does NOT attempt to auto-detect header vs task lines by inspecting field names -- it relies on line position. This is documented in artifact-formats.md ("Plan Header (line 1)" and "Plan Task (lines 2+)") and enforced by validate-plan.sh.

D12: Excluded artifact types in agent-field-map.md [C8]
The agent-field-map.md covers 10 primary artifact types that flow through the compile-context.sh pipeline: plan.jsonl, summary.jsonl, critique.jsonl, research.jsonl, code-review.jsonl, verification.jsonl, qa-code.jsonl, security-audit.jsonl, test-plan.jsonl, gaps.jsonl. Excluded artifact types with rationale documented in agent-field-map.md:
- decisions.jsonl: Append-only log, read by Architect only (no filtering needed -- Architect reads all fields)
- manual-qa.jsonl: Written and read by Lead only (single consumer, no filtering benefit)
- design-tokens.jsonl: UX department artifact, read as-is by fe-senior and fe-dev (cross-dept handoff, filtering handled by department guard)
- component-specs.jsonl: UX department artifact, same rationale as design-tokens.jsonl
- user-flows.jsonl: UX department artifact, same rationale
- design-handoff.jsonl: Cross-department handoff artifact, read as-is by consuming department Lead
- api-contracts.jsonl: Cross-department negotiation artifact, read as-is by both FE and BE Leads
- state.json: Runtime state, read by go.md orchestrator only (not an agent context input)
- .execution-state.json: Runtime state, same rationale as state.json
The exclusion rationale is: single-consumer artifacts, cross-department handoff artifacts (already isolated by department guard), and runtime state files (not agent context) do not benefit from per-field filtering.

D13: Research step entry in .execution-state.json schema
The .execution-state.json schema (execute-protocol.md Step 3, item 7) must add a "research" entry to the "steps" object, positioned between "critique" and "architecture":
```json
"steps": {
  "critique": {...},
  "research": {"status": "pending", "started_at": "", "completed_at": "", "artifact": "", "reason": ""},
  "architecture": {...},
  ...
}
```
The state.json "step" field valid values (artifact-formats.md line 189) must also add "research" to the union: "critique"|"research"|"architecture"|"planning"|"design_review"|"test_authoring"|"implementation"|"code_review"|"qa"|"security"|"signoff". The generate-execution-state.sh script must include this key. The validate-gates.sh lookup table must add the research step entry/exit gates.


## Critique Responses

C1: addressed (D1) -- Display-only renumbering. State keys remain string-based. "research" key added to .execution-state.json. Mandatory vs Skippable rewritten with state key names.

C2: addressed (D2) -- Orchestrator writes research.jsonl from Scout's returned findings. Mirrors Critic pattern. Explicit in execute-protocol.md Step 2 text.

C3: addressed (D8) -- 26 agents map to 11 base roles via fe-/ux- prefix stripping. Owner and Debugger added. Success criteria clarified as "all 11 base roles covered".

C4: addressed (D9) -- char/4 documented as approximation. Success criteria framed as character reduction percentage. --measure outputs explicit "char/4 approx" note.

C5: addressed (D4) -- New fields (brief_for, mode, priority) are optional with jq // defaults. get_research() updated to extract new fields with fallback. Backward compatible with standalone /yolo:research output.

C6: addressed (D3) -- Append mode for post-Critic research. Skip guard is turbo-only, NOT file-existence. Pre-Critic and post-Critic entries coexist via mode field.

C7: addressed (D10) -- Graceful degradation guard follows resolve-tool-permissions.sh pattern. Missing filter script falls back to current inline jq. Zero breakage guarantee.

C8: addressed (D12) -- 7 excluded artifact types documented with rationale in agent-field-map.md. Exclusion categories: single-consumer, cross-dept handoff, runtime state.

C9: addressed (D11) -- head -1 for header, tail -n +2 for tasks. Matches compile-context.sh existing pattern. Positional convention, not heuristic detection.

C10: addressed (D7) -- Scout context enriched with critical/major critique findings only. Minor findings excluded to respect 1000-token budget. jq select filter on sev field.

C11: addressed (D6) -- Mechanical grep-and-replace of "10-step" to "11-step" across 15 files. Covered by plan 02-01 T1 and T4.

C12: addressed (D1) -- Mandatory vs Skippable section rewritten with state key names. Research step included as skippable (turbo or exists is replaced by turbo-only per D3).

C13: addressed (D5) -- Scout added to Pre-Execution model resolution loop. Position: after critic, before architect. SCOUT_MODEL resolved before research step.


## Component Design

### execute-protocol.md Research Step (Step 2, NEW)

Position: Between Step 1 (Critique) and renamed Step 3 (Architecture, formerly Step 2)
State key: "research"
Guard: Skip if --effort=turbo. Note: file existence does NOT trigger skip (D3).

Entry gate: critique.jsonl exists OR steps.critique.status is "skipped" in .execution-state.json. (Same gate as current Architecture step.)

Protocol:
1. Compile context: `bash ${CLAUDE_PLUGIN_ROOT}/scripts/compile-context.sh {phase} scout {phases_dir}`
2. Spawn yolo-scout with Task tool:
   - model: "${SCOUT_MODEL}"
   - Provide: critique.jsonl findings (critical/major only per D7), reqs.jsonl, codebase/ mapping
   - Include compiled context: {phase-dir}/.ctx-scout.toon
   - Research directives: For each critical/major critique finding, research best practices and solutions
3. Display: "Spawning Scout (${SCOUT_MODEL})..." -> "Research complete"
4. Scout returns findings (structured output or scout_findings schema)
5. Write research.jsonl from Scout's findings to phase directory (APPEND if file exists per D3)
6. Commit: `docs({phase}): research findings`

Exit gate: research.jsonl exists (valid JSONL). State: steps.research = complete.
Skip output: steps.research.status = "skipped", reason = "turbo effort".

Context scoping table row:
| 2 | Scout | critique.jsonl (critical/major), reqs.jsonl, codebase/ mapping, .ctx-scout.toon | plans, architecture, implementation code, QA artifacts, department CONTEXT |

Execution state transitions table row:
| 2. Research | research | critique.jsonl OR step 1 skipped | research.jsonl | docs({phase}): research findings | --effort=turbo |

### compile-context.sh scout case enhancement

Current (lines 657-665):
  emit_header, get_requirements, reference_package, tool_restrictions

Enhanced:
  emit_header, get_requirements, critique findings (filtered), codebase mapping refs, reference_package, tool_restrictions

New critique section in scout case:
```
if [ -f "$PHASE_DIR/critique.jsonl" ]; then
  echo "research_directives:"
  jq -r 'select(.sev == "critical" or .sev == "major") | "  \(.id): \(.q)"' "$PHASE_DIR/critique.jsonl" 2>/dev/null || true
fi
```

Budget consideration: Scout budget is 1000 tokens. Critique findings are filtered to critical/major only. Each finding line is ~80 chars (~20 tokens). At 10 findings = 200 tokens, well within budget.

### compile-context.sh get_research() update

Current (lines 99-105):
```
jq -r 'select((.q // .query // empty) != "" and (.finding // empty) != "") | "  - \(.q // .query): \(.finding)"'
```

Updated:
```
jq -r 'select((.q // .query // empty) != "" and (.finding // empty) != "") | "  - \(.q // .query): \(.finding) [\(.conf // "")]" + if (.brief_for // "") != "" then " (ref:\(.brief_for))" else "" end'
```

This adds confidence level and critique cross-reference when present, using jq // for backward compat.

### filter-agent-context.sh (NEW SCRIPT)

Interface:
  filter-agent-context.sh --role=ROLE --artifact=PATH --type=TYPE
  ROLE: one of the 11 base roles (or 26 full roles -- prefix is stripped internally)
  PATH: path to JSONL artifact file
  TYPE: plan|summary|critique|research|code-review|verification|qa-code|security-audit|test-plan|gaps
  Output: Filtered JSONL to stdout
  Exit: 0=success, 1=error (unknown role, missing file)

Internal architecture:
1. Parse args, strip role prefix (fe-dev -> dev, ux-architect -> architect)
2. Detect header vs tasks for plan type: head -1 for header, tail -n +2 for tasks
3. Lookup field list from internal associative array (or case statement) keyed by "${BASE_ROLE}_${TYPE}"
4. Apply jq field projection: `jq '{(.field1), (.field2), ...}'` with // fallback for optional fields
5. Output filtered JSONL lines to stdout

Field mapping source: references/agent-field-map.md (documented) and script internal mapping (implemented).

### agent-field-map.md (NEW REFERENCE)

Structure:
  Header: Purpose, mapping convention (26 agents -> 11 base roles)
  Section per base role: table of artifact type x required fields
  Section: Excluded artifacts with rationale (D12)
  Section: Prefix stripping convention (fe-/ux- -> base role)

Coverage: 11 base roles x 10 artifact types = 110 cells. Many are "N/A" (agent does not consume that artifact type). Populated cells document exact jq field projections.

### company-hierarchy.md 11-Step Workflow table

Updated table inserts Scout research row as Step 2:
| 2 | Scout | critique + reqs + codebase | research.jsonl | `docs({phase}): research findings` | turbo |

All subsequent rows renumbered (Architecture -> 3, Load Plans -> 4, etc. through Sign-off -> 11).


## Risk Mitigations

R1: execute-protocol.md step renumbering touches many cross-references (other steps reference "Step N") -- Mitigation: Use state key names in cross-references where possible. Entry gate references use "steps.{key}.status" not "Step N". Display labels are secondary. T1 must do a thorough cross-reference sweep within execute-protocol.md.

R2: Pre-Critic and post-Critic research entries in same file could confuse consumers -- Mitigation: mode field distinguishes origin. Architect reads all entries and prioritizes by confidence + brief_for linkage. get_research() renders both modes identically (both are useful context).

R3: filter-agent-context.sh field mapping gets out of sync with actual JSONL schemas -- Mitigation: (1) agent-field-map.md is the documented source of truth, (2) bats tests verify specific field inclusions/exclusions, (3) field projections use jq // fallback so missing fields degrade gracefully rather than error.

R4: compile-context.sh integration with filter script could break existing context compilation -- Mitigation: Graceful degradation (D10). If filter script is absent, current behavior is unchanged. Integration tests in compile-context.bats verify both paths (with and without filter script).

R5: 15-file "10-step" to "11-step" update is error-prone -- Mitigation: Mechanical grep-and-replace. Each file has 1-3 occurrences. T1/T4 verify with `grep -c "10-step"` after changes (count should be 0 in modified files).


## Dependency Graph

Plan 02-01 (wave 1): Research flow in execute-protocol.md + compile-context.sh scout case
Plan 02-02 (wave 1): Research artifact format + Scout/Critic/Architect agent updates
  -- 02-01 and 02-02 are parallel, no dependency between them
Plan 02-03 (wave 2): agent-field-map.md + filter-agent-context.sh + bats tests
  -- depends on 02-01 (Scout context fields defined) and 02-02 (research.jsonl schema finalized)
Plan 02-04 (wave 3): Integrate filter into compile-context.sh + --measure flag
  -- depends on 02-03 (filter script exists)


## Open Questions (for Lead)

Q1: Should the research step have a user confirmation gate (like critique at balanced/thorough effort)? Decision recommendation: No. Research findings are informational, not blocking. Architect consumes them without user review. This keeps the flow efficient.

Q2: Should filter-agent-context.sh support a --dry-run mode that shows which fields would be kept/dropped? Decision recommendation: Defer. The --measure flag on compile-context.sh provides the observable output. A per-artifact dry-run adds complexity without clear immediate value.
