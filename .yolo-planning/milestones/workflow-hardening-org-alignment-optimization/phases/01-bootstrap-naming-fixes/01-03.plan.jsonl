{"p":"01","n":"03","t":"Create naming validation script","w":2,"d":["01-02"],"mh":{"tr":["validate-naming.sh catches p field containing compound IDs like '01-01'","validate-naming.sh catches n field containing title strings instead of numbers","validate-naming.sh catches task lines missing tp field","validate-naming.sh catches summary files using legacy keys (commits instead of ch)","validate-naming.sh exits non-zero on any naming violation"],"ar":[{"p":"scripts/validate-naming.sh","pv":"script exists, is executable, validates plan and summary naming","c":"bash scripts/validate-naming.sh on canonical plan returns valid:true"},{"p":"tests/unit/validate-naming.bats","pv":"test file exists with tests for both valid and invalid naming","c":"bats tests/unit/validate-naming.bats passes all tests"}],"kl":[{"fr":"scripts/validate-naming.sh","to":"references/naming-conventions.md","vi":"validate-naming.sh enforces patterns documented in naming-conventions.md"},{"fr":"scripts/validate-naming.sh","to":"scripts/validate-plan.sh","vi":"validate-naming.sh complements validate-plan.sh (structural vs naming validation)"}]},"obj":"Create a naming validation script that catches all naming inconsistencies found in the audit, integrated with existing validation tooling (REQ-02 enforcement)","sk":["commit"],"fm":["scripts/validate-naming.sh","tests/unit/validate-naming.bats"]}
{"id":"T1","tp":"auto","a":"Create scripts/validate-naming.sh that validates artifact naming conventions: (1) plan.jsonl header p field is phase-only number string, (2) header n field is plan-only number string, (3) task lines have canonical keys (id, tp, a, f, v, done), (4) file name matches {NN-MM}.plan.jsonl pattern where NN matches header p and MM matches header n. Output JSON {valid:bool,errors:[]}. Uses jq, set -euo pipefail. REQ-02 enforcement.","f":["scripts/validate-naming.sh"],"v":"Script returns valid:true for canonical plan, valid:false with specific errors for plans with compound p field or title in n field","done":"validate-naming.sh exists, executable, validates plan naming conventions","spec":"Create scripts/validate-naming.sh. Shebang: #!/usr/bin/env bash. set -euo pipefail.\n\n--- jq dependency check ---\nSame pattern as validate-plan.sh lines 14-17: if ! command -v jq &>/dev/null; then echo JSON error to stderr; exit 1; fi.\n\n--- Arg parsing ---\nAccept: validate-naming.sh <file-or-dir> [--scope=active|all] [--type=plan|summary] [--turbo]\nIf no args: echo Usage to stderr, exit 1.\nParse flags with for-in loop over \"$@\": case \"$arg\" in --scope=*) SCOPE=\"${arg#--scope=}\";; --type=*) TYPE_OVERRIDE=\"${arg#--type=}\";; --turbo) TURBO=true;; *) TARGET=\"$arg\";; esac.\nDefaults: SCOPE=active, TURBO=false, TYPE_OVERRIDE=\"\".\n\n--- Global state ---\nERRORS=() WARNINGS=() VALID=true (same pattern as validate-plan.sh line 34-35).\n\n--- add_error helper ---\nadd_error() { ERRORS+=(\"$1\"); VALID=false; }\nadd_warning() { WARNINGS+=(\"$1\"); }\n\n--- detect_type function ---\ndetect_type(file): extract basename. Case pattern matching:\n  *.plan.jsonl) echo plan;; *.summary.jsonl) echo summary;; reqs.jsonl) echo reqs;; critique.jsonl) echo critique;; decisions.jsonl) echo decisions;; code-review.jsonl) echo code-review;; *) echo unknown;;\nIf TYPE_OVERRIDE is set, use that instead.\n\n--- validate_plan_naming function ---\nInput: file path. Reads line 1 as header via head -1.\n(1) p field: extract via jq -r '.p // empty'. Check with regex ^[0-9]{2}$ (zero-padded phase only). If matches compound like '01-01' (contains '-'): add_error \"Header p field is compound '$p_val' -- must be phase-only (e.g. '01')\".\n(2) n field: extract via jq -r '.n // empty'. Check with regex ^[0-9]{2}$ (zero-padded plan number only). If contains non-digits or is longer than 2 chars: add_error \"Header n field '$n_val' is not a plan number -- must be zero-padded number (e.g. '03')\".\n(3) t field: extract via jq -r '.t // empty'. Verify it is NOT a number (digits only). If [[ \"$t_val\" =~ ^[0-9]+$ ]]: add_error \"Header t field is a number '$t_val' -- must be title string\".\n(4) Turbo detection (C7): auto_turbo=false. Check header for eff field: eff_val=$(echo \"$header\" | jq -r '.eff // empty'). If eff_val=turbo OR (mh key missing from header): auto_turbo=true. If TURBO flag is set OR auto_turbo is true: skip mh validation. Otherwise verify mh key exists and is object.\n(5) File name vs header consistency: extract NN and MM from filename using basename + sed 's/\\.plan\\.jsonl$//; s/-/ /'. Compare NN with p field, MM with n field. Mismatch: add_error \"File name NN-MM does not match header p='$p_val' n='$n_val'\".\n(6) Task lines: read lines 2+ via tail -n +2. For each task line:\n  - If TURBO or auto_turbo: required keys = id a f v done (no tp required per C7).\n  - Else: required keys = id tp a f v done.\n  - For each required key: check with jq has($k). Missing: add_error \"Task $task_id: missing required key: $key\".\n  - Check for legacy keys presence: if has(\"n\") and NOT has(\"a\"): add_error \"Task $task_id: uses legacy key 'n' instead of 'a'\". Same for 'd' vs redundant, 'ac' vs 'v'.\n  - Check no absolute paths in f: same pattern as validate-plan.sh lines 174-183.\n\n--- validate_summary_naming function ---\nInput: file path. Read full file (single line expected for canonical).\n(1) Required keys per artifact-formats.md section 4 of naming-conventions.md: p n t s dt tc tt ch fm dv built tst. For each: jq has($k), missing: add_error \"Summary missing required key: $key\".\n(2) Legacy key detection: check for keys 'commits' (should be ch), 'tasks' (should be tc), 'dev' (should be dv), 'sum' (not canonical). If found: add_error \"Summary uses legacy key '$key' -- use '$canonical' instead\".\n(3) p field format: same check as plan (phase-only, no compound).\n(4) Valid enum values: s must be in (complete, partial, failed). tst must be in (red_green, green_only, no_tests). If present and not valid: add_error.\n(5) File name consistency: same as plan -- extract NN-MM from filename, compare to header p and n.\n\n--- validate_reqs_naming function ---\nInput: file path. Read each line.\n(1) Required keys: id t pri. Missing: add_error.\n(2) Legacy key detection: has('p') but not has('pri'): add_error \"Reqs uses legacy key 'p' -- use 'pri'\". has('d') but not has('ac'): add_error \"Reqs uses legacy key 'd' -- use 'ac'\".\n(3) Valid enum: pri in (must, should, nice). st in (open, done).\n\n--- scope-aware directory scanning ---\nIf TARGET is a directory:\n  files=() -- collect files.\n  If SCOPE=active or SCOPE=all: find TARGET -name '*.plan.jsonl' -o -name '*.summary.jsonl' -o -name 'reqs.jsonl' etc.\n  If SCOPE=all AND .yolo-planning/milestones/ exists: also scan milestones. For milestones files, use add_warning instead of add_error (C3: archived milestones are non-blocking warnings).\nIf TARGET is a single file: validate that single file with detect_type.\n\n--- Main flow ---\nIf TARGET is file: type=$(detect_type \"$TARGET\"); case $type in plan) validate_plan_naming \"$TARGET\";; summary) validate_summary_naming \"$TARGET\";; reqs) validate_reqs_naming \"$TARGET\";; *) add_warning \"Unknown artifact type for $TARGET\";; esac.\nIf TARGET is directory: iterate collected files, validate each.\n\n--- Output (JSON) ---\nSame pattern as validate-plan.sh lines 266-272:\nif [ ${#ERRORS[@]} -eq 0 ]; then jq -n '{\"valid\":true,\"errors\":[],\"warnings\":[]}' (include warnings array); exit 0;\nelse printf '%s\\n' \"${ERRORS[@]}\" | jq -R . | jq -s --argjson w \"$(printf '%s\\n' \"${WARNINGS[@]:-}\" | jq -R . | jq -s .)\" '{\"valid\":false,\"errors\":.  ,\"warnings\":$w}'; exit 1; fi.\nHandle empty WARNINGS array: if [ ${#WARNINGS[@]} -eq 0 ]; then warnings_json='[]'; else warnings_json=$(printf '%s\\n' \"${WARNINGS[@]}\" | jq -R . | jq -s .); fi.\n\nFile must be chmod +x. Total: ~200-250 lines.","ts":"Test file: tests/unit/validate-naming.bats. Framework: bats-core with bats-support, bats-assert, bats-file.\nSetup: load '../test_helper/common' and '../test_helper/fixtures'. mk_test_workdir. SUT=\"$SCRIPTS_DIR/validate-naming.sh\".\n\nTests for T1 scope (plan validation):\n(1) 'valid canonical plan passes naming validation' -- create file with header {\"p\":\"03\",\"n\":\"01\",\"t\":\"Test Plan\",...} and canonical tasks {\"id\":\"T1\",\"tp\":\"auto\",\"a\":\"...\",\"f\":[...],\"v\":\"...\",\"done\":\"...\"}. Name file 03-01.plan.jsonl. run bash \"$SUT\" \"$file\". assert_success. jq '.valid' == true.\n(2) 'plan with compound p field fails' -- header {\"p\":\"01-01\",...}. File 01-01.plan.jsonl. run bash \"$SUT\". assert_failure. assert_output --partial 'compound'.\n(3) 'plan with title string in n field fails' -- header {\"n\":\"Create auth\",...}. assert_failure. assert_output --partial 'not a plan number'.\n(4) 'plan with number in t field fails' -- header {\"t\":3,...} (number not string). assert_failure. assert_output --partial 'must be title string'.\n(5) 'plan task missing tp key fails' -- task line without tp. assert_failure. assert_output --partial 'missing required key: tp'.\n(6) 'plan task using legacy key n instead of a fails' -- task with {\"n\":\"action\"} but no \"a\". assert_failure. assert_output --partial 'legacy key'.\n(7) 'file name vs header mismatch detected' -- file named 02-01.plan.jsonl but header has p:\"03\" n:\"01\". assert_failure. assert_output --partial 'does not match'.\n(8) 'turbo plan without mh passes' -- header with eff:\"turbo\" and no mh key. Tasks without tp. run bash \"$SUT\" \"$file\" --turbo. assert_success.\n(9) 'turbo auto-detection works when eff:turbo in header' -- same as (8) but without --turbo flag. assert_success (auto-detected).\n(10) 'absolute path in task f field fails' -- task with f:[\"/usr/local/bin/foo\"]. assert_failure. assert_output --partial 'absolute path'."}
{"id":"T2","tp":"auto","a":"Extend validate-naming.sh to also validate summary.jsonl naming: (1) required keys per artifact-formats.md (p, n, t, s, dt, tc, tt, ch, fm, dv, built, tst), (2) no legacy keys (commits, tasks, dev), (3) file name matches {NN-MM}.summary.jsonl pattern. Accept --type plan|summary flag or auto-detect from file extension. REQ-02 enforcement.","f":["scripts/validate-naming.sh"],"v":"Script validates summary files, catches legacy key names","done":"validate-naming.sh validates both plan and summary naming conventions","spec":"Extend scripts/validate-naming.sh (created in T1) by adding the validate_summary_naming function and extending detect_type.\n\n--- validate_summary_naming function ---\nInput: file path.\n(1) Read file content: content=$(cat \"$file\"). Verify valid JSON: echo \"$content\" | jq empty 2>/dev/null || { add_error \"$file: invalid JSON\"; return; }.\n(2) Required keys check (12 keys): iterate over 'p n t s dt tc tt ch fm dv built tst'. For each: echo \"$content\" | jq --arg k \"$key\" 'has($k)' => if not true: add_error \"Summary $file: missing required key: $key\".\n(3) Legacy key detection -- check for 4 known legacy keys:\n  - has('commits'): add_error \"Summary uses legacy key 'commits' -- use 'ch' (commit hashes)\"\n  - has('tasks'): add_error \"Summary uses legacy key 'tasks' -- use 'tc' (tasks completed)\"\n  - has('dev'): add_error \"Summary uses legacy key 'dev' -- use 'dv' (deviations)\"\n  - has('sum'): add_error \"Summary uses legacy key 'sum' -- not canonical (remove)\"\n(4) p field format validation: p_val=$(echo \"$content\" | jq -r '.p // empty'). Same regex as plan: must match ^[0-9]{2}$. Compound like '01-01': add_error.\n(5) n field format validation: same pattern, must be zero-padded number string.\n(6) Enum validation for s field: s_val=$(echo \"$content\" | jq -r '.s // empty'). If non-empty, must be one of: complete, partial, failed. Else: add_error \"Summary s field '$s_val' not valid -- must be complete|partial|failed\".\n(7) Enum validation for tst field: tst_val=$(echo \"$content\" | jq -r '.tst // empty'). If non-empty, must be one of: red_green, green_only, no_tests. Note: 'manual' is NOT valid per naming-conventions.md section 4 and artifact-formats.md. If invalid: add_error \"Summary tst field '$tst_val' not valid -- must be red_green|green_only|no_tests\".\n(8) File name consistency: basename=\"$(basename \"$file\")\". Extract NN-MM from basename by stripping .summary.jsonl suffix. Split on '-' to get NN and MM. Compare NN to header p, MM to header n. Mismatch: add_error.\n(9) Multi-line check: line_count=$(wc -l < \"$file\" | tr -d ' '). If line_count > 1: add_warning \"Summary $file has $line_count lines -- canonical is single-line JSONL\" (warning not error, since performance-opt milestone had multi-line).\n\n--- Update detect_type ---\nAdd: *.summary.jsonl) echo summary;; to the case statement (already specified in T1 spec but verify it is present).\n\n--- Update --type flag ---\nEnsure --type=summary works as override: if TYPE_OVERRIDE is 'summary', call validate_summary_naming regardless of filename.\n\n--- Extend validate_reqs_naming ---\nAlso add validate_reqs_naming function (from T1 spec architecture requirements -- reqs.jsonl validation per C2/D6):\nInput: file path. Read each line. Required keys: id t pri. Legacy detection: has('p') without has('pri') => error. has('d') without has('ac') => error. Enum: pri in (must,should,nice), st in (open,done) if present.\n\nThis task modifies the same file as T1. The function bodies are additive (no conflicts with T1 code).","ts":"Test file: tests/unit/validate-naming.bats (same file as T1, append tests).\n\nTests for T2 scope (summary + reqs validation):\n(11) 'valid canonical summary passes' -- create file 01-01.summary.jsonl with all 12 required keys {\"p\":\"01\",\"n\":\"01\",\"t\":\"Test\",\"s\":\"complete\",\"dt\":\"2026-02-17\",\"tc\":3,\"tt\":3,\"ch\":[\"abc123\"],\"fm\":[\"src/test.sh\"],\"dv\":[],\"built\":[\"test feature\"],\"tst\":\"red_green\"}. run bash \"$SUT\" \"$file\". assert_success.\n(12) 'summary with legacy commits key fails' -- include 'commits' key instead of 'ch'. assert_failure. assert_output --partial \"legacy key 'commits'\".\n(13) 'summary with legacy tasks key fails' -- include 'tasks' key instead of 'tc'. assert_failure. assert_output --partial \"legacy key 'tasks'\".\n(14) 'summary with legacy dev key fails' -- include 'dev' key instead of 'dv'. assert_failure. assert_output --partial \"legacy key 'dev'\".\n(15) 'summary missing required key dt fails' -- omit dt from JSON. assert_failure. assert_output --partial 'missing required key: dt'.\n(16) 'summary with invalid tst enum fails' -- tst:\"manual\". assert_failure. assert_output --partial 'not valid'.\n(17) 'summary with compound p field fails' -- p:\"01-01\". assert_failure. assert_output --partial 'compound'.\n(18) 'summary file name mismatch detected' -- file named 02-01.summary.jsonl but header p:\"01\". assert_failure. assert_output --partial 'does not match'.\n(19) 'reqs with legacy p key instead of pri fails' -- reqs.jsonl with {\"id\":\"REQ-01\",\"t\":\"test\",\"p\":\"must\"}. run bash \"$SUT\" \"$file\" --type=reqs. assert_failure. assert_output --partial \"legacy key 'p'\".\n(20) 'valid reqs passes' -- {\"id\":\"REQ-01\",\"t\":\"test\",\"pri\":\"must\",\"st\":\"open\",\"ac\":\"criteria\"}. assert_success."}
{"id":"T3","tp":"auto","a":"Write tests/unit/validate-naming.bats: (1) valid canonical plan passes, (2) plan with compound p field fails, (3) plan with title in n field fails, (4) plan with missing tp in task fails, (5) valid summary passes, (6) summary with legacy 'commits' key fails, (7) file name mismatch between name and header detected. REQ-02 verification.","f":["tests/unit/validate-naming.bats"],"v":"bats tests/unit/validate-naming.bats passes all 7+ test cases","done":"Naming validation tests written and passing","spec":"Create tests/unit/validate-naming.bats. This file contains ALL tests specified across T1 ts and T2 ts fields (tests 1-20), plus additional tests for C3 (scope), C7 (turbo), and C8 (drift detection).\n\n--- File header ---\n#!/usr/bin/env bats\n# validate-naming.bats -- Unit tests for scripts/validate-naming.sh\n# Validates artifact naming conventions: plan headers, task keys, summaries, reqs.\n\n--- setup function ---\nsetup() {\n  load '../test_helper/common'\n  load '../test_helper/fixtures'\n  mk_test_workdir\n  SUT=\"$SCRIPTS_DIR/validate-naming.sh\"\n}\n\n--- Helper: mk_valid_named_plan ---\nCreates a canonical plan file at given path:\nmk_valid_named_plan() {\n  local file=\"$1\"\n  cat > \"$file\" <<'JSONL'\n{\"p\":\"03\",\"n\":\"01\",\"t\":\"Test Plan\",\"w\":1,\"d\":[],\"mh\":{\"tr\":[\"test\"],\"ar\":[],\"kl\":[]},\"obj\":\"Test objective\"}\n{\"id\":\"T1\",\"tp\":\"auto\",\"a\":\"Create file\",\"f\":[\"src/test.sh\"],\"v\":\"file exists\",\"done\":\"Created\"}\nJSONL\n}\n\n--- Helper: mk_valid_summary ---\nmk_valid_summary() {\n  local file=\"$1\"\n  echo '{\"p\":\"01\",\"n\":\"01\",\"t\":\"Test\",\"s\":\"complete\",\"dt\":\"2026-02-17\",\"tc\":3,\"tt\":3,\"ch\":[\"abc123\"],\"fm\":[\"src/a.sh\"],\"dv\":[],\"built\":[\"feature\"],\"tst\":\"red_green\"}' > \"$file\"\n}\n\n--- Helper: mk_turbo_plan ---\nmk_turbo_plan() {\n  local file=\"$1\"\n  cat > \"$file\" <<'JSONL'\n{\"p\":\"01\",\"n\":\"01\",\"t\":\"Quick fix\",\"w\":1,\"d\":[],\"obj\":\"Fix bug\",\"eff\":\"turbo\"}\n{\"id\":\"T1\",\"a\":\"Fix the bug\",\"f\":[\"src/fix.sh\"],\"v\":\"bug gone\",\"done\":\"Fixed\"}\nJSONL\n}\n\n--- Test cases (write all 20+ from T1/T2 ts fields) ---\nInclude all tests numbered 1-20 from T1 ts and T2 ts. PLUS:\n\n(21) 'directory mode validates all plan files' -- create dir with 2 plan files (one valid, one with compound p). Run on directory. assert_failure (at least one error).\n(22) '--scope=active skips milestones directory' -- create .yolo-planning/milestones/old/01-old/01-01.plan.jsonl with legacy naming. Run with --scope=active. assert_success (milestones not scanned).\n(23) '--scope=all includes milestones as warnings' -- same files, run with --scope=all. assert_success (warnings not errors per C3). assert_output --partial 'warning' OR check warnings array in JSON output.\n(24) 'drift detection: every naming-conventions.md section has corresponding validation' (C8) -- this is a meta-test. Read references/naming-conventions.md, extract section headers (## N. Title), verify validate-naming.sh has a function or check for each documented pattern category. Implementation: extract section numbers from naming-conventions.md via grep '^## [0-9]', count them. Grep validate-naming.sh for validate_ functions, count them. Assert function count >= section count (minus anti-patterns section which is documentation-only, and minus cross-department section 7 and state section 8 which are future scope). Minimum: sections 2 (plan header), 3 (plan task), 4 (summary), 5 (reqs) must each have a corresponding validate_ function.\n(25) '--type flag overrides auto-detection' -- create a file named 'custom.jsonl' with plan content. Run with --type=plan. assert_success.\n(26) 'unknown file type produces warning not error' -- create random.jsonl. Run without --type. assert_success (warning about unknown type, but valid=true since no errors).\n\nTotal: 26 test cases. Each test follows validate-plan.bats pattern: create fixture file in TEST_WORKDIR, run bash \"$SUT\" \"$file\", assert_success/assert_failure, check output JSON or partial string.\n\nCRITICAL: Tests must be written BEFORE T1 and T2 implementation to verify they all FAIL (RED). Dev executes T3 first or concurrently, but tests must initially fail against a non-existent script.","ts":""}
{"id":"T4","tp":"auto","a":"Update validate-plan.sh to call validate-naming.sh as additional check: after existing structural validation, run naming validation and merge errors. Backward compatible -- naming errors are appended to existing error array. REQ-02 integration.","f":["scripts/validate-plan.sh","references/execute-protocol.md"],"v":"validate-plan.sh catches naming violations that were previously invisible; existing tests still pass","done":"validate-plan.sh integrates naming validation, execute-protocol.md wires validate-naming.sh into Step 3","spec":"Modify scripts/validate-plan.sh to call validate-naming.sh after structural validation. Also update references/execute-protocol.md to wire validate-naming.sh into the pre-execution validation loop (C12).\n\n--- validate-plan.sh changes ---\nFile: scripts/validate-plan.sh.\n\n(1) After line 263 (after validate_no_circular_deps call, before the --- Output --- section), add a new function call: validate_naming_conventions.\n\n(2) Define validate_naming_conventions function (add before --- Main flow --- section, around line 258):\n\nvalidate_naming_conventions() {\n  # Locate validate-naming.sh relative to this script\n  local script_dir\n  script_dir=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n  local naming_script=\"$script_dir/validate-naming.sh\"\n\n  # Skip if validate-naming.sh does not exist (backward compatible)\n  if [ ! -x \"$naming_script\" ]; then\n    return\n  fi\n\n  # Run naming validation on the plan file\n  local naming_result\n  naming_result=$(bash \"$naming_script\" \"$PLAN_FILE\" --type=plan 2>/dev/null) || true\n\n  # Parse naming errors and merge into ERRORS array\n  local naming_valid\n  naming_valid=$(echo \"$naming_result\" | jq -r '.valid // true' 2>/dev/null) || true\n\n  if [ \"$naming_valid\" = \"false\" ]; then\n    local naming_errors\n    naming_errors=$(echo \"$naming_result\" | jq -r '.errors[]?' 2>/dev/null) || true\n    if [ -n \"$naming_errors\" ]; then\n      while IFS= read -r err; do\n        [ -z \"$err\" ] && continue\n        ERRORS+=(\"Naming: $err\")\n        VALID=false\n      done <<< \"$naming_errors\"\n    fi\n  fi\n}\n\n(3) Add validate_naming_conventions to the --- Main flow --- section, after validate_no_circular_deps (line 263):\nvalidate_header\nvalidate_tasks\nvalidate_waves\nvalidate_no_circular_deps\nvalidate_naming_conventions   # <-- NEW: naming convention check\n\nKEY: The integration is backward compatible. If validate-naming.sh does not exist (pre-01-03 state), the function returns early with no effect. Existing validate-plan.sh tests continue to pass because they test structural validation which is unchanged.\n\n--- execute-protocol.md changes (C12) ---\nFile: references/execute-protocol.md.\n\nIn the Pre-Execution section, item 4 (lines 26-37, the 'Validate all plans' block), add a second validation step after the validate-plan.sh loop. Insert after the closing 'done' of the validate-plan.sh for-loop (after line 36, before line 37 'This replaces...'):\n\n   ```bash\n   # Naming convention validation (post-structural)\n   if [ -x \"${CLAUDE_PLUGIN_ROOT}/scripts/validate-naming.sh\" ]; then\n     for plan in \"${PHASE_DIR}\"/*.plan.jsonl; do\n       result=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/validate-naming.sh \"$plan\" --type=plan)\n       if [ $? -ne 0 ]; then\n         echo \"Naming validation failed: $plan\" >&2\n         echo \"$result\" | jq -r '.errors[]' >&2\n         exit 1\n       fi\n     done\n   fi\n   ```\n\nUpdate the comment after the block: 'This replaces LLM-based plan validation. Invalid plans (structural or naming) STOP execution before any agent spawns.'\n\nThis wires validate-naming.sh as a blocking gate in execute-protocol.md Step 3 pre-execution, as specified by C12. The -x guard ensures backward compatibility if the script is not yet deployed.","ts":"Test file: tests/unit/validate-plan.bats (existing file, append tests).\n\nAppend these tests to the existing validate-plan.bats file:\n\n(A) 'validate-plan.sh still passes valid plan after naming integration' -- use existing mk_valid_plan helper. run bash \"$SUT\" \"$plan_file\". assert_success. Verifies backward compatibility.\n(B) 'validate-plan.sh catches compound p field via naming validation' -- create plan with p:\"01-01\" (compound) but otherwise valid structural keys. run bash \"$SUT\" \"$file\". assert_failure. assert_output --partial 'Naming:' (prefix from integration). assert_output --partial 'compound'.\n(C) 'validate-plan.sh catches title in n field via naming validation' -- create plan with n:\"Create auth\" but otherwise valid. assert_failure. assert_output --partial 'Naming:'.\n(D) 'validate-plan.sh works when validate-naming.sh does not exist' -- temporarily rename validate-naming.sh (or use a test workdir where it is absent). Create valid plan. run bash \"$SUT\". assert_success. Verifies backward compatibility guard.\n\nThese 4 tests verify the integration layer. They do NOT duplicate the 26 tests in validate-naming.bats (those test validate-naming.sh directly). These test the plumbing between validate-plan.sh and validate-naming.sh."}
