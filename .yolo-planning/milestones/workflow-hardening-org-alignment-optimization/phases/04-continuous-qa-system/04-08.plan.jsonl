{"p":"04","n":"08","t":"Execute-protocol QA gate integration","w":2,"d":["04-05","04-06","04-07"],"mh":{"tr":["Step 7 (implementation) calls qa-gate-post-task.sh after each Dev task completion","Step 7 calls qa-gate-post-plan.sh after each plan completion before proceeding to next plan","Step 9 (QA) calls qa-gate-post-phase.sh as first action before spawning QA agents","QA gate failures in Step 7 trigger Dev remediation via Senior re-spec","Gate invocations are documented with exact bash commands in execute-protocol.md"],"ar":[{"p":"references/execute-protocol.md","pv":"file exists","c":"Contains post-task gate call in Step 7 after each task, post-plan gate after each plan, post-phase gate in Step 9"},{"p":"references/qa-gate-integration.md","pv":"file exists","c":"Documents QA gate integration points, failure handling, and remediation flow"}],"kl":[{"fr":"execute-protocol.md Step 7 post-task gate","to":"scripts/qa-gate-post-task.sh","vi":"Protocol references exact script path and flags"},{"fr":"execute-protocol.md Step 7 post-plan gate","to":"scripts/qa-gate-post-plan.sh","vi":"Protocol references exact script path and flags"},{"fr":"execute-protocol.md Step 9 post-phase gate","to":"scripts/qa-gate-post-phase.sh","vi":"Step 9 calls post-phase gate before QA agent spawn"}]},"obj":"Wire QA gate scripts into execute-protocol.md at Step 7 (post-task and post-plan) and Step 9 (post-phase) with failure handling and remediation flows","sk":["commit"],"fm":["references/execute-protocol.md","references/qa-gate-integration.md"]}
{"id":"T1","tp":"auto","a":"Add post-task QA gate invocation to execute-protocol.md Step 7: after each Dev task completion (after commit, before next task), call qa-gate-post-task.sh with --phase-dir and --plan and --task flags. On failure: Dev pauses, Senior reviews test failures, Dev fixes and re-commits. Document both team_mode=task and team_mode=teammate flows. Insert after 'Dev commits' and before 'Dev loops to next task'. REQ-07 post-task gate integration.","f":["references/execute-protocol.md"],"v":"Step 7 contains post-task gate call with exact bash command and failure handling","done":"Post-task gate integrated into Step 7","spec":"File: references/execute-protocol.md (modify). Location: Step 7: Implementation (Dev Agents), after the 'Dev TDD protocol' section (around line 396-398) and before 'Dev escalation chain'. Add new section '**Post-task QA Gate (after each task commit):**' with the following content: (1) Exact bash command block: ```bash\\nresult=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/qa-gate-post-task.sh \\\\\\n  --phase-dir \"{phase-dir}\" --plan \"{plan-id}\" --task \"{task-id}\" --scope)\\ngate_status=$(echo \"$result\" | jq -r '.gate')\\n```. Note: --scope flag is DEFAULT per architecture D4. (2) On gate_status=pass: 'Dev proceeds to next task.' (3) On gate_status=fail: 'Dev pauses. Senior reviews test failures from gate JSON output (tst.fl field). Senior re-specs fix. Dev implements fix and re-commits. Re-run post-task gate. Max 2 remediation cycles per task -- after cycle 2 still failing, Senior escalates to Lead.' (4) On gate_status=warn: 'Dev proceeds (warn indicates missing test infrastructure, not test failure). Gate result is recorded for QA agent review.' (5) **[teammate]** block: 'When team_mode=teammate: Dev runs post-task gate autonomously after each self-claimed task commit (part of the Dev claim loop step 5-6). Dev sends gate result to Senior via dev_progress message (include gate_status field). If gate fails, Dev sends dev_blocker to Senior with gate output. Senior routes fix instructions back to Dev via code_review_changes schema.' (6) **[task]** block: 'When team_mode=task: Orchestrator (Lead) runs post-task gate after each Dev task commit. On failure, orchestrator messages Dev with fix instructions from Senior.' Add this BEFORE the existing 'Dev escalation chain' section. Do NOT modify any existing text -- this is purely additive insertion.","ts":""}
{"id":"T2","tp":"auto","a":"Add post-plan QA gate invocation to execute-protocol.md Step 7: after all tasks in a plan complete and summary.jsonl is written, call qa-gate-post-plan.sh with --phase-dir and --plan flags. On failure: block progression to next plan, Senior re-specs failed tasks, Dev fixes. Document team_mode differences (teammate: Lead runs gate; task: orchestrator runs gate). REQ-07 post-plan gate integration.","f":["references/execute-protocol.md"],"td":["T1"],"v":"Step 7 contains post-plan gate call after summary verification, before next plan","done":"Post-plan gate integrated into Step 7","spec":"File: references/execute-protocol.md (modify). Location: Step 7, after the 'Summary verification gate (mandatory)' section (around line 402-408) and before 'EXIT GATE'. Add new section '**Post-plan QA Gate (after plan completion):**' with content: (1) Exact bash command: ```bash\\nresult=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/qa-gate-post-plan.sh \\\\\\n  --phase-dir \"{phase-dir}\" --plan \"{plan-id}\")\\ngate_status=$(echo \"$result\" | jq -r '.gate')\\n```. Note: NO --scope flag -- post-plan runs full test suite per architecture D4. (2) On gate_status=pass: 'Proceed to next plan (or Step 8 if last plan).' (3) On gate_status=fail: 'Block progression to next plan. Read gate JSON: check tst (test failures), mh (must_have failures). For test failures: Senior reviews, re-specs fix tasks, Dev implements. For must_have failures: Senior reviews plan coverage gaps. Max 1 remediation cycle at post-plan level -- persistent failure escalates to Lead.' (4) **[teammate]** block: 'When team_mode=teammate: Lead runs post-plan gate after writing summary.jsonl (Lead is sole summary writer in teammate mode). Lead sends gate result to Senior for review if fail.' (5) **[task]** block: 'When team_mode=task: Orchestrator runs post-plan gate after Dev writes summary.jsonl. On failure, orchestrator routes to Senior.' Insert AFTER the summary verification section, BEFORE EXIT GATE. Additive only.","ts":""}
{"id":"T3","tp":"auto","a":"Add post-phase QA gate invocation to execute-protocol.md Step 9: as first action before spawning QA Lead and QA Code agents, call qa-gate-post-phase.sh with --phase-dir flag. On failure: block QA agent spawn, generate remediation plan. This formalizes existing informal phase-end verification into a script-backed gate. REQ-07 post-phase gate formalization.","f":["references/execute-protocol.md"],"td":["T2"],"v":"Step 9 contains post-phase gate call before QA agent spawn","done":"Post-phase gate integrated into Step 9","spec":"File: references/execute-protocol.md (modify). Location: Step 9: QA (QA Lead + QA Code), after the ENTRY GATE paragraph (around line 465-466) and before '1. Update execution state'. Add new section '**Post-phase QA Gate (automated pre-check):**' with content: (1) Context line: 'Before spawning QA agents (LLM-powered, expensive), run the post-phase gate as a fast automated pre-check (script-only, <60s). This catches obvious failures before committing LLM cost.' (2) Exact bash command: ```bash\\nresult=$(bash ${CLAUDE_PLUGIN_ROOT}/scripts/qa-gate-post-phase.sh \\\\\\n  --phase-dir \"{phase-dir}\")\\ngate_status=$(echo \"$result\" | jq -r '.gate')\\n```. (3) On gate_status=pass: 'Proceed to QA agent spawn below.' (4) On gate_status=fail: 'BLOCK QA agent spawn. Read gate JSON for failure details: plans.complete (incomplete plans), steps.fl (failed validation gates), tst.fl (test failures). Generate remediation: for incomplete plans, route back to Step 7. For failed gates, identify which step artifacts are missing. For test failures, route to Senior for re-spec. Do NOT spawn QA agents until post-phase gate passes -- this saves LLM cost on obviously-broken phases.' (5) After the gate check, add: 'Post-phase gate result is available to QA agents via {phase-dir}/.qa-gate-results.jsonl. QA Lead and QA Code can reference prior gate results for incremental verification.' Insert between ENTRY GATE and step 1 (Update execution state). Additive only -- do not modify existing QA Lead or QA Code spawn logic.","ts":""}
{"id":"T4","tp":"auto","a":"Create references/qa-gate-integration.md documenting: (1) all three gate levels with trigger points, (2) failure handling and remediation flows per level, (3) gate skip conditions (--skip-qa, --effort=turbo), (4) team_mode differences, (5) config options for enabling/disabling individual gate levels. Cross-reference qa-output-patterns.md for output format. REQ-07 documentation.","f":["references/qa-gate-integration.md"],"td":["T3"],"v":"Integration doc exists with all five sections, cross-references output patterns","done":"QA gate integration documentation committed","spec":"File: references/qa-gate-integration.md (new). Structure with these sections: (1) '# QA Gate Integration' -- Overview paragraph: three-level continuous QA system (post-task, post-plan, post-phase). Fast automated pre-checks before expensive LLM-powered QA. (2) '## Gate Levels' -- Table with columns: Level, Trigger Point, Script, Scope, Timeout, Blocking Behavior. Rows: post-task (after each Dev commit in Step 7, qa-gate-post-task.sh, --scope by default, 30s, blocks next task), post-plan (after summary.jsonl in Step 7, qa-gate-post-plan.sh, full suite, 300s, blocks next plan), post-phase (before QA agent spawn in Step 9, qa-gate-post-phase.sh, full suite + gate validation, 300s, blocks QA spawn). (3) '## Failure Handling' -- Per-level subsections: post-task failure (Senior review -> Dev fix -> max 2 cycles -> escalate to Lead), post-plan failure (Senior review -> Dev fix -> max 1 cycle -> escalate to Lead), post-phase failure (block QA spawn -> generate remediation -> route back to Step 7). (4) '## Skip Conditions' -- Table: --skip-qa flag skips all gates AND Step 9 QA agents, --effort=turbo skips all gates (no tests run), per-gate config toggle (qa_gates.post_task=false skips post-task only). When skipped, gate outputs {gate:\"skipped\"} JSON and exits 0. (5) '## Team Mode Differences' -- Table: team_mode=task (orchestrator/Lead runs all gates, sequential execution), team_mode=teammate (Dev runs post-task after self-claimed task commit, Lead runs post-plan after summary aggregation, Lead runs post-phase). Post-task in teammate mode: Dev is responsible for gate execution and reporting result to Senior. (6) '## Config Options' -- Reference to config/defaults.json qa_gates object. Table of 5 fields: post_task (bool, default true), post_plan (bool, default true), post_phase (bool, default true), timeout_seconds (int, default 300), failure_threshold (enum critical|major|minor, default critical). Link to commands/config.md for interactive configuration. (7) '## Result Storage' -- .qa-gate-results.jsonl in phase-dir. Append-mode, flock-serialized. Schema reference to artifact-formats.md. Consumed by QA agents in Step 9. (8) '## Output Format' -- Cross-reference: 'See references/qa-output-patterns.md for human-readable output templates.' (9) '## Relationship to QA Agents' -- Clarification: gates are fast automated pre-checks (<60s). QA agents (yolo-qa, yolo-qa-code) are deep LLM-powered verification (5-10min). Gates do NOT replace agents. Gates catch obvious failures early. Cost optimization: if gate fails, agents never spawn (save LLM tokens). If gate passes, agents still run full verification.","ts":""}
