---
phase: "03"
plan: "01"
title: "Implement QA feedback loop orchestration in execute-protocol Step 3d"
wave: 1
depends_on: []
must_haves:
  - "Step 3d contains full loop logic: QA fail → categorize by fixable_by → spawn Dev or HARD STOP → re-run QA"
  - "Loop reads qa_max_cycles from config with default 3"
  - "execution-state.json updated with qa_loop block during loop"
  - "Event logging: qa_loop_start, qa_loop_cycle, qa_loop_end"
  - "Max cycles exceeded produces HARD STOP with accumulated findings"
  - "Only failed checks re-run on subsequent cycles (skip passed)"
  - "Dev subagent receives scoped remediation context (specific failure, not full report)"
---
# Plan 03-01: Execute-protocol QA feedback loop orchestration

## Context
Step 3d in `skills/execute-protocol/SKILL.md` currently runs 5 QA commands and stops on failure.
Phase 3 replaces this with an automated remediation loop: on failure, categorize each check by
`fixable_by` field, spawn Dev for dev-fixable issues, HARD STOP for architect/manual issues,
then re-run only failed checks. Loop until all pass or qa_max_cycles exceeded.

The review loop in Step 2b (Phase 2) is the template — follow its pattern for loop state,
execution-state tracking, event logging, and delta re-runs.

## Tasks

### Task 1: Replace Step 3d failure path with QA loop logic
Read `skills/execute-protocol/SKILL.md`. Find the Step 3d section. Replace the current
"If ANY check fails → STOP" behavior with full loop logic:

1. Read `qa_max_cycles` from config: `jq -r '.qa_max_cycles // 3' .yolo-planning/config.json`
2. Run all 5 QA commands as before
3. Parse results — collect failures with their `fixable_by` field
4. **Categorize failures:**
   - If ANY failure has `fixable_by: "architect"`: HARD STOP — plan-level issue, cannot auto-fix post-execution
   - If ANY failure has `fixable_by: "manual"`: HARD STOP — requires human intervention
   - If ALL failures have `fixable_by: "dev"`: enter remediation loop
5. **Remediation loop:** While failed checks exist AND QA_CYCLE < QA_MAX_CYCLES:
   a. Increment QA_CYCLE
   b. Log `qa_loop_cycle` event
   c. For each dev-fixable failure, build a scoped remediation task:
      - commit-lint violation → "Rewrite commit message: {suggested_fix}"
      - diff-against-plan mismatch → "Update SUMMARY.md files_modified to match actual git changes"
      - verify-plan-completion failure → "Fix SUMMARY.md: {specific field/section}"
      - validate-requirements unverified → "Add evidence for requirement: {requirement text}"
   d. Spawn Dev subagent (Task tool, execution family, model from resolve-model) with:
      - Scoped remediation instructions (NOT full QA report)
      - List of specific failures to fix
      - Working directory and file paths
   e. After Dev completes, re-run ONLY previously failed checks (skip passed ones)
   f. Update failure list
6. On all checks pass: exit loop successfully
7. On max_cycles exceeded: HARD STOP with all accumulated findings

**File:** `skills/execute-protocol/SKILL.md`
**Commit:** `feat(03-01): implement QA feedback loop orchestration in Step 3d`

### Task 2: Add execution-state.json qa_loop tracking
In the Step 3d loop logic, add jq commands to track QA loop state:

- On loop start: add `qa_loop` block to execution-state.json:
  ```json
  {"cycle": 1, "max": 3, "status": "running", "failed_checks_per_cycle": []}
  ```
- On each cycle: append failed checks summary to `failed_checks_per_cycle` array:
  ```json
  {"cycle": 1, "failed_count": 2, "checks": ["commit-lint", "diff-against-plan"], "dev_fixable": 2, "hard_stop": 0}
  ```
- On loop end: set `qa_loop.status` to "passed" (all pass) or "failed" (max_cycles exceeded)

Follow the same jq pattern used in Step 2b for review_loops tracking.

**File:** `skills/execute-protocol/SKILL.md` (same file, within Step 3d)
**Commit:** `feat(03-01): add qa_loop tracking to execution-state.json`

### Task 3: Wire event logging and delta re-run optimization
Add event logging calls at loop boundaries:

```bash
yolo log-event qa_loop_start {phase} plan={plan_id} max_cycles={max} failed_count={N} 2>/dev/null || true
yolo log-event qa_loop_cycle {phase} plan={plan_id} cycle={N} failed_count={N} dev_fixable={N} 2>/dev/null || true
yolo log-event qa_loop_end {phase} plan={plan_id} cycles_used={N} final_status=pass|max_exceeded 2>/dev/null || true
```

Add delta re-run optimization:
- Track which checks passed on first run
- On subsequent cycles, only re-run checks that failed previously
- This saves token cost by not re-running check-regression, verify-plan-completion etc. if they already passed
- Note cache efficiency: Dev and QA share "execution" Tier 2 cache — stays warm between iterations

**File:** `skills/execute-protocol/SKILL.md`
**Commit:** `feat(03-01): wire QA loop event logging and delta re-run optimization`

### Task 4: Document Dev remediation context scoping
Add clear documentation in Step 3d about how Dev remediation tasks are constructed:

- Dev receives ONLY the specific failure details (not the full QA report)
- Each remediation task has clear instructions per command type:
  - `commit-lint`: "Rewrite commit {hash}: {suggested_fix}" — Dev uses `git commit --amend` or interactive rebase
  - `diff-against-plan`: "Update SUMMARY.md files_modified section to include: {undeclared files}"
  - `verify-plan-completion`: "Fix SUMMARY.md field {field_name}: expected {expected}, got {actual}"
  - `validate-requirements`: "Add evidence for '{requirement}' — update SUMMARY.md What Was Built section"
- Dev gets the working directory, plan path, and summary path for context
- Dev commits fixes with `fix({scope}): {description}` format

**File:** `skills/execute-protocol/SKILL.md`
**Commit:** `feat(03-01): document Dev remediation context scoping for QA loop`
