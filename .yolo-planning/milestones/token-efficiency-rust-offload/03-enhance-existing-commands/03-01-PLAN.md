---
phase: "03"
plan: "01"
title: "phase-detect --suggest-route and resolve-model --with-cost --all flags"
wave: 1
depends_on: []
must_haves:
  - "yolo phase-detect --suggest-route appends suggested_route={mode} to output"
  - "yolo resolve-model ... --with-cost outputs JSON {model,cost_weight}"
  - "yolo resolve-model ... --all outputs JSON object with all 9 agents"
  - "yolo resolve-model ... --all --with-cost outputs combined JSON"
  - "All existing phase-detect and resolve-model bats tests still pass"
  - "New bats tests for each flag variant"
---

# Plan 03-01: phase-detect --suggest-route and resolve-model --with-cost --all

## Summary

Add three flags to two existing Rust commands that let the LLM skip routing/cost reasoning:
- `phase-detect --suggest-route`: appends a routing decision based on existing output fields
- `resolve-model --with-cost`: outputs JSON with cost weight instead of bare model name
- `resolve-model --all`: resolves all 9 agents in one call, returns JSON object

## Task 1: Add --suggest-route to phase-detect

**File:** `yolo-mcp-server/src/commands/phase_detect.rs`

**Changes:**
1. At line 5 (function signature), args are already `&[String]` — no change needed
2. After line 5, add flag detection:
   ```rust
   let suggest_route = args.iter().any(|a| a == "--suggest-route");
   ```
3. Before the final `Ok(...)` at line 236, add routing logic after `execution_state` output:
   ```rust
   if suggest_route {
       let route = suggest_route_mode(
           &next_phase_state, project_exists, &exec_state, brownfield, phase_count,
       );
       out.push_str(&format!("suggested_route={}\n", route));
   }
   ```
4. Add helper function after `execute()`:
   ```rust
   fn suggest_route_mode(
       next_phase_state: &str,
       project_exists: bool,
       execution_state: &str,
       brownfield: bool,
       phase_count: usize,
   ) -> &'static str {
       // Resume interrupted execution
       if execution_state == "running" {
           return "resume";
       }
       // No project yet
       if !project_exists {
           if brownfield {
               return "bootstrap";
           }
           return "init";
       }
       // All phases done
       if next_phase_state == "all_done" {
           return "archive";
       }
       // Needs planning
       if next_phase_state == "needs_plan_and_execute" || next_phase_state == "no_phases" {
           return "plan";
       }
       // Has plans, needs execution
       if next_phase_state == "needs_execute" {
           return "execute";
       }
       "plan"
   }
   ```

**Routing logic explained:**
- `execution_state == "running"` -> `resume`
- `!project_exists && brownfield` -> `bootstrap`
- `!project_exists && !brownfield` -> `init`
- `next_phase_state == "all_done"` -> `archive`
- `next_phase_state == "needs_plan_and_execute"` or `"no_phases"` -> `plan`
- `next_phase_state == "needs_execute"` -> `execute`
- fallback -> `plan`

**Note:** The early return at line 37 (no planning dir) needs the flag too. Add `suggested_route=init` when `suggest_route` is true before that early return.

**Exit codes:** Unchanged (always 0 on success).

## Task 2: Add --with-cost and --all to resolve-model

**File:** `yolo-mcp-server/src/commands/resolve_model.rs`

**Changes:**
1. After line 7, add flag detection and strip flags from positional arg indexing:
   ```rust
   let with_cost = args.iter().any(|a| a == "--with-cost");
   let all_agents = args.iter().any(|a| a == "--all");
   // Filter out flags for positional arg parsing
   let positional: Vec<&String> = args.iter().filter(|a| !a.starts_with("--")).collect();
   ```
2. For `--all` mode: skip single-agent validation. Instead, iterate `VALID_AGENTS`, resolve each model, build JSON object. The `--all` path skips the cache check (it has its own cache key).
3. For `--with-cost` mode: wrap output in JSON `{"model":"opus","cost_weight":100}`.
4. For `--all --with-cost` combined: `{"lead":{"model":"opus","cost_weight":100},...}`.
5. Add cost weight constant map:
   ```rust
   fn cost_weight(model: &str) -> u32 {
       match model {
           "opus" => 100,
           "sonnet" => 20,
           "haiku" => 2,
           _ => 0,
       }
   }
   ```
6. For `--all` cache: use separate cache key `/tmp/yolo-model-ALL-{mtime}-{hash}` (and `-ALL-COST-` for combined).

**Arg parsing adjustment for --all:**
- When `--all` is set, only need 4 positional args: `yolo resolve-model <config-path> <profiles-path>`
- When not `--all`, need 5 positional: `yolo resolve-model <agent> <config-path> <profiles-path>`
- Adjust the `if positional.len() < N` check accordingly.

**Output format:**
- No flags: `opus\n` (unchanged)
- `--with-cost`: `{"model":"opus","cost_weight":100}\n`
- `--all`: `{"lead":"opus","dev":"sonnet",...}\n`
- `--all --with-cost`: `{"lead":{"model":"opus","cost_weight":100},...}\n`

**Exit codes:** Unchanged (0 success, 1 error via Err).

## Task 3: Add Rust unit tests for --suggest-route

**File:** `yolo-mcp-server/src/commands/phase_detect.rs` (in `mod tests` block)

Add tests:
1. `test_suggest_route_no_planning` — no planning dir, flag set, output contains `suggested_route=init`
2. `test_suggest_route_needs_plan` — project exists, phase with no plans, output contains `suggested_route=plan`
3. `test_suggest_route_needs_execute` — phase with plans no summaries, output contains `suggested_route=execute`
4. `test_suggest_route_all_done` — all phases done, output contains `suggested_route=archive`
5. `test_suggest_route_execution_running` — `.execution-state.json` with `"status":"running"`, output contains `suggested_route=resume`
6. `test_no_suggest_route_without_flag` — no flag set, output does NOT contain `suggested_route`

## Task 4: Add Rust unit tests for --with-cost and --all

**File:** `yolo-mcp-server/src/commands/resolve_model.rs` (in `mod tests` block)

Add tests:
1. `test_with_cost_flag` — single agent with `--with-cost`, output is valid JSON with `model` and `cost_weight` keys
2. `test_all_flag` — `--all` without agent name, output is JSON object with all 9 agent keys
3. `test_all_with_cost_combined` — `--all --with-cost`, output has nested JSON per agent
4. `test_all_without_agent_name` — `--all` flag should NOT require agent positional arg
5. `test_cost_weight_values` — verify opus=100, sonnet=20, haiku=2

## Task 5: Add bats integration tests for new flags

**File:** `tests/phase-detect.bats` (append)

Add tests:
```bash
@test "phase-detect --suggest-route: init when no project" {
  rm -rf .yolo-planning/PROJECT.md
  run "$YOLO_BIN" phase-detect --suggest-route
  [ "$status" -eq 0 ]
  echo "$output" | grep -q "suggested_route="
}

@test "phase-detect --suggest-route: plan when needs planning" {
  echo "# Proj" > .yolo-planning/PROJECT.md
  mkdir -p .yolo-planning/phases/01-test/
  run "$YOLO_BIN" phase-detect --suggest-route
  [ "$status" -eq 0 ]
  echo "$output" | grep -q "suggested_route=plan"
}

@test "phase-detect: no suggested_route without flag" {
  run "$YOLO_BIN" phase-detect
  [ "$status" -eq 0 ]
  ! echo "$output" | grep -q "suggested_route"
}
```

**File:** `tests/resolve-agent-model.bats` (append)

Add tests:
```bash
@test "resolve-model --with-cost outputs JSON with cost_weight" {
  run "$YOLO_BIN" resolve-model dev "$TEST_TEMP_DIR/.yolo-planning/config.json" "$CONFIG_DIR/model-profiles.json" --with-cost
  [ "$status" -eq 0 ]
  echo "$output" | jq -e '.model' >/dev/null
  echo "$output" | jq -e '.cost_weight' >/dev/null
}

@test "resolve-model --all returns all 9 agents" {
  run "$YOLO_BIN" resolve-model --all "$TEST_TEMP_DIR/.yolo-planning/config.json" "$CONFIG_DIR/model-profiles.json"
  [ "$status" -eq 0 ]
  local count=$(echo "$output" | jq 'keys | length')
  [ "$count" -eq 9 ]
}

@test "resolve-model --all --with-cost returns nested JSON" {
  run "$YOLO_BIN" resolve-model --all --with-cost "$TEST_TEMP_DIR/.yolo-planning/config.json" "$CONFIG_DIR/model-profiles.json"
  [ "$status" -eq 0 ]
  echo "$output" | jq -e '.lead.model' >/dev/null
  echo "$output" | jq -e '.lead.cost_weight' >/dev/null
}
```

## Verification

1. `cargo test -p yolo --release` passes all existing + new unit tests
2. `bats tests/phase-detect.bats` passes all existing + new integration tests
3. `bats tests/resolve-agent-model.bats` passes all existing + new integration tests
4. Without flags, output format is identical to current (backward compatible)
