---
phase: "02"
plan: "02"
title: "compile-progress and git-state commands"
wave: 1
depends_on: []
must_haves:
  - "yolo compile-progress outputs JSON with phase/plan/task counts and percentages"
  - "yolo git-state outputs JSON with branch, dirty, last tag, commits since"
  - "Both commands registered in router.rs with enum, from_arg, name, run_cli"
  - "Bats test file tests/compile-progress.bats with 6+ tests"
  - "Bats test file tests/git-state.bats with 5+ tests"
  - "cargo test passes for both modules"
---

# Plan 02-02: compile-progress and git-state commands

Two medium-complexity Rust commands that unify scattered shell/LLM work into deterministic CLI calls.

## Task 1: Implement `compile-progress` command

**Files to create:**
- `yolo-mcp-server/src/commands/compile_progress.rs`

**Files to modify:**
- `yolo-mcp-server/src/commands/mod.rs` — add `pub mod compile_progress;`

**Command spec:**
- CLI name: `compile-progress`
- Args: `[planning_dir]` (optional, defaults to `.yolo-planning`)
- Output JSON schema:
  ```json
  {
    "ok": true,
    "cmd": "compile-progress",
    "milestone": "token-efficiency-rust-offload",
    "phases": {
      "total": 4,
      "completed": 1,
      "in_progress": 1,
      "pending": 2
    },
    "plans": {
      "total": 5,
      "completed": 2,
      "in_progress": 1,
      "pending": 2
    },
    "tasks": {
      "total": 25,
      "completed": 10,
      "in_progress": 5,
      "pending": 10
    },
    "overall_pct": 40.0,
    "active_phase": "02",
    "active_phase_title": "new-rust-commands",
    "elapsed_ms": 5
  }
  ```
- Logic:
  1. Find active milestone directory: scan `<planning_dir>/milestones/` for directories, pick the one matching STATE.md's active milestone or the only one present
  2. Count phase directories (NN-slug pattern)
  3. For each phase dir, count plan files (`NN-MM-PLAN.md`) and summary files (`NN-MM-SUMMARY.md`)
  4. A phase is "completed" if every plan has a matching summary
  5. A phase is "in_progress" if it has some plans but not all have summaries
  6. A phase is "pending" if it has no plans
  7. Count tasks by parsing plan files — each `## Task N:` header counts as one task; matching summary = completed task
  8. `overall_pct` = (completed_tasks / total_tasks * 100), rounded to 1 decimal
  9. Active phase = first non-completed phase directory
- Exit code: 0 on success, 1 on error (e.g., no milestones directory)

**Implementation notes:**
- Use `std::fs::read_dir` for directory scanning
- Plan file detection: regex `^\d{2}-\d{2}-PLAN\.md$`
- Summary detection: same pattern with SUMMARY replacing PLAN
- Task counting: scan plan file lines for `^## Task \d+`
- For milestone name: read from STATE.md field `milestone:` or infer from directory name

**Rust unit tests:**
- Empty planning dir returns zeroes
- Single phase with 2 plans (1 complete) returns correct counts
- Phase with no plans counts as pending
- Overall percentage calculation
- Active phase detection

**Commit:** `feat(cli): add compile-progress command`

---

## Task 2: Implement `git-state` command

**Files to create:**
- `yolo-mcp-server/src/commands/git_state.rs`

**Files to modify:**
- `yolo-mcp-server/src/commands/mod.rs` — add `pub mod git_state;`

**Command spec:**
- CLI name: `git-state`
- Args: none required. All operations relative to cwd.
- Output JSON schema:
  ```json
  {
    "ok": true,
    "cmd": "git-state",
    "is_git_repo": true,
    "branch": "main",
    "dirty": false,
    "dirty_files": 3,
    "staged_files": 1,
    "last_tag": "v2.9.0",
    "commits_since_tag": 5,
    "head_sha": "abc1234",
    "head_short": "abc1234",
    "head_message": "feat: latest commit message",
    "has_upstream": true,
    "ahead": 2,
    "behind": 0,
    "elapsed_ms": 15
  }
  ```
- When not a git repo: `"is_git_repo": false` with all other fields as null/defaults
- Git commands used:
  - `git rev-parse --git-dir` — verify git repo
  - `git rev-parse --abbrev-ref HEAD` — branch name
  - `git status --porcelain` — dirty check + file counts
  - `git diff --cached --name-only` — staged count
  - `git describe --tags --abbrev=0` — last tag (empty if no tags)
  - `git rev-list <tag>..HEAD --count` — commits since tag
  - `git rev-parse HEAD` — full sha
  - `git rev-parse --short HEAD` — short sha
  - `git log -1 --format=%s` — head commit message
  - `git rev-parse --abbrev-ref --symbolic-full-name @{u}` — upstream check
  - `git rev-list --left-right --count HEAD...@{u}` — ahead/behind
- Exit code: 0 always (non-git repo is not an error, just `is_git_repo: false`)

**Implementation notes:**
- Use `std::process::Command` for all git calls (same pattern as `planning_git.rs`)
- Each git subcommand wrapped in a helper that returns `Option<String>` (None if command fails)
- Parse `--left-right --count` output: "N\tM" → ahead=N, behind=M

**Rust unit tests:**
- Non-git directory returns `is_git_repo: false`
- Git repo with clean state
- Git repo with dirty files
- Git repo with tags returns last_tag and commits_since_tag
- Git repo without tags returns null for last_tag

**Commit:** `feat(cli): add git-state command`

---

## Task 3: Register both commands in router.rs

**Files to modify:**
- `yolo-mcp-server/src/cli/router.rs`

**IMPORTANT — conflict avoidance with Plan 02-01:**
This plan's router edits add AFTER Plan 02-01's entries. Plan 02-01 adds `ParseFrontmatter, ResolvePluginRoot, ConfigRead` at the end of each section. This plan adds `CompileProgress, GitState` after those. **The Dev must acquire a file lock on router.rs before editing and verify Plan 02-01's router task (Task 4) has been committed first.** If Plan 02-01 has not yet committed its router changes, wait or add all entries fresh at the end.

**Router registration — add after Plan 02-01's entries (or at END if Plan 02-01 not yet merged):**

1. **Enum variants** (after ConfigRead or after VerifyPlanCompletion):
   ```rust
   CompileProgress,
   GitState,
   ```

2. **from_arg() match arms** (before `_ => None`):
   ```rust
   "compile-progress" => Some(Command::CompileProgress),
   "git-state" => Some(Command::GitState),
   ```

3. **name() match arms**:
   ```rust
   Command::CompileProgress => "compile-progress",
   Command::GitState => "git-state",
   ```

4. **all_names() array** — append:
   ```rust
   "compile-progress", "git-state",
   ```

5. **use statement** (line 6) — append to import list:
   ```rust
   compile_progress, git_state
   ```

6. **run_cli() dispatch** (before `None =>`):
   ```rust
   Some(Command::CompileProgress) => {
       let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
       compile_progress::execute(&args, &cwd)
   }
   Some(Command::GitState) => {
       let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
       git_state::execute(&args, &cwd)
   }
   ```

**Commit:** `feat(cli): register compile-progress and git-state in router`

---

## Task 4: Bats integration tests for compile-progress

**Files to create:**
- `tests/compile-progress.bats`

**Test setup:**
```
setup: setup_temp_dir, YOLO_BIN
```

**Tests (6):**
1. `returns zeroes for empty planning dir` — empty .yolo-planning, verify all counts are 0
2. `counts phases correctly` — create 3 phase dirs (01-foo, 02-bar, 03-baz), verify phases.total=3
3. `counts plans and summaries` — create 2 plan files and 1 summary in a phase, verify plans.total=2, plans.completed=1
4. `calculates overall percentage` — set up known plan/summary ratio, verify overall_pct value
5. `detects active phase` — phase 01 fully done (all summaries), phase 02 has plans but not all done, verify active_phase="02"
6. `counts tasks from plan headers` — create plan file with `## Task 1:`, `## Task 2:`, `## Task 3:` headers, verify tasks.total counts them
7. `handles missing milestones dir` — no milestones dir at all, verify graceful error or zero counts

**Commit:** `test(cli): add bats tests for compile-progress`

---

## Task 5: Bats integration tests for git-state

**Files to create:**
- `tests/git-state.bats`

**Test setup:**
```
setup: setup_temp_dir, YOLO_BIN, git init in TEST_TEMP_DIR
```

**Tests (5):**
1. `returns is_git_repo false for non-git dir` — run in plain temp dir (no git init), verify is_git_repo=false
2. `returns branch name` — init git repo, verify branch is "main" or "master"
3. `detects clean state` — init + commit, verify dirty=false
4. `detects dirty state` — create uncommitted file, verify dirty=true and dirty_files > 0
5. `returns head sha and message` — make a commit with known message, verify head_message and head_sha are present
6. `returns last tag and commits since` — create tag, make 2 more commits, verify last_tag and commits_since_tag=2

**Commit:** `test(cli): add bats tests for git-state`
