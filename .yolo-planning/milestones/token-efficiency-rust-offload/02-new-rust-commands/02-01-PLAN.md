---
phase: "02"
plan: "01"
title: "parse-frontmatter, resolve-plugin-root, and config-read commands"
wave: 1
depends_on: []
must_haves:
  - "yolo parse-frontmatter <file> outputs JSON with all frontmatter keys"
  - "yolo resolve-plugin-root outputs JSON with resolved plugin path"
  - "yolo config-read <key> [default] outputs JSON with config value"
  - "All three commands registered in router.rs with enum, from_arg, name, run_cli"
  - "Bats test file tests/parse-frontmatter.bats with 6+ tests"
  - "Bats test file tests/resolve-plugin-root.bats with 4+ tests"
  - "Bats test file tests/config-read.bats with 5+ tests"
  - "cargo test passes for all three modules"
---

# Plan 02-01: parse-frontmatter, resolve-plugin-root, config-read

Three small, independent Rust commands that eliminate LLM-side deterministic work.

## Task 1: Implement `parse-frontmatter` command

**Files to create:**
- `yolo-mcp-server/src/commands/parse_frontmatter.rs`

**Files to modify:**
- `yolo-mcp-server/src/commands/mod.rs` — add `pub mod parse_frontmatter;`

**Command spec:**
- CLI name: `parse-frontmatter`
- Args: `<file_path>` (required) — path to a markdown file
- Output JSON schema:
  ```json
  {
    "ok": true,
    "cmd": "parse-frontmatter",
    "frontmatter": { "<key>": "<value>", ... },
    "has_frontmatter": true,
    "elapsed_ms": 2
  }
  ```
- When file has no frontmatter: `"has_frontmatter": false, "frontmatter": {}`
- When file does not exist: return error string `{"error": "file not found: <path>"}`
- Exit code: 0 on success, 1 on error

**Implementation notes:**
- Reuse the parsing logic from `state_updater.rs:392-424` but generalize it:
  - Parse ALL key-value pairs, not just phase/plan/status
  - Support YAML arrays: `key: [a, b, c]` or multi-line `- item` lists → JSON arrays
  - Support quoted and unquoted string values
  - Return all frontmatter keys as a flat JSON object
- Signature: `pub fn execute(args: &[String], cwd: &Path) -> Result<(String, i32), String>`

**Rust unit tests (in same file):**
- File with standard frontmatter returns parsed keys
- File without frontmatter returns `has_frontmatter: false`
- File with array values in frontmatter
- Missing file returns error
- Empty frontmatter block (just `---\n---`)

**Commit:** `feat(cli): add parse-frontmatter command`

---

## Task 2: Implement `resolve-plugin-root` command

**Files to create:**
- `yolo-mcp-server/src/commands/resolve_plugin_root.rs`

**Files to modify:**
- `yolo-mcp-server/src/commands/mod.rs` — add `pub mod resolve_plugin_root;`

**Command spec:**
- CLI name: `resolve-plugin-root`
- Args: none required. Optional `<start_path>` to override cwd.
- Output JSON schema:
  ```json
  {
    "ok": true,
    "cmd": "resolve-plugin-root",
    "plugin_root": "/absolute/path/to/plugin",
    "resolved_via": "env|walk|binary",
    "elapsed_ms": 1
  }
  ```
- Resolution order:
  1. `CLAUDE_PLUGIN_ROOT` env var (if set and directory exists) → `resolved_via: "env"`
  2. Walk up from cwd looking for a directory containing `config/defaults.json` → `resolved_via: "walk"`
  3. Binary location: parent of parent of `std::env::current_exe()` → `resolved_via: "binary"`
  4. If none found: error `{"error": "could not resolve plugin root"}`
- Exit code: 0 on success, 1 on error

**Rust unit tests:**
- Resolves via env var when CLAUDE_PLUGIN_ROOT is set
- Walks up to find config/defaults.json
- Returns error when nothing found (tempdir with no markers)

**Commit:** `feat(cli): add resolve-plugin-root command`

---

## Task 3: Implement `config-read` command

**Files to create:**
- `yolo-mcp-server/src/commands/config_read.rs`

**Files to modify:**
- `yolo-mcp-server/src/commands/mod.rs` — add `pub mod config_read;`

**Command spec:**
- CLI name: `config-read`
- Args: `<key>` (required), `[default_value]` (optional), `[config_path]` (optional, defaults to `.yolo-planning/config.json`)
- Output JSON schema:
  ```json
  {
    "ok": true,
    "cmd": "config-read",
    "key": "effort",
    "value": "balanced",
    "source": "config|default|missing",
    "elapsed_ms": 1
  }
  ```
- Reads JSON config file, extracts value at `key` (supports dot-notation for nested keys: `agent_max_turns.scout`)
- If key not found and default provided: `"source": "default"`, value = default
- If key not found and no default: `"source": "missing"`, `"value": null`
- Exit code: 0 always (missing key is not an error, just source=missing)

**Rust unit tests:**
- Reads simple top-level key
- Reads nested key with dot-notation
- Returns default when key missing
- Returns source=missing when no key and no default
- Handles missing config file gracefully (source=missing)

**Commit:** `feat(cli): add config-read command`

---

## Task 4: Register all three commands in router.rs

**Files to modify:**
- `yolo-mcp-server/src/cli/router.rs`

**Router registration — add at END of each section (after VerifyPlanCompletion):**

1. **Enum variants** (after line 79, before closing `}`):
   ```rust
   ParseFrontmatter,
   ResolvePluginRoot,
   ConfigRead,
   ```

2. **from_arg() match arms** (after line 153, before `_ => None`):
   ```rust
   "parse-frontmatter" => Some(Command::ParseFrontmatter),
   "resolve-plugin-root" => Some(Command::ResolvePluginRoot),
   "config-read" => Some(Command::ConfigRead),
   ```

3. **name() match arms** (after line 229, before closing `}`):
   ```rust
   Command::ParseFrontmatter => "parse-frontmatter",
   Command::ResolvePluginRoot => "resolve-plugin-root",
   Command::ConfigRead => "config-read",
   ```

4. **all_names() array** — append to the array:
   ```rust
   "parse-frontmatter", "resolve-plugin-root", "config-read",
   ```

5. **use statement** (line 6) — add to the import list:
   ```rust
   parse_frontmatter, resolve_plugin_root, config_read
   ```

6. **run_cli() dispatch** (after VerifyPlanCompletion block, before `None =>`):
   ```rust
   Some(Command::ParseFrontmatter) => {
       let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
       parse_frontmatter::execute(&args, &cwd)
   }
   Some(Command::ResolvePluginRoot) => {
       let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
       resolve_plugin_root::execute(&args, &cwd)
   }
   Some(Command::ConfigRead) => {
       let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
       config_read::execute(&args, &cwd)
   }
   ```

**IMPORTANT — conflict avoidance:** Plan 02-02 adds its commands AFTER the ones added here (alphabetically later in enum). Plan 02-01 adds at positions ending in `ConfigRead`, Plan 02-02 adds after `ConfigRead`. The `use` import line is a single long line — Plan 02-01 appends `parse_frontmatter, resolve_plugin_root, config_read` and Plan 02-02 appends `compile_progress, git_state` to the same line. To avoid merge conflict, Plan 02-01 MUST be committed first for the router.rs task, OR both plans must use non-overlapping insertion points. Since both are wave 1, **the Dev for Plan 02-02 must acquire a lock on router.rs before editing it and wait for Plan 02-01's router task to complete.**

**Commit:** `feat(cli): register parse-frontmatter, resolve-plugin-root, config-read in router`

---

## Task 5: Bats integration tests for all three commands

**Files to create:**
- `tests/parse-frontmatter.bats`
- `tests/resolve-plugin-root.bats`
- `tests/config-read.bats`

**tests/parse-frontmatter.bats** (6 tests):
```
setup: setup_temp_dir, YOLO_BIN
```
1. `parses standard frontmatter` — create MD file with `---\nphase: "01"\nplan: "02"\ntitle: "Test"\n---\n# Body`, verify JSON output has all 3 keys
2. `returns has_frontmatter false for no frontmatter` — plain MD file, verify `has_frontmatter` is false
3. `handles array values` — frontmatter with `must_haves:\n  - "item1"\n  - "item2"`, verify JSON array
4. `errors on missing file` — run with nonexistent path, verify exit code 1
5. `handles empty frontmatter` — file with just `---\n---`, verify empty frontmatter object
6. `handles inline array values` — `depends_on: [01, 02]`, verify JSON array

**tests/resolve-plugin-root.bats** (4 tests):
```
setup: setup_temp_dir, YOLO_BIN
```
1. `resolves via CLAUDE_PLUGIN_ROOT env` — set env var to temp dir, verify output
2. `resolves by walking up` — create nested dir with config/defaults.json marker, run from nested child
3. `resolves via binary fallback` — unset env, no marker files, verify it returns the binary's parent path
4. `outputs valid JSON` — verify output parses with jq

**tests/config-read.bats** (5 tests):
```
setup: setup_temp_dir, create_test_config, YOLO_BIN
```
1. `reads top-level key` — read "effort" from test config, verify value "balanced"
2. `reads nested key with dot-notation` — read "agent_max_turns.scout", verify value 15
3. `returns default when key missing` — read nonexistent key with default "fallback"
4. `returns source missing when no key no default` — read nonexistent key, verify source=missing value=null
5. `handles missing config file` — point to nonexistent path, verify source=missing

**Commit:** `test(cli): add bats tests for parse-frontmatter, resolve-plugin-root, config-read`
