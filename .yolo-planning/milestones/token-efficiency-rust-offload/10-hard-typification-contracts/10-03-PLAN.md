---
phase: 10
plan: 3
title: CLI Command Enum for Type-Safe Routing
wave: 1
depends_on: []
must_haves:
  - Command enum covering all 73+ CLI commands
  - router.rs dispatch via Command enum instead of string match
  - Unknown command error includes list of similar commands (fuzzy suggestion)
  - All existing tests pass + new tests for Command enum
---

# Plan 10-03: CLI Command Enum for Type-Safe Routing

## Context

`router.rs` dispatches 73+ commands via `match args[1].as_str()`. Adding a new
command requires manually adding a string arm — no compiler help if you forget.
Typos in string arms silently fall through to the `_` catch-all. This plan
replaces the string dispatch with a `Command` enum.

## Files to Modify

- `yolo-mcp-server/src/cli/router.rs` — Refactor to use Command enum
- `yolo-mcp-server/src/cli/mod.rs` — Re-export Command if needed

## Tasks

### Task 1: Define the Command enum

Add at the top of `router.rs` (or in a new `cli/commands.rs` if preferred,
re-exported from `cli/mod.rs`):

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Command {
    Report,
    ReportTokens,
    UpdateState,
    Statusline,
    HardGate,
    SessionStart,
    MetricsReport,
    TokenBaseline,
    Bootstrap,
    SuggestNext,
    ListTodos,
    PhaseDetect,
    DetectStack,
    Infer,
    PlanningGit,
    ResolveModel,
    ResolveTurns,
    LogEvent,
    CollectMetrics,
    GenerateContract,
    ContractRevision,
    AssessRisk,
    GatePolicy,
    SmartRoute,
    RouteMonorepo,
    SnapshotResume,
    PersistState,
    RecoverState,
    RollingSummary,
    GsdIndex,
    Incidents,
    Artifact,
    GsdSummary,
    CacheContext,
    CacheNuke,
    DeltaFiles,
    MapStaleness,
    TokenBudget,
    Lock,
    LeaseLock,
    TwoPhaseComplete,
    HelpOutput,
    BumpVersion,
    Doctor,
    AutoRepair,
    RolloutStage,
    Verify,
    Hook,
    InstallHooks,
    MigrateConfig,
    InvalidateTierCache,
    CompressContext,
    PruneCompleted,
    CompileContext,
    InstallMcp,
    MigrateOrphanedState,
    CleanStaleTeams,
    TmuxWatchdog,
    VerifyInitTodo,
    VerifyVibe,
    VerifyClaudeBootstrap,
    PrePush,
    ValidatePlan,
    ReviewPlan,
    CheckRegression,
    CommitLint,
    DiffAgainstPlan,
    ValidateRequirements,
    VerifyPlanCompletion,
}
```

### Task 2: Implement Command::from_arg()

Add a `from_arg` method that maps CLI strings to enum variants:

```rust
impl Command {
    pub fn from_arg(s: &str) -> Option<Command> {
        match s {
            "report" => Some(Command::Report),
            "report-tokens" => Some(Command::ReportTokens),
            "update-state" => Some(Command::UpdateState),
            // ... all commands ...
            "rollout-stage" | "rollout" => Some(Command::RolloutStage),
            _ => None,
        }
    }

    /// Return the canonical CLI name for this command.
    pub fn name(&self) -> &'static str {
        match self {
            Command::Report => "report",
            Command::ReportTokens => "report-tokens",
            // ... all variants ...
        }
    }
}
```

### Task 3: Refactor run_cli to use Command enum

Change the dispatch in `run_cli()`:

```rust
let command = Command::from_arg(args[1].as_str());
match command {
    Some(Command::Report) => { /* existing body */ }
    Some(Command::ReportTokens) => { /* existing body */ }
    // ... all arms ...
    None => {
        let suggestion = Command::suggest(&args[1]);
        let msg = if let Some(s) = suggestion {
            format!("Unknown command: '{}'. Did you mean '{}'?", args[1], s)
        } else {
            format!("Unknown command: '{}'", args[1])
        };
        Err(msg)
    }
}
```

The function bodies remain identical — this is a mechanical refactor of the
dispatch pattern only. Do NOT change any command implementation logic.

### Task 4: Implement fuzzy suggestion for unknown commands

Add a `suggest()` method that finds the closest match by Levenshtein-like
edit distance (simple implementation — no new crate needed):

```rust
impl Command {
    /// All known command names.
    fn all_names() -> &'static [&'static str] {
        &["report", "report-tokens", "update-state", /* ... */]
    }

    /// Suggest the closest command name for a typo.
    pub fn suggest(input: &str) -> Option<&'static str> {
        let mut best: Option<(&str, usize)> = None;
        for name in Self::all_names() {
            let dist = edit_distance(input, name);
            if dist <= 3 {
                if best.is_none() || dist < best.unwrap().1 {
                    best = Some((name, dist));
                }
            }
        }
        best.map(|(name, _)| name)
    }
}

fn edit_distance(a: &str, b: &str) -> usize {
    // Simple Levenshtein implementation (no external crate)
    let a: Vec<char> = a.chars().collect();
    let b: Vec<char> = b.chars().collect();
    let mut dp = vec![vec![0usize; b.len() + 1]; a.len() + 1];
    for i in 0..=a.len() { dp[i][0] = i; }
    for j in 0..=b.len() { dp[0][j] = j; }
    for i in 1..=a.len() {
        for j in 1..=b.len() {
            let cost = if a[i-1] == b[j-1] { 0 } else { 1 };
            dp[i][j] = (dp[i-1][j] + 1).min(dp[i][j-1] + 1).min(dp[i-1][j-1] + cost);
        }
    }
    dp[a.len()][b.len()]
}
```

### Task 5: Update tests

Update existing router tests and add new ones:

1. `test_command_from_arg_all_variants` — every known CLI string maps to Some(Command)
2. `test_command_from_arg_unknown` — unknown string returns None
3. `test_command_name_roundtrip` — `Command::from_arg(cmd.name()) == Some(cmd)` for all variants
4. `test_command_suggest_typo` — `Command::suggest("reprot")` returns `Some("report")`
5. `test_command_suggest_no_match` — `Command::suggest("zzzzz")` returns `None`
6. Update `test_run_cli_errors` to verify the new "Did you mean" message format
7. Verify the existing `test_routed_verify_commands` still passes
