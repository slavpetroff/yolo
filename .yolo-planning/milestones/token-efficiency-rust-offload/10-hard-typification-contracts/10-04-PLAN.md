---
phase: 10
plan: 4
title: Domain Newtypes and Typed Hook Inputs
wave: 1
depends_on: []
must_haves:
  - TaskId, Phase, Wave newtypes replacing raw String/u64 in at minimum 3 critical paths
  - Typed hook input structs for security_filter and validate_contract
  - All existing tests pass + new tests for newtypes and typed inputs
---

# Plan 10-04: Domain Newtypes and Typed Hook Inputs

## Context

Critical domain values — task IDs, phase numbers, wave numbers — are passed as
raw `String` or `u64` throughout the system. A task_id could be accidentally
swapped with a plan_id with no compiler error. Hook handlers receive
`serde_json::Value` and manually extract fields with `.get()` chains that
silently return `None` on typos.

This plan introduces newtypes for domain primitives and typed structs for
hook inputs, applied to the highest-impact paths.

## Files to Modify

- `yolo-mcp-server/src/commands/mod.rs` — Add `pub mod domain_types;`
- `yolo-mcp-server/src/commands/domain_types.rs` (NEW) — Newtype definitions
- `yolo-mcp-server/src/hooks/types.rs` — Add typed hook input structs
- `yolo-mcp-server/src/hooks/security_filter.rs` — Use typed SecurityFilterInput
- `yolo-mcp-server/src/hooks/validate_contract.rs` — Use typed ContractValidationInput
- `yolo-mcp-server/src/commands/lease_lock.rs` — Use TaskId/ResourceId newtypes

## Tasks

### Task 1: Create domain_types.rs with newtypes

Create `yolo-mcp-server/src/commands/domain_types.rs`:

```rust
use std::fmt;

/// A validated task identifier (e.g., "1", "5").
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TaskId(String);

impl TaskId {
    pub fn new(s: impl Into<String>) -> Self {
        Self(s.into())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
    /// Parse as a 1-based task number.
    pub fn as_number(&self) -> Option<u32> {
        self.0.parse().ok()
    }
}

impl fmt::Display for TaskId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// A phase number (positive integer).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Phase(pub u32);

impl Phase {
    pub fn new(n: u32) -> Self {
        Self(n)
    }
    pub fn as_u32(&self) -> u32 {
        self.0
    }
}

impl fmt::Display for Phase {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// A wave number within a phase (1-based).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Wave(pub u32);

impl Wave {
    pub fn new(n: u32) -> Self {
        Self(n)
    }
}

impl fmt::Display for Wave {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// A lock resource identifier.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ResourceId(String);

impl ResourceId {
    pub fn new(s: impl Into<String>) -> Self {
        Self(s.into())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for ResourceId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}
```

Register in `commands/mod.rs`: add `pub mod domain_types;`

### Task 2: Add typed hook input structs to hooks/types.rs

Add typed input structs alongside the existing `HookInput`:

```rust
/// Typed input for the security filter hook.
#[derive(Debug, Clone, Deserialize)]
pub struct SecurityFilterInput {
    pub tool_name: Option<String>,
    pub tool_input: Option<SecurityToolInput>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SecurityToolInput {
    pub file_path: Option<String>,
    pub path: Option<String>,
    pub pattern: Option<String>,
}

/// Typed input for the contract validation hook.
#[derive(Debug, Clone, Deserialize)]
pub struct ContractValidationInput {
    pub mode: Option<String>,
    pub contract_path: Option<String>,
    pub task_number: Option<u32>,
    pub modified_files: Option<Vec<String>>,
}

impl SecurityFilterInput {
    /// Try to parse from a HookInput, falling back to None fields on failure.
    pub fn from_hook_input(input: &HookInput) -> Self {
        serde_json::from_value(input.data.clone()).unwrap_or(SecurityFilterInput {
            tool_name: None,
            tool_input: None,
        })
    }
}

impl ContractValidationInput {
    /// Try to parse from a serde_json::Value.
    pub fn from_value(value: &serde_json::Value) -> Self {
        serde_json::from_value(value.clone()).unwrap_or(ContractValidationInput {
            mode: None,
            contract_path: None,
            task_number: None,
            modified_files: None,
        })
    }
}
```

### Task 3: Migrate security_filter.rs to typed input

Refactor `security_filter::handle()` to use `SecurityFilterInput`:

1. Parse input: `let typed = SecurityFilterInput::from_hook_input(input);`
2. Replace `input.data.get("tool_name").and_then(|v| v.as_str())` with `typed.tool_name.as_deref()`
3. Replace `extract_file_path(&input.data)` with direct field access on `typed.tool_input`
4. Keep the `extract_file_path` private function as a fallback for backward compat,
   but prefer the typed path when `tool_input` is present
5. All existing tests must continue to pass (the HookInput test helpers construct
   raw JSON, so the typed parsing must handle both paths)

### Task 4: Migrate validate_contract hook and lease_lock to typed inputs

**validate_contract.rs**: Refactor `validate_contract_hook()` to use
`ContractValidationInput::from_value(input)` instead of raw `.get()` chains.

**lease_lock.rs**: Change the `acquire`, `renew`, `release` function signatures
to accept `ResourceId` and `&str` for owner (the owner could be a newtype too but
start with the resource). Update the `execute()` CLI entry point to construct
`ResourceId::new(...)` from the parsed arg. This is a targeted change — only the
function signatures and the call site in `execute()` change.

### Task 5: Write tests for newtypes and typed inputs

Add tests:

**domain_types.rs tests:**
1. `test_task_id_as_number` — "3" parses to Some(3), "abc" to None
2. `test_task_id_display` — Display trait outputs the raw string
3. `test_phase_new` — Phase(5).as_u32() == 5
4. `test_resource_id_as_str` — ResourceId::new("src/main.rs").as_str() == "src/main.rs"

**hooks/types.rs tests:**
5. `test_security_filter_input_from_hook_input` — parse known JSON structure
6. `test_security_filter_input_fallback` — bad JSON falls back to None fields
7. `test_contract_validation_input_from_value` — parse known structure
8. `test_contract_validation_input_fallback` — bad JSON falls back to None fields
