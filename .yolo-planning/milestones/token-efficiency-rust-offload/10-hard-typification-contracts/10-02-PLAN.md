---
phase: 10
plan: 2
title: Feature Flag Enum with Compile-Time Exhaustiveness
wave: 1
depends_on: []
must_haves:
  - FeatureFlag Rust enum covering all 22 v2/v3/v4 flags
  - Centralized read_flag(flag, cwd) function replacing ad-hoc JSON reads
  - At minimum 8 call sites migrated from raw string gets to FeatureFlag enum
  - All existing tests pass + new unit tests for FeatureFlag
---

# Plan 10-02: Feature Flag Enum with Compile-Time Exhaustiveness

## Context

22 feature flags (v2_*, v3_*, v4_*) are read across 16 files via ad-hoc
`.get("v3_lock_lite").and_then(|v| v.as_bool()).unwrap_or(false)` patterns.
There is no compile-time guarantee that flag names are correct — a typo
like `v3_lock_lte` silently returns `false`. This plan introduces a
`FeatureFlag` enum and a centralized reader function.

## Files to Modify

- `yolo-mcp-server/src/commands/mod.rs` — Add `pub mod feature_flags;`
- `yolo-mcp-server/src/commands/feature_flags.rs` (NEW) — FeatureFlag enum + reader
- `yolo-mcp-server/src/hooks/validate_contract.rs` — Migrate `read_feature_flags()`
- `yolo-mcp-server/src/hooks/validate_message.rs` — Migrate `read_v2_typed_flag()`
- `yolo-mcp-server/src/commands/lease_lock.rs` — Migrate `is_lock_enabled()` and `is_hard_gates_enabled()`
- `yolo-mcp-server/src/commands/lock_lite.rs` — Migrate flag reads
- `yolo-mcp-server/src/commands/two_phase_complete.rs` — Migrate flag reads
- `yolo-mcp-server/src/commands/log_event.rs` — Migrate flag reads

## Tasks

### Task 1: Create FeatureFlag enum and reader

Create `yolo-mcp-server/src/commands/feature_flags.rs`:

```rust
use serde_json::Value;
use std::fs;
use std::path::Path;

/// All feature flags in the system. Adding a new flag here forces
/// exhaustive handling at compile time.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FeatureFlag {
    V2HardContracts,
    V2HardGates,
    V2TypedProtocol,
    V2RoleIsolation,
    V2TwoPhaseCompletion,
    V2TokenBudgets,
    V3DeltaContext,
    V3ContextCache,
    V3PlanResearchPersist,
    V3Metrics,
    V3ContractLite,
    V3LockLite,
    V3ValidationGates,
    V3SmartRouting,
    V3EventLog,
    V3SchemaValidation,
    V3SnapshotResume,
    V3LeaseLocks,
    V3EventRecovery,
    V3MonorepoRouting,
    V4PostEditTestCheck,
    V4SessionCacheWarm,
}

impl FeatureFlag {
    /// The JSON key in config.json for this flag.
    pub fn key(&self) -> &'static str {
        match self {
            Self::V2HardContracts => "v2_hard_contracts",
            Self::V2HardGates => "v2_hard_gates",
            Self::V2TypedProtocol => "v2_typed_protocol",
            Self::V2RoleIsolation => "v2_role_isolation",
            Self::V2TwoPhaseCompletion => "v2_two_phase_completion",
            Self::V2TokenBudgets => "v2_token_budgets",
            Self::V3DeltaContext => "v3_delta_context",
            Self::V3ContextCache => "v3_context_cache",
            Self::V3PlanResearchPersist => "v3_plan_research_persist",
            Self::V3Metrics => "v3_metrics",
            Self::V3ContractLite => "v3_contract_lite",
            Self::V3LockLite => "v3_lock_lite",
            Self::V3ValidationGates => "v3_validation_gates",
            Self::V3SmartRouting => "v3_smart_routing",
            Self::V3EventLog => "v3_event_log",
            Self::V3SchemaValidation => "v3_schema_validation",
            Self::V3SnapshotResume => "v3_snapshot_resume",
            Self::V3LeaseLocks => "v3_lease_locks",
            Self::V3EventRecovery => "v3_event_recovery",
            Self::V3MonorepoRouting => "v3_monorepo_routing",
            Self::V4PostEditTestCheck => "v4_post_edit_test_check",
            Self::V4SessionCacheWarm => "v4_session_cache_warm",
        }
    }
}

/// Read a feature flag from the project config.
/// Returns false if config is missing, unreadable, or flag is absent.
pub fn is_enabled(flag: FeatureFlag, cwd: &Path) -> bool {
    let config_path = cwd.join(".yolo-planning").join("config.json");
    read_flag_from_path(flag, &config_path)
}

/// Read a feature flag from a specific config file path.
pub fn read_flag_from_path(flag: FeatureFlag, config_path: &Path) -> bool {
    if !config_path.exists() {
        return false;
    }
    let content = match fs::read_to_string(config_path) {
        Ok(c) => c,
        Err(_) => return false,
    };
    let config: Value = match serde_json::from_str(&content) {
        Ok(v) => v,
        Err(_) => return false,
    };
    config
        .get(flag.key())
        .and_then(|v| v.as_bool())
        .unwrap_or(false)
}
```

Register in `commands/mod.rs`: add `pub mod feature_flags;`

### Task 2: Migrate validate_contract.rs

Replace `read_feature_flags()` in `hooks/validate_contract.rs`:

- Add `use crate::commands::feature_flags::{self, FeatureFlag};`
- Replace `read_feature_flags()` body with:
  ```rust
  let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
  let v3_lite = feature_flags::is_enabled(FeatureFlag::V3ContractLite, &cwd);
  let v2_hard = feature_flags::is_enabled(FeatureFlag::V2HardContracts, &cwd);
  ```
- Remove the old `read_feature_flags()` private function

### Task 3: Migrate validate_message.rs and lease_lock.rs

**validate_message.rs**: Replace `read_v2_typed_flag()` with:
```rust
let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
feature_flags::is_enabled(FeatureFlag::V2TypedProtocol, &cwd)
```
Remove the old private function.

**lease_lock.rs**: Replace `is_lock_enabled()` and `is_hard_gates_enabled()` with
calls to `feature_flags::is_enabled()` using `FeatureFlag::V3LockLite` and
`FeatureFlag::V2HardGates`. Remove both private functions.

### Task 4: Migrate lock_lite.rs, two_phase_complete.rs, log_event.rs

Apply the same pattern: find ad-hoc `.get("v3_...")` or `.get("v2_...")` reads
and replace with `feature_flags::is_enabled(FeatureFlag::Xxx, &cwd)`.

Remove the private helper functions that become unused.

### Task 5: Write unit tests for FeatureFlag

Add tests in `feature_flags.rs`:

1. `test_all_flags_have_unique_keys` — iterate all variants, collect keys into a HashSet, assert count matches
2. `test_flag_key_matches_defaults` — load `config/defaults.json`, verify every `FeatureFlag::key()` exists in it
3. `test_is_enabled_true` — create temp config with a flag set true, verify `is_enabled` returns true
4. `test_is_enabled_false` — create temp config with flag false, verify false
5. `test_is_enabled_missing_config` — no config file => false
6. `test_is_enabled_missing_key` — config exists but flag key absent => false
