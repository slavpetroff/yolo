---
phase: 11
plan: 1
title: MCP Tool Retry with Exponential Backoff and Circuit Breaker
wave: 1
depends_on: []
must_haves:
  - Exponential backoff retry (100ms base, 3 retries, jitter) wrapping all 5 MCP tool calls
  - Circuit breaker disables tool after 5 consecutive failures, resets after 60s
  - Telemetry tracks retry count per tool call
  - All existing server.rs and tools.rs tests pass
---

# Plan 11-01: MCP Tool Retry with Exponential Backoff and Circuit Breaker

## Context

The MCP server dispatches tool calls via `tools::handle_tool_call()` in `server.rs` with zero retry logic. Any transient failure (filesystem hiccup, git timeout, temporary lock contention) causes instant task failure. This plan adds a retry layer at the server dispatch level and a circuit breaker that disables tools after repeated failures.

The retry wrapper sits in `server.rs` around the `tools::handle_tool_call()` call. The circuit breaker state lives in a new `retry.rs` module under `src/mcp/`. This keeps `tools.rs` untouched (Plan 3 owns that file).

## Files to Modify

| File | Action | What Changes |
|------|--------|-------------|
| `yolo-mcp-server/src/mcp/retry.rs` | **CREATE** | RetryConfig, CircuitBreaker, retry_tool_call() wrapper |
| `yolo-mcp-server/src/mcp/mod.rs` | EDIT | Add `pub mod retry;` |
| `yolo-mcp-server/src/mcp/server.rs` | EDIT | Wrap `tools::handle_tool_call()` with retry logic, pass circuit breaker state |

## Tasks

### Task 1: Create retry module with RetryConfig and CircuitBreaker

Create `yolo-mcp-server/src/mcp/retry.rs` with:
- `RetryConfig` struct: `max_retries: u32` (default 3), `base_delay_ms: u64` (default 100), `max_delay_ms: u64` (default 1000)
- `CircuitBreaker` struct: tracks per-tool failure counts and open/closed state. Fields: `failure_counts: HashMap<String, u32>`, `open_until: HashMap<String, Instant>`, `failure_threshold: u32` (default 5), `reset_duration: Duration` (default 60s)
- `CircuitBreaker::is_open(tool_name) -> bool`: returns true if tool is in open state and reset time has not passed
- `CircuitBreaker::record_success(tool_name)`: resets failure count for tool
- `CircuitBreaker::record_failure(tool_name)`: increments count, opens circuit if threshold reached
- Unit tests for retry config defaults, circuit breaker open/close transitions, and reset after duration

**Commit:** `feat(mcp): add retry config and circuit breaker module`

### Task 2: Implement retry_tool_call async wrapper

In `retry.rs`, add:
- `async fn retry_tool_call(name, params, state, config, breaker) -> (Value, RetryStats)` where `RetryStats { attempts: u32, retried: bool }`
- Logic: check circuit breaker first (return error if open), then call `tools::handle_tool_call()`, check if result has `"isError": true`, retry with exponential backoff + jitter if so, update circuit breaker on final success/failure
- Jitter: add random 0-50% of delay using simple `SystemTime` nanosecond mod
- Non-retryable errors: if error message contains "Unknown tool" or "No test_path" (input validation errors), do not retry
- Unit tests with mock tool results verifying retry count, backoff timing, and circuit breaker integration

**Commit:** `feat(mcp): implement retry_tool_call with exponential backoff and jitter`

### Task 3: Wire retry into server.rs tool dispatch

In `server.rs`:
- Add `Arc<Mutex<retry::CircuitBreaker>>` to the state passed around (add field to a new struct or pass alongside `ToolState`)
- In `handle_request` for `"tools/call"` match arm, replace direct `tools::handle_tool_call()` with `retry::retry_tool_call()`
- Pass `RetryConfig::default()` and the circuit breaker
- Include `retry_stats.attempts` in telemetry (add to `record_tool_call` or log separately)
- Update `mod.rs` to add `pub mod retry;`
- Ensure all existing `server.rs` tests still pass

**Commit:** `feat(mcp): wire retry and circuit breaker into MCP tool dispatch`

### Task 4: Add telemetry for retry events

In `server.rs` `handle_request`:
- When `retry_stats.retried` is true, log a telemetry event with tool name, attempt count, and whether circuit breaker opened
- Add `retry_count` field to the telemetry `record_tool_call` invocation (or append as a separate event)
- Verify via test: call a tool that fails, check telemetry DB has retry count > 0

**Commit:** `feat(mcp): track retry count and circuit breaker events in telemetry`

### Task 5: Integration tests for retry and circuit breaker

Add integration tests in `server.rs` tests module:
- Test that a tool returning `isError: true` is retried up to 3 times
- Test that after 5 consecutive failures the circuit breaker opens and returns error immediately
- Test that circuit breaker resets after the configured duration
- Test that input validation errors (e.g., "Unknown tool") are NOT retried

**Commit:** `test(mcp): add integration tests for retry and circuit breaker`
