---
phase: 11
plan: 2
title: Atomic File Writes with Checksum Validation
wave: 1
depends_on: []
must_haves:
  - Atomic write function using temp file + rename pattern
  - SHA256 sidecar .sha256 files written alongside critical state files
  - Checksum validation on read with automatic backup restore on mismatch
  - Critical write paths converted (execution-state.json, event-log.jsonl, config.json writes)
  - All existing tests pass
---

# Plan 11-02: Atomic File Writes with Checksum Validation

## Context

Critical state files (`execution-state.json`, `event-log.jsonl`, config) are written with bare `fs::write()` which is non-atomic -- a crash mid-write corrupts the file with no recovery path. This plan introduces an `atomic_io` module with write-via-temp-rename, SHA256 sidecar verification, and backup-restore on checksum mismatch.

This plan touches only `src/commands/` files. The MCP layer (`src/mcp/`) is untouched (owned by Plans 1 and 3).

## Files to Modify

| File | Action | What Changes |
|------|--------|-------------|
| `yolo-mcp-server/src/commands/atomic_io.rs` | **CREATE** | atomic_write(), read_verified(), checksum helpers |
| `yolo-mcp-server/src/commands/mod.rs` | EDIT | Add `pub mod atomic_io;` |
| `yolo-mcp-server/src/commands/state_updater.rs` | EDIT | Replace `fs::write` calls for STATE.md with atomic_write |
| `yolo-mcp-server/src/commands/persist_state.rs` | EDIT | Replace `fs::write` for output state file with atomic_write |
| `yolo-mcp-server/src/commands/log_event.rs` | EDIT | No change needed (append-only is already safe); add .sha256 for event-log rotation |

## Tasks

### Task 1: Create atomic_io module with core write and checksum functions

Create `yolo-mcp-server/src/commands/atomic_io.rs` with:
- `pub fn atomic_write(path: &Path, content: &[u8]) -> io::Result<()>`: write to `{path}.tmp.{pid}`, fsync, rename to `{path}`. On rename failure, remove temp file.
- `pub fn write_checksum(path: &Path, content: &[u8]) -> io::Result<()>`: compute SHA256 of content, write hex string to `{path}.sha256`
- `pub fn verify_checksum(path: &Path) -> Result<bool, io::Error>`: read file + sidecar, compare digests. Returns Ok(false) if sidecar missing (backwards compat).
- `pub fn atomic_write_with_checksum(path: &Path, content: &[u8]) -> io::Result<()>`: combines atomic_write + write_checksum + write backup `.backup`
- Unit tests: write+verify roundtrip, checksum mismatch detection, missing sidecar returns Ok(false)

**Commit:** `feat(commands): add atomic_io module with checksummed atomic writes`

### Task 2: Add backup-restore on checksum mismatch

In `atomic_io.rs`, add:
- `pub fn read_verified(path: &Path) -> io::Result<Vec<u8>>`: read file, verify checksum; if mismatch, attempt to read `{path}.backup`, log recovery event to stderr, return backup content. If backup also fails, return the original content with a warning.
- `pub fn read_verified_string(path: &Path) -> io::Result<String>`: convenience wrapper returning String
- Backup file is written by `atomic_write_with_checksum` (copy current file to `.backup` before overwriting)
- Unit tests: corrupt file triggers backup restore, missing backup falls through gracefully

**Commit:** `feat(commands): add read_verified with backup restore on checksum mismatch`

### Task 3: Convert state_updater.rs to use atomic writes

In `state_updater.rs`:
- Replace `fs::write(&state_md, ...)` calls (lines 48, 171, 309, 386, 453) with `atomic_io::atomic_write_with_checksum()`
- Import `use super::atomic_io;`
- The file writes `STATE.md`, `ROADMAP.md`, and `execution-state.json` -- all are critical state
- Add `pub mod atomic_io;` to `mod.rs`
- Verify all existing `state_updater` tests pass unchanged

**Commit:** `refactor(commands): use atomic writes in state_updater for crash safety`

### Task 4: Convert persist_state.rs to use atomic writes

In `persist_state.rs`:
- Replace `fs::write(&output_path, &output)` (line 46) with `atomic_io::atomic_write_with_checksum()`
- Import `use super::atomic_io;`
- Verify existing tests pass

**Commit:** `refactor(commands): use atomic writes in persist_state for crash safety`

### Task 5: Add integration test for corruption recovery flow

Add tests in `atomic_io.rs`:
- Full end-to-end: write file with checksum, corrupt the file manually (flip bytes), call `read_verified`, verify backup content is returned
- Verify `.sha256` sidecar is correct hex digest
- Verify `.backup` file exists after second write
- Verify `atomic_write` cleans up temp file on rename failure (simulate with read-only directory)

**Commit:** `test(commands): add integration tests for atomic write corruption recovery`
