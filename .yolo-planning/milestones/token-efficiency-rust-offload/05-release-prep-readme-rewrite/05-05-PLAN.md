---
phase: "05"
plan: "05"
title: "Add Lifecycle and Design Idioms sections to README"
wave: 1
depends_on: []
must_haves:
  - "New '## Lifecycle' section exists in README.md between 'Architecture' and 'Features'"
  - "Covers the full vibe flow: Bootstrap → Scope → Plan → Execute → Verify → Archive"
  - "Each stage explains what happens, what artifacts are produced, and what agents are involved"
  - "New '## Design Decisions' section exists after 'Features'"
  - "Covers: file system as state machine, platform vs instruction enforcement, effort × model orthogonality, hard shutdown gate, ground truth persistence"
  - "Both sections combined under 130 lines"
---

# Plan 05: Add Lifecycle and Design Idioms Sections to README

## Goal

Add two sections to README.md: a "Lifecycle" section explaining what actually happens at each stage of `/yolo:vibe`, and a "Design Decisions" section explaining the key architectural patterns and WHY they exist. Together these transform the README from "here's what you get" to "here's how it works and why we built it this way."

## Tasks

### Task 1: Write the Lifecycle section

**Files:** `README.md`

Add a `## Lifecycle` section after Architecture (which Plan 04 adds) and before Features. Structure as a flow:

#### The `/yolo:vibe` State Machine (~10 lines)

```
/yolo:vibe
    ├─ No project?     → Bootstrap (create PROJECT.md, REQUIREMENTS.md, ROADMAP.md)
    ├─ No phases?      → Scope (decompose into 3-5 phases)
    ├─ Unplanned phase? → Plan (spawn Lead to write PLAN.md files)
    ├─ Unexecuted plan? → Execute (spawn Dev team in parallel waves)
    ├─ All done?       → Archive (audit, milestone, tag)
    └─ Natural language → Route by intent (discuss/plan/build/verify)
```

One command, run repeatedly. State persists in `.yolo-planning/` — close terminal, come back tomorrow, it picks up where you left off.

#### Bootstrap (~10 lines)

- Creates PROJECT.md (identity), REQUIREMENTS.md (what to build), ROADMAP.md (phases)
- Auto-detects project profile → controls how many discovery questions to ask (0 for yolo profile, 5-8 for production)
- For existing codebases: chains `/yolo:map` which runs Scout agents to analyze your code into 7 structured documents (STACK.md, ARCHITECTURE.md, CONVENTIONS.md, etc.)

#### Plan (~15 lines)

- Spawns Lead agent with compiled context (Tier 1+2+3) prefix-injected
- Lead writes `{NN-MM}-PLAN.md` files with YAML frontmatter: `wave` (parallel group), `depends_on` (ordering), `must_haves` (verification targets)
- Same-wave plans get disjoint file assignments → Dev agents can work in parallel without conflicts
- **Hard gate**: Lead team is shut down completely before execution begins (prevents lingering agents burning credits)
- At Turbo effort: skips Lead entirely, orchestrator writes a single lightweight plan inline

#### Execute (~20 lines)

- Creates team (`TeamCreate`), compiles Dev context (prefix-first for cache hits)
- Spawns one `yolo-dev` per uncompleted plan — same-wave plans run in parallel
- Each Dev: `acquire_lock` → implement tasks → `run_test_suite` → `release_lock` → atomic commit
- Wave 2 plans auto-unblock when wave 1 completes (orchestrator sends "your task is now unblocked")
- Crash recovery: `.execution-state.json` tracks wave state; on resume, reconciles against existing SUMMARY.md files and git log
- **Hard gate**: ALL Dev agents shut down before verification (mandatory `shutdown_request` → `shutdown_response` → `TeamDelete`)

#### Verify (~10 lines)

- 3-tier verification runs automatically after execution based on effort level:
  - **Quick** (fast effort): artifact existence, frontmatter valid, no placeholders
  - **Standard** (balanced): + content structure, convention compliance, anti-pattern scan
  - **Deep** (thorough): + requirement-to-artifact tracing, cross-file consistency, dead import detection
- Goal-backward methodology: starts from success criteria, traces backward to verify each claim
- `/yolo:verify` adds human acceptance testing: CHECKPOINT prompts presented one at a time

#### Archive (~8 lines)

- 6-point audit: phases complete, plans have summaries, verification passed, requirements mapped
- Moves artifacts to `.yolo-planning/milestones/{slug}/`
- Extracts persistent state (todos, decisions, skills) into fresh STATE.md
- Git tag + optional GitHub release

### Task 2: Write the Design Decisions section

**Files:** `README.md`

Add a `## Design Decisions` section after "Features" and before "Effort Profiles". These are the WHY behind the architecture — the patterns that make YOLO different from "just telling Claude to plan and code."

#### File System as State Machine (~8 lines)

- Phase detection scans for PLAN.md / SUMMARY.md file pairs — not STATE.md
- If a PLAN.md exists without a matching SUMMARY.md, the phase needs execution. If both exist, it's complete.
- This makes the system crash-safe: even if STATE.md is corrupted or context is compacted, scanning file existence reconstructs the full state
- `/yolo:resume` works without a prior `/yolo:pause` because the files ARE the state

#### Platform-Enforced vs Instruction-Based Permissions (~10 lines)

- **Platform-enforced** (cannot be overridden by agents, even during compaction):
  - `security_filter` hook blocks .env/.pem/credentials before the tool runs (Rust, exit code 2)
  - `permissionMode: plan` on Debugger and Reviewer — Claude Code prevents writes at the platform level
  - MCP `acquire_lock` conflict returns `isError: true` — tool-level rejection
- **Instruction-based** (protocol compliance, enforced by agent definition):
  - Lead never implements, only delegates
  - Dev never edits without acquiring lock first
  - Docs agent stays within documentation file scope
- Two layers because compaction can erase instructions, but platform enforcement survives compaction

#### Hard Shutdown Gate (~8 lines)

- Before ANY phase transition, every active teammate receives `shutdown_request` and must respond with `shutdown_response(approved=true)`
- Without this: each `/yolo:vibe` spawns new agents while old ones linger in tmux, burning API credits
- This was the #1 user-reported cost issue — mandatory shutdown is the fix
- 3 retries per agent before force-proceeding with a warning

#### Effort × Model Profile Orthogonality (~8 lines)

- **Effort** controls workflow depth: how much planning, verification depth, team communication
- **Model profile** controls which Claude model each agent uses (Opus/Sonnet/Haiku)
- They compose independently: Thorough effort + Budget models = deep workflow, cheap execution. Fast effort + Quality models = quick workflow, best output
- This means "cheap" doesn't mean "sloppy" — you can have full verification with budget models, or skip verification with expensive models

#### Ground Truth Persistence (~6 lines)

- State is triply-redundant: file system (PLAN/SUMMARY pairs), STATE.md (human-readable), .execution-state.json (machine-readable)
- The Rust binary reads file system directly for phase detection — STATE.md is for humans
- `.compaction-marker` written by PreCompact hook tells SessionStart whether to skip re-initialization
- Agents re-read PLAN.md from disk after compaction (working memory was wiped, but files persist)

### Task 3: Verify total README line count and coherence

**Files:** `README.md`

- Confirm total README stays under 750 lines (current ~497 + ~120 architecture + ~130 lifecycle/idioms = ~747)
- Read the full README start-to-finish to verify the flow makes sense: value → quick start → how it works → reference tables
- Verify no duplicate content between Architecture, Lifecycle, Features, and Design Decisions sections
