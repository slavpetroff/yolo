---
phase: "05"
plan: "04"
title: "Add Architecture section to README"
wave: 1
depends_on: []
must_haves:
  - "New '## Architecture' section exists in README.md between 'The Agents' and 'Features'"
  - "Covers: Rust binary as platform layer, 3-tier compiled context, hook system, MCP file locking"
  - "Includes a text-based architecture diagram showing binary + hooks + MCP + agents"
  - "Explains WHY each layer exists (token savings, crash safety, cache hits)"
  - "Section under 120 lines total"
---

# Plan 04: Add Architecture Section to README

## Goal

Add an "Architecture" section to README.md that explains HOW the plugin works internally — the Rust binary layer, the 3-tier compiled context system, the hook dispatcher, and MCP file locking. This transforms the README from a feature catalog into a document that helps users (and contributors) understand the system design.

## Placement

After "The Agents" section (line ~211) and before "Features" section (line ~218). The agents table establishes WHO does what; the architecture section explains HOW they coordinate.

## Tasks

### Task 1: Write the Architecture section

**Files:** `README.md`

Add a new `## Architecture` section with these subsections:

#### 1. Overview diagram (text-based, ~15 lines)

Show the three layers:
```
┌─────────────────────────────────────────────┐
│  /yolo:vibe                                 │
│  Claude Code orchestrator                   │
│  Routes: scope → plan → execute → archive   │
├─────────────────────────────────────────────┤
│  Agent Teams                                │
│  Lead (plans) → Dev×N (parallel execute)    │
│  Architect (roadmaps) · Debugger (bugs)     │
│  Docs (documentation) · Reviewer (red team) │
├─────────────────────────────────────────────┤
│  Rust Binary (yolo)         MCP Server      │
│  61 CLI commands            5 tools         │
│  11 hook handlers           File locks      │
│  Context compiler           Test runner     │
│  State machine              HITL gates      │
│  Zero LLM tokens            In-process      │
└─────────────────────────────────────────────┘
```

#### 2. Rust Binary as Platform Layer (~20 lines)

Explain:
- The `yolo` binary handles ALL infrastructure — hooks, context compilation, state detection, model resolution, telemetry — without consuming LLM tokens
- When Claude Code starts, hooks route through `yolo hook <EventName>` (native Rust, <5ms)
- When `/yolo:vibe` runs, the binary pre-computes state (`yolo phase-detect`) and injects it before any Claude reasoning begins
- CLI mode for commands, MCP server mode for agent-accessible tools
- This is WHY the "Base context overhead" drops from 10,800 → 1,500 tokens: infrastructure that other approaches handle with LLM prompts, YOLO handles with compiled code

#### 3. 3-Tier Compiled Context (~25 lines)

Explain the prompt caching optimization:
```
Tier 1: Shared Base (CONVENTIONS.md + STACK.md)
  → Byte-identical for ALL agents in the phase
  → Single API cache write, shared by entire team

Tier 2: Role Family (planning: ARCHITECTURE.md | execution: ROADMAP.md)
  → Byte-identical within role family
  → All Dev agents share one cache entry

Tier 3: Volatile Tail (phase-specific goal + current delta)
  → Changes per plan — always a cache miss, but small
```

- Agents receive `{DEV_CONTEXT}` at position 0 in their Task description (prefix-first injection)
- Tier 1+2 is identical across all same-family agents → Anthropic API caches it as one shared prefix
- Mtime-based filesystem cache at `/tmp/yolo-tier-cache-{uid}/` avoids re-reading source files when unchanged
- This is WHY "Context duplication" drops from 16,500 → 900 tokens: 4 Dev agents share one cached prefix instead of each loading the full codebase independently

#### 4. Hook System (~20 lines)

Explain:
- 21 hooks across 11 event types, all routed through `yolo hook <EventName>`
- `PreToolUse` is the only blocking hook — security filter can DENY tool calls (exit code 2)
- `PostToolUse` hooks are advisory — validate summaries, check commit format, but can't block
- Agent lifecycle hooks (`SubagentStart/Stop`, `TeammateIdle`, `TaskCompleted`) track health and coordinate shutdown
- `SessionStart` detects compaction, runs config migration, checks map staleness
- This is WHY "21 hooks for continuous verification" works at zero token cost — the Rust binary validates, not an LLM

#### 5. MCP File Locking (~15 lines)

Explain:
- Parallel Dev agents need coordination — they can't both write the same file
- `acquire_lock(file_path, task_id)` / `release_lock(file_path, task_id)` are in-memory mutex operations inside the MCP server process
- No shell flock, no git stash, no separate coordination agent
- The Lead assigns disjoint file sets to same-wave plans at planning time; locks are the runtime safety net
- `run_test_suite(test_path)` lets Dev agents verify their own work natively without spawning a QA agent

### Task 2: Verify section placement and cross-references

**Files:** `README.md`

- Confirm the new Architecture section renders correctly in GitHub markdown preview
- Verify no broken anchor links from Table of Contents (if one exists)
- Confirm total README stays under 620 lines (current ~497 + ~120 new = ~617)
