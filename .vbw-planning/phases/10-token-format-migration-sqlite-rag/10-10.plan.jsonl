{"phase":10,"plan":"10-10","title":"TOON output format for remaining references and ROADMAP elimination","wave":3,"depends_on":["10-01","10-06"],"must_haves":["ROADMAP.md parsed once into phases table","Phase metadata served from DB to all roles","Remaining eligible references/*.md files converted to TOON","ROADMAP triplication eliminated (11,811 → 1,200 tokens)"]}
{"id":"T1","title":"Create import-roadmap.sh to parse ROADMAP into phases table","spec":"Create scripts/db/import-roadmap.sh. Usage: import-roadmap.sh --file <ROADMAP_PATH> [--db PATH]. Behavior: Parse ROADMAP.md using awk (same pattern as compile-context.sh OPTIMIZATION 2), extract per-phase: phase_num, goal, reqs, success_criteria, slug. INSERT INTO phases table for each phase. ON CONFLICT(phase_num) DO UPDATE. Also extract milestone name, total phases for state table. This replaces the 3x ROADMAP read pattern: parse once at DB init, serve targeted queries via get-phase.sh. Handle ROADMAP format: '## Phase N: Title' followed by **Goal:**, **Reqs:**, **Success:**.","files":["scripts/db/import-roadmap.sh"],"tests":["tests/unit/db/import-roadmap.bats: parses all phases, extracts goal/reqs/success, idempotent re-import, handles missing sections gracefully"]}
{"id":"T2","title":"Create import-requirements.sh to parse requirements into DB","spec":"Create scripts/db/import-requirements.sh. Usage: import-requirements.sh [--file <PATH>] [--db PATH]. Behavior: (1) If reqs.jsonl exists, read JSONL and INSERT into requirements table (id, title, priority, status, acceptance_criteria), (2) Elif REQUIREMENTS.md exists, parse markdown (REQ-NN patterns) into same table. ON CONFLICT(id) DO UPDATE. This eliminates REQUIREMENTS.md re-reads by multiple roles (Critic, Architect, Lead, QA all read same file). Combined with ROADMAP elimination, saves ~8,000 tokens/phase.","files":["scripts/db/import-requirements.sh"],"tests":["tests/unit/db/import-requirements.bats: imports JSONL format, imports markdown format, idempotent, missing file exit 0"]}
{"id":"T3","title":"Update get-phase.sh to serve ROADMAP data from DB","spec":"Modify scripts/db/get-phase.sh. After import-roadmap.sh populates phases table, get-phase.sh becomes the sole interface for phase metadata. Add --reqs-detail flag that JOINs phases.reqs with requirements table to return full requirement text (not just IDs). Add --all-phases flag for multi-phase overview (replaces reading full ROADMAP). Verify: Architect calling get-phase.sh 09 --goals returns 200 tokens vs ROADMAP.md's 3,937 tokens (95% savings).","files":["scripts/db/get-phase.sh"],"tests":["tests/unit/db/get-phase.bats: --reqs-detail returns full requirement text, --all-phases returns overview, token count under 200"]}
{"id":"T4","title":"Convert eligible references/*.md to TOON format","spec":"Identify references/*.md files that are agent-consumed (not user-facing) and convert to TOON: (1) references/effort-profile-balanced.toon (already TOON, verify), (2) references/company-hierarchy.md → references/company-hierarchy.toon (key:value pairs for hierarchy levels), (3) references/handoff-schemas.md → references/handoff-schemas.toon (schema definitions in compact format), (4) references/teammate-api-patterns.md → references/teammate-api-patterns.toon (pattern:description pairs). Keep markdown files as originals, generate TOON alongside. Update build-reference-packages.sh to include TOON versions.","files":["references/company-hierarchy.toon","references/handoff-schemas.toon","references/teammate-api-patterns.toon"],"tests":["tests/unit/build-reference-packages.bats: TOON files included in packages, TOON format valid (key:value pairs)"]}
{"id":"T5","title":"Wire import-roadmap.sh and import-requirements.sh into init-db.sh","spec":"Modify scripts/db/init-db.sh. After schema creation, add: (1) If ROADMAP.md exists in planning dir, call import-roadmap.sh, (2) If reqs.jsonl or REQUIREMENTS.md exists, call import-requirements.sh, (3) If research-archive.jsonl exists, call import-research-archive.sh, (4) Report imported counts: 'Imported: N phases, M requirements, K research entries'. This makes init-db.sh a one-shot bootstrap that prepopulates the DB with all existing project metadata. Order: schema → roadmap → requirements → research archive → existing artifacts.","files":["scripts/db/init-db.sh"],"tests":["tests/unit/db/init-db.bats: roadmap imported on init, requirements imported, research archive imported, counts reported"]}
