{"phase":10,"plan":"10-06","title":"Migrate compile-context.sh from file scanning to SQL queries","wave":2,"depends_on":["10-01","10-02","10-05"],"must_haves":["All 16+ role case blocks use SQL queries instead of file reads","ROADMAP.md parsed once into DB, queried per-role","Field filtering via SQL SELECT replaces filter-agent-context.sh calls","Budget enforcement preserved","Backward compatible: falls back to file-based when DB absent"]}
{"id":"T1","title":"Add SQL query path to compile-context.sh header and helpers","spec":"Modify scripts/compile-context.sh. Add at top (after MANIFEST_AVAILABLE check): DB_AVAILABLE=false; DB_PATH=\"${PLANNING_DIR}/yolo.db\"; if [ -f \"$DB_PATH\" ]; then DB_AVAILABLE=true; fi. Add helper sql() that wraps sqlite3 with WAL pragma: sql() { sqlite3 -separator ',' \"$DB_PATH\" \"PRAGMA journal_mode=WAL; PRAGMA busy_timeout=5000; $1\"; }. Add helper sql_toon() that formats SQL output as TOON lines with prefix. Modify get_phase_metadata() to use SQL when DB_AVAILABLE: SELECT goal, reqs, success FROM phases WHERE phase_num=?. Keep file-based fallback in else branch. This eliminates the ROADMAP.md parse (3,937 tokens saved per phase).","files":["scripts/compile-context.sh"],"tests":["tests/unit/compile-context-sql.bats: SQL path used when DB exists, file fallback when DB absent, ROADMAP not read when DB available"]}
{"id":"T2","title":"Migrate architect and critic role blocks to SQL","spec":"Modify scripts/compile-context.sh architect case block: Replace get_requirements call with SQL: sql 'SELECT id,t FROM requirements WHERE id IN (...)'. Replace get_research call with SQL: sql 'SELECT q,finding,conf FROM research WHERE phase=?'. Replace codebase @ references with sql query for codebase summaries (if stored). Keep codebase mapping as @ references (those stay as files). Migrate critic case block similarly: SQL for research, requirements; keep codebase references. Both roles should produce identical TOON output whether SQL or file path is used.","files":["scripts/compile-context.sh"],"tests":["tests/unit/compile-context-sql.bats: architect TOON output matches file-based for same data, critic TOON output matches"]}
{"id":"T3","title":"Migrate lead, senior, dev role blocks to SQL","spec":"Modify scripts/compile-context.sh. Lead: Replace get_architecture with SQL query for architecture summary, get_decisions with SQL from decisions table, test-results with SQL. Senior: Replace rolling summaries with SQL query, architecture with SQL, patterns stays as @ reference, suggestions with SQL from summaries.sg field. Dev: Replace plan task extraction with sql 'SELECT task_id,action,files,done,spec FROM tasks WHERE plan_id=? AND phase=?' (the key 93% savings: 1,064→75 tokens). Rolling summaries and error recovery via SQL. All three roles produce identical TOON format output.","files":["scripts/compile-context.sh"],"tests":["tests/unit/compile-context-sql.bats: dev TOON matches file-based, lead decisions from SQL, senior summaries from SQL"]}
{"id":"T4","title":"Migrate qa, qa-code, security, tester role blocks to SQL","spec":"Modify scripts/compile-context.sh. QA: get_all_plan_summaries via SQL, test_results via SQL, plan_context (must_haves, objective) via SQL, escalation counts via SQL. QA-code: summaries via SQL, files_to_check from summaries.fm via SQL. Security: files_to_audit from summaries.fm via SQL. Tester: enriched plan tasks with test_spec via SQL. All produce identical TOON output. The QA path benefits most: currently reads N summary files (2000+ tokens) → single SQL query (300 tokens).","files":["scripts/compile-context.sh"],"tests":["tests/unit/compile-context-sql.bats: qa summaries from SQL, security files list from SQL, tester task specs from SQL"]}
{"id":"T5","title":"Migrate remaining role blocks and add DB population hook","spec":"Modify scripts/compile-context.sh. Migrate: owner (department results + escalation via SQL), integration-gate (dept status + test results + contracts via SQL), debugger (research + gaps via SQL), scout (critique queries via SQL), po/questionary/roadmap (requirements + summaries via SQL). Also add a populate hook: if DB_AVAILABLE and artifact files are newer than DB (stat mtime comparison), call import-jsonl.sh to sync. This ensures DB stays current when artifacts are written by non-DB-aware code paths during migration period.","files":["scripts/compile-context.sh"],"tests":["tests/unit/compile-context-sql.bats: owner TOON from SQL, integration-gate from SQL, populate hook triggers on stale DB"]}
