{"phase":10,"plan":"10-04","title":"Task queue scripts for agent coordination","wave":1,"depends_on":[],"must_haves":["next-task.sh returns exactly 1 unblocked pending task","next-review.sh returns completed tasks needing QA","check-phase-status.sh provides completion percentage","Atomic task claiming prevents double-assignment","All queue operations are transactional"]}
{"id":"T1","title":"Create next-task.sh for task self-assignment","spec":"Create scripts/db/next-task.sh. Usage: next-task.sh [--dept DEPT] [--plan PLAN_ID] [--db PATH]. Behavior: (1) Find next pending task where all task_depends are 'complete' (unblocked), (2) Atomically UPDATE status='in_progress', assigned_to=current agent, (3) Return task in TOON format: 'id: T3\\nplan: 09-02\\naction: Create auth middleware\\nspec: ...\\nfiles: src/auth.ts'. Uses UPDATE ... WHERE status='pending' AND task_id = (SELECT ...) for atomic claim (no race conditions between parallel agents). --dept filters by plan's department. --plan filters to specific plan. If no tasks available, exit 0 with empty output. ORDER BY plan_id ASC, task_id ASC (natural ordering).","files":["scripts/db/next-task.sh"],"tests":["tests/unit/db/next-task.bats: returns unblocked task, skips blocked tasks, atomic claim works, empty when all complete, dept filter works"]}
{"id":"T2","title":"Create next-review.sh for QA task polling","spec":"Create scripts/db/next-review.sh. Usage: next-review.sh [--plan PLAN_ID] [--phase PHASE] [--db PATH]. Behavior: SELECT tasks WHERE status='complete' AND NOT EXISTS (SELECT 1 FROM code_review WHERE code_review.plan=tasks.plan_id AND code_review.task_id=tasks.task_id). Returns tasks that are complete but not yet reviewed. Output TOON format listing: 'T1,09-02,Create auth middleware,complete,2026-02-19'. Multiple lines for multiple ready-for-review tasks. If --plan specified, filter to that plan only. ORDER BY completed_at ASC (oldest completed first).","files":["scripts/db/next-review.sh"],"tests":["tests/unit/db/next-review.bats: returns completed unreviewed tasks, filters by plan, empty when all reviewed"]}
{"id":"T3","title":"Create check-phase-status.sh for orchestrator status checks","spec":"Create scripts/db/check-phase-status.sh. Usage: check-phase-status.sh <PHASE> [--db PATH] [--json]. Behavior: Query tasks and summaries for phase, compute: total_plans, completed_plans, total_tasks, completed_tasks, pending_tasks, in_progress_tasks, blocked_tasks, completion_pct. Default output TOON: 'phase: 09\\nplans: 5/7 complete\\ntasks: 28/35 complete (80%)\\nblocked: 2\\nin_progress: 3'. --json flag outputs JSON object. Also include per-plan breakdown. This replaces the glob+read pattern in phase-detect.sh and state-updater.sh for tracking progress.","files":["scripts/db/check-phase-status.sh"],"tests":["tests/unit/db/check-phase-status.bats: correct counts, percentage calculation, JSON output, per-plan breakdown, handles empty phase"]}
{"id":"T4","title":"Create claim-task.sh for explicit task claiming","spec":"Create scripts/db/claim-task.sh. Usage: claim-task.sh --plan <PLAN_ID> --task <TASK_ID> --agent <AGENT_NAME> [--db PATH]. Behavior: Atomic UPDATE tasks SET status='in_progress', assigned_to=? WHERE plan_id=? AND task_id=? AND status='pending'. Exit 1 if task not found, already claimed, or not pending. Uses sqlite3 'changes()' function to verify exactly 1 row updated. Print 'claimed T3 for agent dev' on success. This is the explicit version of next-task.sh's auto-claim â€” used when Lead assigns specific tasks.","files":["scripts/db/claim-task.sh"],"tests":["tests/unit/db/claim-task.bats: claims pending task, rejects already-claimed, rejects non-existent, prints confirmation"]}
{"id":"T5","title":"Create release-task.sh for unclaiming and retry","spec":"Create scripts/db/release-task.sh. Usage: release-task.sh --plan <PLAN_ID> --task <TASK_ID> [--reason TEXT] [--db PATH]. Behavior: UPDATE tasks SET status='pending', assigned_to=NULL WHERE plan_id=? AND task_id=? AND status='in_progress'. For retry scenarios (task failed, agent crashed). Optionally appends reason to gaps table as retry context. Exit 1 if task not in_progress. Print 'released T3 back to pending'. This enables the error recovery flow currently handled by gaps.jsonl retry_context field.","files":["scripts/db/release-task.sh"],"tests":["tests/unit/db/release-task.bats: releases in_progress task, rejects non-in-progress, stores retry reason in gaps, prints confirmation"]}
