{"phase":10,"plan":"10-03","title":"Write scripts for artifact ingestion and status updates","wave":1,"depends_on":[],"must_haves":["insert-task.sh handles all plan task fields","complete-task.sh updates status atomically","append-finding.sh supports all append-only artifact types","update-status.sh handles state transitions","All writes use transactions for atomicity"]}
{"id":"T1","title":"Create insert-task.sh for task ingestion","spec":"Create scripts/db/insert-task.sh. Usage: insert-task.sh --plan <PLAN_ID> --id <TASK_ID> --action <TEXT> [--spec TEXT] [--files FILE1,FILE2] [--verify TEXT] [--done TEXT] [--test-spec TEXT] [--deps T1,T2] [--db PATH]. Behavior: INSERT INTO tasks (plan_id, task_id, action, spec, files, verify, done, test_spec, task_depends, status) VALUES (?,?,?,?,?,?,?,?,?,'pending') ON CONFLICT(plan_id, task_id) DO UPDATE SET ... (idempotent upsert). Files and deps stored as JSON arrays. Must use set -euo pipefail. Transaction wrapper via db-common.sh sql_exec().","files":["scripts/db/insert-task.sh"],"tests":["tests/unit/db/insert-task.bats: inserts task, upsert updates existing, JSON arrays stored correctly, missing required fields exit 1"]}
{"id":"T2","title":"Create complete-task.sh for task completion","spec":"Create scripts/db/complete-task.sh. Usage: complete-task.sh <TASK_ID> --plan <PLAN_ID> [--files FILE1,FILE2] [--summary TEXT] [--commit HASH] [--db PATH]. Behavior: UPDATE tasks SET status='complete', completed_at=datetime('now'), files_written=?, summary=? WHERE plan_id=? AND task_id=? AND status IN ('pending','in_progress'). Exit 1 if task not found or already complete. Also trigger FTS5 rebuild if summary contains searchable content. Print updated task status to stdout.","files":["scripts/db/complete-task.sh"],"tests":["tests/unit/db/complete-task.bats: completes pending task, rejects already-complete, stores files_written, exit 1 on missing task"]}
{"id":"T3","title":"Create append-finding.sh for append-only artifacts","spec":"Create scripts/db/append-finding.sh. Usage: append-finding.sh --type <TYPE> --phase <PHASE> --data <JSON> [--db PATH]. Supported types: critique, research, decisions, escalation, gaps, code-review-comment, security-finding, qa-gate-result. Behavior: Parse JSON data, INSERT into appropriate table. For research: also INSERT INTO research_fts. For decisions: also INSERT INTO decisions_fts. For gaps: also INSERT INTO gaps_fts. Validate required fields per type (critique needs id,cat,sev,q; research needs q,finding,conf). Exit 1 on unknown type or missing required fields.","files":["scripts/db/append-finding.sh"],"tests":["tests/unit/db/append-finding.bats: inserts critique, research updates FTS, rejects unknown type, validates required fields"]}
{"id":"T4","title":"Create update-status.sh for state transitions","spec":"Create scripts/db/update-status.sh. Usage: update-status.sh --type <TYPE> --id <ID> --status <STATUS> [--phase PHASE] [--resolution TEXT] [--db PATH]. Supported types: task (pending→in_progress→complete), escalation (open→escalated→resolved), gap (open→fixed→accepted), critique (open→addressed→deferred→rejected). Behavior: UPDATE {table} SET st=?, res=? WHERE id=? AND phase=?. Validate state transitions (no backward moves except critique→rejected). Exit 1 on invalid transition. Print previous→new status to stdout.","files":["scripts/db/update-status.sh"],"tests":["tests/unit/db/update-status.bats: valid transitions succeed, invalid transitions rejected, resolution stored for escalation, prints status change"]}
{"id":"T5","title":"Create import-jsonl.sh for bulk JSONL ingestion","spec":"Create scripts/db/import-jsonl.sh. Usage: import-jsonl.sh --type <TYPE> --file <PATH> --phase <PHASE> [--db PATH]. Behavior: Read JSONL file line by line, parse with jq, INSERT into appropriate table. For plan files: line 1 is header (INSERT into plans), lines 2+ are tasks (INSERT into tasks). For summary files: single line INSERT into summaries. For multi-line artifacts (critique, research, decisions): INSERT each line. Use BEGIN TRANSACTION / COMMIT for bulk performance. Report: 'Imported N rows into {table} for phase {PHASE}'. This is the migration bridge — used to populate DB from existing JSONL artifacts.","files":["scripts/db/import-jsonl.sh"],"tests":["tests/unit/db/import-jsonl.bats: imports plan file (header + tasks), imports summary, imports multi-line critique, transaction rollback on error"]}
