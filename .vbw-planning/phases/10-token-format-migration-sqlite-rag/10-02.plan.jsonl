{"phase":10,"plan":"10-02","title":"Read query scripts for targeted artifact retrieval","wave":1,"depends_on":[],"must_haves":["get-task.sh returns single task spec in <100 tokens","get-phase.sh returns phase goals without full ROADMAP parse","get-summaries.sh filters by status","get-context.sh returns role-filtered context","All scripts exit 0 on success, 1 on error"]}
{"id":"T1","title":"Create get-task.sh for single-task retrieval","spec":"Create scripts/db/get-task.sh. Usage: get-task.sh <plan-id> <task-id> [--db PATH] [--fields FIELD1,FIELD2]. Behavior: SELECT specified fields (default: task_id, action, files, done, spec) FROM tasks WHERE plan_id=? AND task_id=?. Output TOON format: 'T3,Create auth middleware,src/auth.ts,Tests pass,Express middleware...' (one line, comma-separated). If --fields provided, SELECT only those columns. Uses sqlite3 -separator ',' for output. Exit 1 if task not found. Must use set -euo pipefail. Resolve DB path via helper: db_path() from scripts/db/db-common.sh (shared across all query scripts).","files":["scripts/db/get-task.sh","scripts/db/db-common.sh"],"tests":["tests/unit/db/get-task.bats: returns correct task, field filtering works, exit 1 on missing task, comma-separated output"]}
{"id":"T2","title":"Create get-phase.sh for phase metadata retrieval","spec":"Create scripts/db/get-phase.sh. Usage: get-phase.sh <phase-num> [--db PATH] [--goals] [--reqs] [--success] [--full]. Behavior: Query state table + plans table for phase metadata. --goals: return phase goal text only. --reqs: return requirement IDs linked to phase. --success: return success criteria. --full: return all three. Default is --full. Output TOON format: 'phase: 01\\ngoal: Implement auth\\nreqs: REQ-01,REQ-03\\nsuccess: All tests pass'. Eliminates need to re-read ROADMAP.md (3,937 tokens → ~200 tokens). Store phase metadata in a phases table (add to schema.sql if needed): phase_num, goal, reqs, success_criteria, slug.","files":["scripts/db/get-phase.sh"],"tests":["tests/unit/db/get-phase.bats: returns goal, filters by flag, TOON format output, exit 1 on missing phase"]}
{"id":"T3","title":"Create get-summaries.sh for plan summary retrieval","spec":"Create scripts/db/get-summaries.sh. Usage: get-summaries.sh <phase-num> [--db PATH] [--status STATUS] [--plan PLAN_ID] [--fields FIELD1,FIELD2]. Behavior: SELECT from summaries WHERE phase=?. --status filters (complete/partial/failed). --plan filters to single plan. --fields selects specific columns. Default output: 'plan,status,tasks_completed/total,files_modified' per line. TOON format: '01-01: s=complete tc=5/5 fm=src/auth.ts;src/middleware.ts'. Multiple lines for multiple summaries.","files":["scripts/db/get-summaries.sh"],"tests":["tests/unit/db/get-summaries.bats: returns all summaries, filters by status, filters by plan, field selection works"]}
{"id":"T4","title":"Create get-context.sh for role-filtered context retrieval","spec":"Create scripts/db/get-context.sh. Usage: get-context.sh <phase-num> <role> [--db PATH] [--plan PLAN_ID] [--budget TOKENS]. Behavior: (1) Read context-manifest.json to determine which artifacts and fields the role needs, (2) Query each artifact table with field selection matching manifest, (3) Assemble TOON output with role-specific sections (same format as current .ctx-{role}.toon), (4) Apply budget enforcement if --budget specified (truncation levels same as compile-context.sh). This is the SQL-powered replacement for the role-specific case blocks in compile-context.sh. Start with dev role as proof-of-concept (simplest: just task specs).","files":["scripts/db/get-context.sh"],"tests":["tests/unit/db/get-context.bats: dev role returns task specs only, respects budget, reads manifest fields"]}
{"id":"T5","title":"Create db-common.sh shared helper library","spec":"Create scripts/db/db-common.sh. Shared functions for all DB query/write scripts: (1) db_path() — resolve DB path from --db flag or default .vbw-planning/yolo.db, (2) require_db() — exit 1 if DB not found, (3) sql_query() — wrapper around sqlite3 with WAL pragma and busy_timeout, (4) sql_exec() — wrapper for write operations with BEGIN/COMMIT, (5) check_table() — verify table exists, (6) json_array() — convert sqlite output to JSON array. All functions use local variables. Source pattern: source \"$(dirname $0)/db-common.sh\". Must use set -euo pipefail.","files":["scripts/db/db-common.sh"],"tests":["tests/unit/db/db-common.bats: db_path resolves correctly, require_db fails on missing, sql_query returns results, json_array formats correctly"]}
