{"phase":10,"plan":"10-01","title":"SQLite schema design and database initialization","wave":1,"depends_on":[],"must_haves":["Schema covers all 40+ artifact types","WAL mode enabled by default","FTS5 virtual tables for research/decisions/gaps","init-db.sh creates DB idempotently","Single .db file per milestone"]}
{"id":"T1","title":"Design core artifact tables schema","spec":"Create scripts/db/schema.sql with CREATE TABLE statements for: plans (phase, plan_num, title, wave, depends_on JSON, must_haves JSON, objective, effort, skills JSON, files_modified JSON, autonomous BOOL), tasks (plan_id FK, task_id, type, action, files JSON, verify, done, spec, test_spec, task_depends JSON, status TEXT DEFAULT 'pending', assigned_to, completed_at, files_written JSON, summary TEXT), summaries (plan_id FK, status, date_completed, tasks_completed INT, tasks_total INT, commit_hashes JSON, files_modified JSON, deviations JSON, built JSON, test_status, suggestions JSON). All TEXT columns unless noted. Use JSONL abbreviated key names as column names where practical (p, n, t, w, d for plan header). Include created_at/updated_at timestamps.","files":["scripts/db/schema.sql"],"tests":["tests/unit/db/schema-valid.bats: sqlite3 :memory: < schema.sql succeeds, all tables exist via .tables"]}
{"id":"T2","title":"Design workflow artifact tables","spec":"Add to schema.sql: critique (id, cat, sev, q, ctx, sug, st, cf INT, rd INT, phase), research (q, src, finding, conf, dt, rel, brief_for, mode, priority, ra, rt, resolved_at, phase), research_archive (q, finding, conf, phase, dt, src), decisions (ts, agent, task, dec, reason, alts JSON, phase), escalation (id, dt, agent, reason, sb, tgt, sev, st, res, phase), gaps (id, sev, desc, exp, act, st, res, phase), verification (tier, r, ps INT, fl INT, tt INT, dt, phase -- line 1 summary; checks as separate table or JSON), code_review (plan, r, tdd, cycle INT, dt, sg_reviewed INT, sg_promoted JSON, phase), security_audit (r, findings_count INT, critical_count INT, dt, phase), test_plan (task_id, test_files JSON, test_count INT, red_confirmed BOOL, desc, phase), test_results (plan, dept, tdd_phase, tc INT, ps INT, fl INT, dt, tasks JSON, phase), qa_gate_results (gate_level, r, plan, task, tests JSON, duration_ms INT, files_tested JSON, must_have_coverage JSON, dt, phase).","files":["scripts/db/schema.sql"],"tests":["tests/unit/db/schema-valid.bats: all workflow tables exist, column counts match"]}
{"id":"T3","title":"Design cross-department and state tables","spec":"Add to schema.sql: design_tokens (cat, name, val, sem, dk, phase), component_specs (name, desc, states JSON, props JSON, tokens JSON, a11y JSON, status, phase), user_flows (id, name, steps JSON, err JSON, entry, exit_point, phase), design_handoff (component, status, tokens JSON, phase), api_contracts (endpoint, method, status, dept, phase), po_qa_verdict (r, phase_id, scope_match, findings JSON, action, dt), manual_qa (r, tests JSON, dt, phase), state (ms, ph INT, tt INT, st, step, pr INT, started), execution_state (phase, step, status, started_at, completed_at). Add phase column as partition key on all per-phase tables. Add INDEX on (phase) for all tables, INDEX on (phase, plan) for task-scoped tables.","files":["scripts/db/schema.sql"],"tests":["tests/unit/db/schema-valid.bats: cross-dept tables exist, indexes created"]}
{"id":"T4","title":"Design FTS5 virtual tables","spec":"Add to schema.sql: CREATE VIRTUAL TABLE research_fts USING fts5(q, finding, conf, phase, content=research, content_rowid=rowid); CREATE VIRTUAL TABLE decisions_fts USING fts5(dec, reason, agent, phase, content=decisions, content_rowid=rowid); CREATE VIRTUAL TABLE gaps_fts USING fts5(desc, exp, act, res, phase, content=gaps, content_rowid=rowid). Add triggers to keep FTS indexes in sync: AFTER INSERT, AFTER DELETE, AFTER UPDATE on each content table. Test with: INSERT sample row, SELECT from _fts WHERE _fts MATCH 'keyword'.","files":["scripts/db/schema.sql"],"tests":["tests/unit/db/fts5-search.bats: insert test data, FTS5 MATCH query returns expected rows"]}
{"id":"T5","title":"Create init-db.sh initialization script","spec":"Create scripts/db/init-db.sh. Usage: init-db.sh [--planning-dir PATH] [--force]. Behavior: (1) Resolve DB path: ${PLANNING_DIR:-.vbw-planning}/yolo.db, (2) If DB exists and --force not set, exit 0 (idempotent), (3) sqlite3 $DB_PATH < schema.sql, (4) PRAGMA journal_mode=WAL, (5) PRAGMA busy_timeout=5000, (6) PRAGMA foreign_keys=ON, (7) echo DB path to stdout. Must use set -euo pipefail. Schema file resolved relative to script dir: $(dirname $0)/schema.sql. Add --verify flag that runs PRAGMA integrity_check and counts tables.","files":["scripts/db/init-db.sh"],"tests":["tests/unit/db/init-db.bats: creates DB file, idempotent re-run, WAL mode enabled, --verify passes, --force recreates"]}
