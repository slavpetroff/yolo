{"p":11,"n":1,"t":"Remove DB_AVAILABLE conditionals from compile-context.sh","w":1,"d":[],"mh":["Zero DB_AVAILABLE references in compile-context.sh","DB unavailability triggers fail-fast exit (not silent fallback)","All 20 conditional blocks replaced with DB-only code paths","sql() helper always available (no guard needed)","File fallback code paths completely removed"],"obj":"Strip all 20 DB_AVAILABLE conditional blocks from compile-context.sh, making every DB query unconditional. Remove file-based fallback paths. Add fail-fast on missing DB. Fix planning dir mismatch (PLANNING_DIR references .yolo-planning but DB may be at .vbw-planning)."}
{"id":"11-01-T1","tp":"fix","a":"Fix planning dir resolution to support both .yolo-planning and .vbw-planning","f":["scripts/compile-context.sh"],"v":"grep -c 'PLANNING_DIR=' scripts/compile-context.sh returns 1; script works with --phases-dir .vbw-planning/phases","done":false,"spec":"Line 26 hardcodes PLANNING_DIR='.yolo-planning'. Change to derive PLANNING_DIR from PHASES_DIR: PLANNING_DIR=$(dirname \"$PHASES_DIR\"). This fixes the critical mismatch where go.md creates DB at .vbw-planning/yolo.db but compile-context.sh looks at .yolo-planning/yolo.db. Remove the hardcoded assignment entirely. The PHASES_DIR arg (arg 3) already defaults to .yolo-planning/phases, so PLANNING_DIR will correctly resolve to .yolo-planning when no arg is given, and to .vbw-planning when go.md passes .vbw-planning/phases."}
{"id":"11-01-T2","tp":"refactor","a":"Remove DB_AVAILABLE flag and add fail-fast DB check","f":["scripts/compile-context.sh"],"v":"grep -c 'DB_AVAILABLE' scripts/compile-context.sh returns 0; script exits 1 with error when yolo.db missing","done":false,"spec":"Remove lines 62-66 (DB_AVAILABLE=false/true detection). Replace with mandatory check: DB_PATH=\"${PLANNING_DIR}/yolo.db\"; if [ ! -f \"$DB_PATH\" ]; then echo \"ERROR: Database not found at $DB_PATH. Run init-db.sh first.\" >&2; exit 1; fi. This makes DB a hard requirement. The sql() helper on line 71 already uses DB_PATH directly -- it just needs the guard removed."}
{"id":"11-01-T3","tp":"refactor","a":"Remove all file fallback paths from helper functions (get_research, get_decisions, get_rolling_summaries, get_error_recovery, get_all_plan_summaries, get_requirements)","f":["scripts/compile-context.sh"],"v":"grep -c 'File fallback' scripts/compile-context.sh returns 0; grep -c 'fallback' scripts/compile-context.sh returns 0","done":false,"spec":"For each helper function that has a DB-first + file-fallback pattern: (1) get_research (lines 152-170): Remove the 'if DB_AVAILABLE' guard -- make SQL query unconditional. Remove lines 165-169 (file fallback reading research.jsonl). (2) get_decisions (lines 173-191): Same pattern -- unconditional SQL, remove lines 186-190 (file fallback). (3) get_rolling_summaries (lines 377-416): Remove DB_AVAILABLE check on line 384, make SQL path unconditional. Remove lines 401-415 (file fallback loop). (4) get_error_recovery (lines 421-445): Remove DB_AVAILABLE check on line 422, make SQL unconditional. Remove lines 434-444 (file fallback). (5) get_all_plan_summaries (lines 449-474): Remove DB_AVAILABLE check on line 450, make SQL unconditional. Remove lines 463-473 (file fallback). (6) get_requirements (lines 268-296): Remove DB_AVAILABLE check on line 271, make SQL unconditional. Remove lines 284-295 (file fallback for reqs.jsonl and REQUIREMENTS.md)."}
{"id":"11-01-T4","tp":"refactor","a":"Remove DB_AVAILABLE conditionals from all role-specific case blocks","f":["scripts/compile-context.sh"],"v":"grep -c 'DB_AVAILABLE' scripts/compile-context.sh returns 0; all 16 role blocks use unconditional SQL","done":false,"spec":"In the main case block (lines 587-1363), every role section that checks DB_AVAILABLE needs cleanup. Affected roles and their patterns: (1) lead (line 650): test_results SQL query -- remove if-guard, keep SQL block, remove elif file fallback. (2) senior (line 702): suggestions SQL -- remove if-guard, keep SQL, remove else file fallback loop. (3) qa (lines 816-828): test_results -- remove if-guard, keep SQL, remove elif fallback. (4) qa (lines 862-874): escalation counts -- remove if-guard, keep SQL, remove elif file fallback. (5) qa-code (lines 888-909): files_to_check from DB summaries -- remove if-guard, keep SQL, remove else file-reading loop. (6) integration-gate (lines 1014-1027): test_results -- same pattern. (7) integration-gate (lines 1042-1052): summaries -- remove if-guard, keep SQL, remove else loop. (8) security (lines 1072-1093): files_to_audit from DB summaries -- same pattern. (9) scout (lines 1170-1181): critique directives -- remove if-guard, keep SQL, remove elif file fallback. (10) debugger (lines 1119-1130): gaps -- same pattern. Also remove the cached flag on line 568-570 (DECISIONS_EXISTS override when DB available)."}
{"id":"11-01-T5","tp":"refactor","a":"Remove DB population hook (JSONL-to-DB resync) and phase metadata file fallback","f":["scripts/compile-context.sh"],"v":"grep -c 'IMPORT_SCRIPT' scripts/compile-context.sh returns 0; grep -c 'JSONL fallback' scripts/compile-context.sh returns 0","done":false,"spec":"Remove lines 307-329 (the DB population hook that resyncs stale JSONL into DB). This auto-import block is a backward compat feature -- with DB as sole store, JSONL files are not written so there is nothing to resync. Also simplify the phase metadata extraction (lines 92-131): remove the 'File fallback: parse ROADMAP.md' block (lines 113-131). Keep only the SQL path for PHASE_GOAL/PHASE_REQS. If SQL returns empty, keep 'Not available' as default (the fail-fast in T2 ensures DB exists, but table may be empty for new phases). Remove the ROADMAP variable assignment on line 93 if no longer used anywhere else in the file."}
