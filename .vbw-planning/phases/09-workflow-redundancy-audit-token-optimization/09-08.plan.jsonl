{"phase":"09","plan":"09-08","title":"Cross-phase research persistence and escalation state","wave":3,"depends_on":["09-04","09-07"],"must_haves":["research-archive.jsonl persists across phases","Escalation state persisted for pause/resume","Multi-department handoff artifacts defined"]}
{"id":"T1","title":"Add research-archive.jsonl schema and persistence logic","file":"references/artifact-formats.md","action":"modify","desc":"Add new section 'Research Archive' to artifact-formats.md defining research-archive.jsonl schema: {\"q\":\"question\",\"finding\":\"answer\",\"conf\":N,\"phase\":\"NN\",\"dt\":\"ISO\",\"src\":\"scout|architect|lead\"}. This file lives at .yolo-planning/research-archive.jsonl (not per-phase). Scout and Architect append findings. Before Scout spawns, orchestrator checks archive for matching questions (fuzzy match on q field) and includes cached findings in Scout context to avoid re-research."}
{"id":"T2","title":"Implement research archive check in go.md Scout spawn","file":"commands/go.md","action":"modify","desc":"In go.md execute mode Step 2 (Research), before spawning Scout, add: 'Check .yolo-planning/research-archive.jsonl for cached research matching the critique questions. For each question, search archive q field for similar terms. If found with conf >= 0.7, include cached finding in Scout context and note it as cached. Scout only researches questions not found in archive.' After Scout completes, append new findings to research-archive.jsonl."}
{"id":"T3","title":"Persist escalation state for pause/resume","file":"scripts/state-updater.sh","action":"modify","desc":"In state-updater.sh, add escalation state tracking. When an escalation is created (via check-escalation-timeout.sh or agent escalation), write to .yolo-planning/.escalation-state.json: {\"escalations\":[{\"id\":\"E1\",\"agent\":\"...\",\"severity\":\"...\",\"status\":\"pending|resolved\",\"created_at\":\"ISO\",\"resolved_at\":\"ISO|null\"}]}. On /yolo:resume, read this file and re-present any pending escalations to the user. On /yolo:pause, preserve the file. Add read/write functions: save_escalation_state() and load_escalation_state()."}
{"id":"T4","title":"Define multi-department handoff artifact schema","file":"references/handoff-schemas.md","action":"modify","desc":"Add explicit handoff artifact schemas to handoff-schemas.md for cross-phase handoffs: (1) phase-handoff.jsonl: {\"from_phase\":\"NN\",\"to_phase\":\"MM\",\"decisions\":[...],\"open_issues\":[...],\"dt\":\"ISO\"}, (2) dept-handoff.jsonl: {\"from_dept\":\"...\",\"to_dept\":\"...\",\"artifacts\":[...],\"contracts\":[...],\"dt\":\"ISO\"}. These are written by the orchestrator at phase completion and read at next phase start."}
{"id":"T5","title":"Update resume.md to restore escalation state","file":"commands/resume.md","action":"modify","desc":"In resume.md, add step: 'Read .yolo-planning/.escalation-state.json. If pending escalations exist, present to user: \"Resumed with N pending escalations: [list]. Resolve or dismiss before continuing.\" User can dismiss (mark resolved) or address each. This prevents lost escalation context across pause/resume cycles.'"}
